= Parse and Load MASL Activity

xtUML Project Design Note

== 1 Abstract

MASL action language shall be parsed and loaded into an xtUML model of
MASL activity.  This note documents design steps to achieve this parsing.

== 2 Introduction and Background


== 3 Requirements


== 4 Analysis

=== 4.1 Notes

* Some attribute names (and perhaps other names) used in the Java model
  will need to be changed due to being MASL reserved words.
* In a supertype/subtype hierarchy, it is difficult to tell from the java
  model where a relationship should be formalized.
  ** I think java will tend to link at the lowest level.
* Define an overloadable unique ID type.  Consider using the strategy that
  Ciera uses.  Consider Position.  Note that row/column is not sufficient
  because nested expressions can be anchored at the same row/column.
  Ciera uses evaluation incrementing order.  Another thought is a
  3 dimensional row/column/layer or some such.  Another thought is to
  do something like `anltr` does.  In any case, it will likely be inherited.
* We should add supertypes MarkableElement and UnmarkableElement and subtype
  the elements in a separate package.  This was done in the xtuml2masl
  model cleanly.

=== 4.2 Questions

* (T) What is a 'Skeleton'?  (e.g. `getFindSkeletonInner`)
* Do I need forward declaration in the metamodel?
  ** __I think 'no'.  This is part of what distinguishes an abstract model
     from syntax.__
* To what extent shall the MM carry "syntactic baggage"?
  ** __I kinda like having 'position' as an identifier.  It should be the
     identifier of a supertype linked from a separate package called
     'parsable element'.__
* Should we use typeReference or link directly to Type (e.g. for an object attribute)?
  ** __I think 'yes, we use typeReference.'__
* (T) How (technical mechanics) is 'position' used as an identifier?
* (T) How do we divine identifiers, referentials and associations from the
  java model?
  ** __It appears that most attributes with types of other objects are
     referential/associations.__
* (T) How do we divine multiplicity and conditionality from the java model?
  ** __Multiplicity can (partly) come from finding list objects on the
     participant side.__
* Does `xtuml2masl` support subsystem packages?
  ** __Yes.__
* How are we going to import and then edit?
  ** Should we import the entire model and then break it into subsystems?
  ** Should we import subsystems and then link them with spanning relationships?
* (T) Why are AnonymousStructure and CollectionType not in the Walker?
* (T) Could I get a review of the MASL subystems before the importing starts?

=== 4.3 More Notes

* The MASL MC has java java and C++ java.  The former is the model, parser
  and loader.  The latter is the serializer.
  ** The model, parser and loader are the points of interest.
* We need to generate MASL from mcooa.  It might be good to imbed the model
  of MASL Activity into the OOAofOOA so that spanning relationships can be
  redirected to structural xtUML classes.
  ** I want to reconsider this.
     *** full native OOA of MASL populated from OOAofOOA like we populate
         the current model of structural MASL (masl)
     *** full native OOA of MASL populated from parsed MASL generated using
         `xtuml2masl`
* I suspect we need to refactor mcooa sooner rather than later.  Translation
  Extensions needs to be pulled out first.  Then, a plan for separating the
  Activity subsystems so that OOA and MASL can be different configurations.
* In addition to 'new' constructors, there are '.create' constructors.
* The imports in Walker.g are a concise list of the MM classes arranged
  nicely into subsystems:  code, common, domain, error, exception, expression,
  name, object, project, relationship, statemodel and type.
  ** I wonder about comparing the structural portion of this MM to the one
     we built from scratch for `xtuml2masl`.
  ** Consider comparing these and the implications of deprecating one or
     the other.
* I note that member storage in classes is not always ordered exactly as
  listed in the constructor (e.g. see AttributeDeclaration).
* Referentials are not really present in the java object model.  Therefore,
  identifier propagation will need to occur "from the top down".
  ** I wonder if we will want to use BridgePoint to formalize the associations?
  ** Maybe import the model with unformalized associations and then formalize
     them after the model is layed out.
* Will `masl2xtuml` be able to process such a large model?
* 'parsable element'
  ** I decided I kinda like 'position' as identifier and was trying to
     understand why.  I think this might be kind-of-a link between the
     textual/syntactic world and the information world.  Instead of position,
     consider a special id type (not unique_id but user defined).  'position'
     should be a type, not an attribute.  The attribute can be 'id' of type
     'position'.
  ** Every element that has a parsable position is a subtype of 'parsable
     element' and is shown as a subtype in a separate package.  This is akin to
     packageable_element and also to markable and unmarkable elements in our
     masl model.
  ** Completely artificial identifiers bug me (for some reason).
  ** I hope that I do not like this idea because of "cleverness".

== 5 Design

. background and research
  .. Find masl_types.xtuml.
  .. Generate MASL from mtypes.xtuml for comparison.
  .. Experiment:
     ... Build a MASL model with 2 classes, 1 association, not formalized.
     ... See what it imports like.
     ... *Results:*  Imports just fine.  Reconcile graphics links the
         associations even when not formalized.
  .. Experiment:
     ... Build an xtUML model with 2 subsystems and a spanning relationship.
     ... Export MASL.
     ... See if all classes are emitted and spanning associations correct.
     ... *Results:*  It worked great.
  .. Perform the prescribed steps on the 'types' subsystem and see how it goes.
  .. sed/grep/awk (or use a Python script) to extract class names and
     initial attribute names/types.
  .. Get `xtuml2masl` working with package references.
. subsystems
  .. Establish subsystems.
     ... code, common, domain, error, exception, expression,
         name, object, project, relationship, statemodel and type.
     ... Establish subsystem number scheme to be used for class numbers
         (after import) and relationship numbers.
     ... Create a `.mod` file for each subsystem.
     ... Convert classes in each subsystem per steps starting at 'classes'
         below.
     ... Consider building some associations completely in the editor.
         .... The classes could be imported, layed out, printed.  The
              prinouts could be used to draw associations.  Formalization
              could be a last step with the sequence and ordering marked
              or colored on the class diagrams.
  .. types
     ... Define an overloadable unique ID type.
     ... Define instance types for the java reference attributes of the form:
         `private type iObject is instance of Object;`.  These will be deleted
         as they are replaced with referentials during formalization.
     ... ??? preexisting type instances ???
  .. classes
     ... Add classes to each subsystem starting with the class list from
         imports in `Walker.g`.
     ... Add additional classes from the metamodel folder.
     ... Potentially refine class list with production rules from `MaslP.g`.
     ... Add referenced spanning classes from other systems with a prefix
         'Imported_<class>'.
  .. attributes
     ... attribute names
         .... Extract and align with .java classes in metamodelImpl folder
              for all attributes and types.
         .... Swap the order of the name and type.
         .... Align with .java classes in metamodel folder for non-referential
              attributes.
         .... Change attribute names for any reserved words.  Provide a
              comment on the attribute giving the original name.
              [TODO - What is the scheme for changing these names?]
     ... attribute types
         .... Supply types with names from the .java classes in metamodelImpl
              folder for all attributes and types.
     ... identifiers
         .... Establish preferred and secondary identifiers when noted as a
              reference in a related formalizing class.
     ... referentials
         .... Referentials will be established during association
              formalization after layout.
         .... While editing the MASL, add/modify referential place-holders.
              On the "List" side, leave a placeholder named 'R_List_' followed
              by the original list name.  Make it of type integer.  This will be
              removed later, but serves as a bread crumb while editing.
         .... On the formalizer side, add 'R_' followed by the original
              name of the java reference member (if one exists).
  .. associations
     ... Divine associations by finding java reference members.  Note that
         a reference member may refer _through_ the supertype to the super-
         supertype (as with collection types).
     ... Assign numbers in sequence and then renumber them after the model
         is complete.
     ... Refine the above by interrogating addXXX methods and assigning
         associations for these.
         .... The participant provides the addXXX method.
     ... Find 'super' invocations to link subtypes to supertypes.
     ... After importing the model, formalize associations.
     ... Take care when formalizing; plan the ordering for propagation.
     ... Delete reference attributes that have been replaced by referential
         attributes.
  .. marking
     ... Add marking subsystem with MarkableElement (and UnmarkableElement).
         Subtype appropriately.
     ... Add Pragma and PragmaList to this subsystem.
     ... If avoidance of polution of the semantic model is desired, use an
         associative class to link PragmaList to the participating markable
         model elements.
. layout
  .. Tease each subsystem apart and lay out logically.
  .. Combine subsystem packages into single model.
  .. Replace each 'Imported_' class with a BridgePoint Imported class linked
     from the spanned subsystem.
. testing
  .. Perform masl_round_trip on the MASL `.mod` files at various steps.
     ... For each subsystem, test when classes are established but before
         associations have been added.
     ... For each subsystem, test when associations have been added.
     ... Test combined packages.
     ... Write a small model compiler to generate the metamodel .java
         classes.

== 6 Design Comments

== 7 User Documentation

== 8 Unit Test

== 9 Document References

. [[dr-1]] https://support.onefact.net/issues/11745[11745 - Parse MASL into xtUML meta-model of MASL activity]
. [[dr-2]] https://support.onefact.net/issues/11744[11744 - AWS software architecture]

---

This work is licensed under the Creative Commons CC0 License

---

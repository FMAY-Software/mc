= OOA of MASL:  Parse and Load MASL Activity

xtUML Project Design Note

== 1 Abstract

MASL action language shall be parsed and loaded into an xtUML model of
MASL activity.  This note documents design steps to achieve this parsing.

== 2 Introduction and Background


== 3 Requirements


== 4 Analysis

=== 4.1 Notes

* Some attribute names (and perhaps other names) used in the Java model
  will need to be changed due to being MASL reserved words.
* In a supertype/subtype hierarchy, it is difficult to tell from the java
  model where a relationship should be formalized.
  ** I think java will tend to link at the lowest level.
* Explore an overloadable unique ID type.  Consider using the strategy that
  Ciera uses.  Consider Position.  Note that row/column is not sufficient
  because nested expressions can be anchored at the same row/column.
  Ciera uses evaluation incrementing order.  Another thought is a
  3 dimensional row/column/layer or some such.  Another thought is to
  do something like `anltr` does.  In any case, it will likely be inherited.
* We should add supertypes MarkableElement and UnmarkableElement and subtype
  the elements in a separate package.  This was done in the xtuml2masl
  model cleanly.
* The MASL MC has java java and C++ java.  The former is the model, parser
  and loader.  The latter is the serializer.
  ** The model, parser and loader are the points of interest.

=== 4.2 Questions

* (T) What is a 'Skeleton'?  (e.g. `getFindSkeletonInner`)
* Do we need forward declaration in the metamodel?
  ** __I think 'no'.  This is part of what distinguishes an abstract model
     from syntax.__
* To what extent shall the MM carry "syntactic baggage"?
  ** __Having 'position' as an identifier seems positive.  It should be
     the identifier of a supertype linked from a separate package called
     'parsable element'.__
* Should we use TypeReference or link directly to Type (e.g. for an object
  attribute)?
  ** __I think 'yes, we use TypeReference.'__
* (T) How (technical mechanics) is 'position' used as an identifier?
* (T) Can we divine identifiers, referentials and associations from the
  java model?
  ** __It appears that most attributes with reference types to other objects
     are referential/associations.__
* (T) How do we divine multiplicity and conditionality from the java model?
  ** __Multiplicity can (partly) come from finding list objects on the
     participant side.__
* Does `xtuml2masl` support subsystem packages?
  ** __Yes.__
* (T) Why are AnonymousStructure and CollectionType not in Walker.g?

=== 4.3 More Notes

* We may want to generate MASL from mcooa.  It might be good to imbed the
  model of MASL Activity into the OOAofOOA so that spanning relationships
  can be redirected to structural xtUML classes.
  ** I want to reconsider this.
     *** full native OOA of MASL populated from OOAofOOA like we populate
         the current model of structural MASL (masl) populated using serial
         MASL
     *** full native OOA of MASL populated from parsed MASL generated using
         `xtuml2masl`
* We may want to refactor mcooa sooner rather than later.  Translation
  Extensions needs to be pulled out first.  Then, a plan for separating the
  Activity subsystems so that OOA and MASL can be different configurations.
* In addition to 'new' constructors, there are '.create' constructors.
* The imports in Walker.g are a concise list of the MM classes arranged
  nicely into subsystems:  code, common, domain, error, exception, expression,
  name, object, project, relationship, statemodel and type.  However, a few
  classes from these subsystems are not represented in the list.
  ** Consider comparing the structural portion of this MM to the one built
     from scratch for `xtuml2masl`.
  ** Consider a comparison of these and the implications of deprecating one
     or the other.
* Note that member storage in classes is not always ordered exactly as
  listed in the constructor (e.g. see AttributeDeclaration).
* Referentials are not really present in the java object model.  Therefore,
  identifier propagation will need to occur "from the top down".
  ** We may want to use BridgePoint to formalize the associations.
  ** It appears feasible to import the model with unformalized associations
     and then formalize them after the model is layed out.
* Is `masl2xtuml` capable of processing models the size of these subsystems?
  ** __So far, it proves to be strong enough.__
* 'parsable element'
  ** 'position' as identifier seems a strong concept.  It may prove to be
     a link between the textual/syntactic world and the information world.
     Instead of position, consider a special id type (not unique_id but
     user defined).  'position' should be a type, not an attribute.  The
     attribute can be 'id' of type 'Position'.
  ** Every element that has a parsable position is a subtype of 'parsable
     element' and is shown as a subtype in a separate package.  This is akin
     to PackageableElement in the BP OOA of OOA and also to markable and
     unmarkable elements in our 'masl' model.

== 5 Design

. background and research
  .. Find `masl_types.xtuml`.
  .. Generate MASL from `masl_types.xtuml` for comparison.
  .. Experiment:
     ... Build a MASL model with 2 classes, 1 association, not formalized.
     ... Import as xtUML into BridgePoint.
     ... *Results:*  Imports just fine.  Reconcile graphics links the
         associations even when not formalized.
  .. Experiment:
     ... Build an xtUML model with 2 subsystems and a spanning relationship.
     ... Export MASL.
     ... See if all classes are emitted and spanning associations correct.
     ... *Results:*  It works nicely.
  .. Perform the steps prescribed below on the 'types' subsystem and
     vet the process.
  .. Sed/grep/awk (or use a Python script) to extract class names and
     initial attribute names/types.
  .. Get `xtuml2masl` working with package references and/or without
     needing a component.
. subsystems
  .. Establish subsystems.
     ... code, common, domain, error, exception, expression, name, object,
         project, relationship, statemodel, type, parsable_element, marking.
     ... Establish subsystem number scheme to be used for class numbers
         (after import) and relationship numbers.
     ... Create a `.mod` file for each subsystem.
     ... Convert classes in each subsystem per steps starting at 'classes'
         below.
     ... Consider building some associations completely in the editor.
         .... The classes could be imported, layed out, printed.
         .... The printouts could be used to draw associations.
         .... Formalization can be a last step with the sequence and
              ordering marked or colored on the class diagrams.
  .. types
     ... Define an overloadable unique ID type.
     ... Define instance types for the java reference attributes of the form:
         `private type iObject is instance of Object;`.  These will be deleted
         as they are replaced with referentials during formalization.
     ... ??? preexisting type instances ???
  .. classes
     ... Add classes to each subsystem starting with the class list from
         imports in `Walker.g`.
     ... Add additional classes from the metamodel folder.
     ... Potentially refine class list with production rules from `MaslP.g`.
     ... Add referenced spanning classes from other subsystems with a prefix
         'Imported_<class>'.
  .. attributes
     ... attribute names
         .... Extract and align with .java classes in metamodelImpl folder
              for all attributes and types.
         .... Swap the order of the name and type.
         .... Align with .java classes in metamodel folder for non-referential
              attributes.
         .... Change attribute names for any reserved words.  Provide a
              comment on the attribute giving the original name.
              [TODO - What is the scheme for changing these names?]
     ... attribute types
         .... Supply types with names from the .java classes in metamodelImpl
              folder for all attributes and types.
     ... identifiers
         .... Establish preferred and secondary identifiers when noted as a
              reference in a related formalizing class.
     ... referentials
         .... Referentials will be established during association
              formalization after layout.
         .... While editing the MASL, add/modify referential place-holders.
              On the "List" side, leave a placeholder named 'R_List_' followed
              by the original list name.  Make it of type integer.  This will be
              removed later, but serves as a "bread crumb" while editing.
         .... On the formalizer side, add 'R_' followed by the original
              name of the java reference member (if one exists) to serve
              as bread crumb.
  .. associations
     ... Divine associations by finding java reference members.  Note that
         a reference member may refer _through_ the supertype to the super-
         supertype (as with collection types).
     ... Assign numbers in sequence and then renumber them after the model
         is complete.
     ... Refine the above by interrogating addXXX methods and assigning
         associations for these.
         .... The participant provides the addXXX method.
     ... Find 'super' invocations to link subtypes to supertypes.
     ... After importing the model, formalize associations.
     ... Take care when formalizing; plan the ordering for propagation.
     ... Delete reference attributes that have been replaced by referential
         attributes.
  .. marking
     ... Add marking subsystem with MarkableElement (and UnmarkableElement).
         Subtype appropriately.
     ... Add Pragma and PragmaList to this subsystem.
     ... If avoidance of pollution of the semantic model is desired, use an
         associative class to link PragmaList to the participating markable
         model elements.
. layout
  .. Tease each subsystem apart and lay out logically.
  .. Combine subsystem packages into single model.
  .. Replace each 'Imported_' class with a BridgePoint Imported class linked
     from the spanned subsystem.
. testing
  .. Perform masl_round_trip on the MASL `.mod` files at various steps.
     ... For each subsystem, test when classes are established but before
         associations have been added.
     ... For each subsystem, test when associations have been added.
     ... Test combined packages.
     ... Write a small model compiler to generate the metamodel .java
         classes.

== 6 Design Comments

== 7 User Documentation

== 8 Unit Test

== 9 Document References

. [[dr-1]] https://support.onefact.net/issues/11745[11745 - Parse MASL into xtUML meta-model of MASL activity]
. [[dr-2]] https://support.onefact.net/issues/11744[11744 - AWS software architecture]

---

This work is licensed under the Creative Commons CC0 License

---

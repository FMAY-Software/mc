---

This work is licensed under the Creative Commons CC0 License

---

# Add Graphics to Model
### xtUML Project Design Note


1. Abstract
-----------
Add graphics to a model with no graphics.

2. Document References
----------------------
<a id="2.1"></a>2.1 [BridgePoint DEI #8238](https://support.onefact.net/issues/8238) This issue.  
<a id="2.2"></a>2.2 analysis note for #8238:  8238_render_graphics.ant.md  
<a id="2.3"></a>2.3 [cell phone photo of original `widget` model](https://github.com/xtuml/mc/doc/notes/8238/widget.jpg)  

3. Background
-------------
Work for [2.2] using the existing auto-reconciliation code has been
a challenge.  The existing code was incomplete and had many bugs.
The more mechanical alternative described in the analysis note is
outlined here.

4. Requirements
---------------
4.1 Create shapes in correct packages for all xtUML elements in a project.
4.2 Created shapes shall be grid into a matrix with reasonable spacing.
4.2.1 The grid shall be greater than 1 dimension (not just 1 row).
4.3 Create connectors in the correct packages.
4.3.1 Connectors shall be drawn between all participating widgets.
4.3.2 Connectors with just one participating widget shall also be drawn.

5. Analysis
-----------
5.1 Adding All Graphics  
Since all graphics need to be added to models, the concept of 'reconcile'
is not needed and adds complexity.  The requirement is to add graphics to
a model which has no graphics to begin with.  There are no existing
graphics to reconcile against.

5.2 No Change to Existing BridgePoint
Adding model graphics before Import means that no change is needed to
existing BridgePoint code.  This eliminates the exposure of breaking
existing functionality.  Also, considering the complexity and build times
of BridgePoint, this is an advantage.

5.3 Less Testing  
The change set for the alternative approach has grown large, 80,000+
lines of code.  The data filter approach will be less code and will
be outside of BridgePoint proper.

6. Design
---------
6.1 Sibling Model to `docgen` (and `masl2xtuml`)  
`docgen` and `masl2xtuml` perform similar functions to what is
needed for graphics rendering.  The flow consists of loading an
xtUML model from its SQL data into the xtUML meta-model, selecting
and interating over the instances of package, component, class,
state, association, transition, etc.  Instead of rendering XML
document data as in `docgen`, we will render SQL INSERT statements
for graphics diagrams of models.

6.1.1 Create `grafgen` Project  
Create a project as a sibling `docgen` in the `mc` repository.
Enable IPR and provide visibility to `mcooa` and `mcshared`.

6.2 Model of Graphics  
BridgePoint already has a model of graphics.  However, it has more detail
than needed for this project.  Also, it is only part of what needs to be
rendered.  GEF (`DIM_*`) shape and connector instances are part of rendered
graphical elements.  For a single figure (class, component, state, etc.) or
coupler (association, transtion, etc.) in a model, a number model elements
are persisted that coordinate to represent the figure or coupler drawn.  
6.2.1 `diagram`  
I diagram is a diagram.  It is a single drawing.  It is full of widgets.
It is the "root" of all visible elements.  
6.2.1 `widget`  
A widget is the supertype of figure and coupler.  Everything in the graphics
rendering has a location and takes space on the diagram.  
6.2.1 `figure`  
A figure is a shape.
6.2.1 `coupler`  
6.2.1 `junction`  

6.3 Templates  
Templates are created for each figure and coupling.

Shapes are identical except for some sort of ID/index that likely chooses a widget graphic blob.

Shapes have an ID that links them to OOA.

Connectors are complex and seem to be associated with an anchor shape somehow.

A model compiler demo could be done inside BP using generator in the gen folder.

Navigate from system to the root package.
Create a model root (GD_MD) 

select one ep_pkg related by s_sys->ep_pkg[main system package]
create GD_MD (with template)
select many ep_pkgs related by ep_pkg->EP_PKG[children]
for each ep_pkg in ep_pkgs
  select many c_cs related by ep_pkg->
  for each c_c
T   create GD_MD
T   add shape for C_C
    select many ep_pkgs related by c_c->EP_PKG
    for each ep_pkg
T     create GD_MD
T     add shape for EP_PKG
      select many o_objs related by ep_pkg->O_OBJ
      for each o_obj
T       add shape with X,Y and link to GD_MD and link to o_obj
        shift X, Y
        select one sm_ism related by o_obj->SM_SM->SM_ISM
        if ( not_empty sm_ism )
T         create GD_MD
          select many sm_states related by sm_sm->SM_STATE
          for each sm_state in sm_states
T           add shape with X,Y and link to GD_MD and link to sm_ism
            shift X, Y
        if ( not_empty sm_asm )
T         create GD_MD
          select many sm_states related by sm_sm->SM_STATE
          for each sm_state in sm_states
T           add shape with X,Y and link to GD_MD and link to sm_asm
            shift X, Y
      select many r_rels related by o_objs->R_OIR->R_REL
      for each r_rel in r_rels
T       add connector linked to anchor
T       add connector with X1,Y1 and X2,Y2 and link to GD_MD and link to sm_ism



challenges:
- UUIDs (hmmm, maybe not)
  + generator will work in integer ID land
  + need to keep the UUIDs
  + New generator does not need the integer IDs.

I notice that DIM_CONs do not get deleted and cleaned up when state
transitions are deleted.  Junk accumulates.

The ID of the shape is a small integer number like 41 (state), 42 (transition),
49 (creation transition).
The IDs are connected to OOA at GD_GE.
Other IDs are interconnected within graphics and thus can be factoried
carefully.

Print the following onto paper.  Use colored pencils to high-light and label
the template variables.
- T snapshot empty state machine
- T snapshot 1 state
- T snapshot creation transition
- snapshot 2 state
- T snapshot transition between them
- factor out the state widget
- factor out the transition widget
- factor out the creation transition widget
- make templates of these with template variables:
  OOA ID, x0, y0, x1, y1, srcID, dstID

7. Design Comments
------------------
7.1 Item 1  

8. Unit Test
------------
8.1 Item 1  

End
---


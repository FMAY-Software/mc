Prepare the model to build docgen
---------------------------------
- Switch to xtUML Modeling Perspective.  
- Delete the "context_menu" and "ooaofooa_heirarchy" domains
- Right click on the com.mentor.nucleus.bp.core project, select 
  "Cleanse for Model Compiler" from the context menu. (NOTE: this step 
  requires that your environment contains at least version 1.0.2 of plug-in 
  com.mentor.nucleus.bp.internal.tools from 
  \\wv\dfs\bridgepoint\engineering_releases\VSx_Dev )
  - Select "Yes" to the question dialog about removing model elements
  - The model will be cleansed.  This removes, operations, functions, MDAs, and
    Body instances and everything associated with them like params, activities,
    etc.  It will leave these activities in DocGen and MC related packages.
- Remove the Local and Runtime Value subsystems.  Note that this will modify the
  Instance subsystem.
** DO NOT CHECK THIS MODIFIED/CLEANSED MODEL IN ON TOP OF THE MC-* BRANCH YOU 
   ARE WORKING IN.


How to build docgen.exe
------------------------
NOTE: You must have source C model compiler already configured.

- Go to Properties->Builders and turn off all builders except for
  the model compiler pre-build and MC-3020 Builder.
- From the C/C++ Projects perspective, find .externalToolBuilders and refresh.
- Edit gen/domain.mark to not exclude any subsystem excludes, comment out all
    .invoke MarkExcludeSubsystemFromCodeGen(...) lines
- If you build now, this will generate the schema.  See additional information 
    about schema creation in HOWTO Create MC-3020 HEAD branch.txt.
- Rename schema_gen.arc to schema_gen.ark.
- Copy folder "/gen/docbook_h" into "src" folder
- Rename folder "/src/docbook_h" to "/src/docbook"
- Build (again), this will do code gen for the whole system.  Scan the Console
    for code generation errors.
- Refresh src/
- Copy com.mentor.nucleus.bp.core_sys_types.h and ooaofooa_classes.h into /gen.
- Open gen/com.mentor.nucleus.bp.core_sys_types.h, replace 3 occurances of 
    "COM.MENTOR.NUCLEUS.BP.CORE_SYS_TYPES_H" with "COM_MENTOR_NUCLEUS_BP_CORE_SYS_TYPES_H"
- Open src/ooaofooa_I_TIM_class.h and add "l_t" as the type of the expiration attribute.
- Edit domain.mark to exclude everything except Document Subsystem (to work with modifying Document).
- Enable CDT Builder and Scanner Configuration Builder in the project Properties
- Build again, this will gen only the Document Subsystem and compile using the
    active CDT build configuration (set via Project > Build Configurations > Set Active > Debug | Release).
    o Output will be <project>/Debug/docgen.exe or <project>/Release/docgen.exe
 
    
    
To build on the command line using cygwin
------------------------------------------
- Open cygwin, navigate to the /src folder:
    To compile for debugging:
    - gcc -g -c *.c
    - gcc *.o
    - should now have a.exe

    To compile only the latest changes in DocGen function package:
    - gcc -g -c ooaofooa_functions.c
    - gcc *.o

    To do a release build:
    - gcc -O2 -mno-cygwin *.c -o docgen.exe // on Linux, i686-w64-mingw32-gcc



Running DocGen
--------------
- To run DocGen inside Verifier
  o Create src/lib/
  o Copy libsrc/*.java to src/lib/
  o Build the project with the Java Builder only
  o Check out <SVN>/trunk/Models/Test/DocGenTest
  o Create a Model Verifier Application launch configuration for the bp.core project
  o Run this launch config
  o In session explorer, expand bp.core/ooaofooa/DocGen
  o Execute docgen_load_project
  o Execute docgen
  o doc.xml will be created in the gen/ folder of the project
  
  NOTE: You can use other models, but they must be a sibling to the bp.core 
        project in the workspace and they must be (re)named DocGenTest or you 
        must modify docgen_load_project for the model name you want to use.
  NOTE2: doc.xml is appended to each time docgen is run.  You must manually
         delete it between runs.
               
- If you need to run docgen.exe by hand for testing, build your sample model
  with MC3020, this will give you gen/code_generation/_system.sql
  o To debug with CDT inside eclipse, copy this _system.sql to 
    com.mentor.nucleus.bp.core/a.xtuml, then create a debug launch configuration
    of type C/C++ Application that points to Debug/docgen.exe
  o To run via the command line, copy this _system.sql to a.xtuml as a directory
    sibling of docgen.exe, then just execute ./docgen.exe





Building mcmc (which serves to be both mcmc and docgen).
-------------

Summary:
- Convert RSL queries into OAL and import into model of model compiler.
- Convert RSL templates into C code templates.
- Build dynamic template engine.
- Generate C code from model compiler model.
- Compile and link.

Needed:
- rsl2oal (xtuml/mc/mcmc/arlan)
- current_list.sh (xtuml/mc/mcmc/arlan)
- convert_templates.sh (xtuml/mc/mcmc/arlan)
- Linux BridgePoint installation (primary)
- golden source from previous build (xtuml/mc/model/com.mentor.nucleus.bp.core/src410)

Update the RSL-to-OAL translator.
- Create function signatures for OAL from the RSL by running the
  the following in the mc/arc folder:
  + egrep -r -e "^\.function " -e "^ *\.param " -e ".end function" * | awk '{if ($1 ~ ".function") printf("{\"%s\"",$2); else if ($0 ~ "\.param ") printf(",\"%s\"",$4); else if ($1 ~ ".end" && $2 ~ "function") printf("},\n");}' > ~/funcsigs.h
  + Then, vimdiff into funcsig.h in the xtuml/mc/mcmc/arlan directory.
  + make -f makefile.rsl2oal
  + Copy lex.yy.c

Run the rsl2oal translator.
- Run current_list.sh to translate RSL to OAL.
  + diff with old version of o.oal, o2.oal, o3.oal, o4.oal looking for extra
    blank space.  (Clean up that extra blank space.)
- In the MC model, delete functions from afun, afunmark, afunsmt, afunval
  but leave afun::a0.
- Right click on the function packages and import OAL using the BridgePoint
  utility:
  + afun gets o.oal
  + afunval gets o2.oal
  + afunsmt gets o3.oal
  + afunmark gets o4.oal
  Parse all activities.  Fix the following by hand-editing:
    afunstmt:  ${subtypecheck}
    afunstmt:  ${ws}

Update the template engine.
- make -f makefile.template
- Copy lex.yy.c and template_engine.tab.c to /src folder.
- Run convert_templates.sh to translate RSL templates into C code templates.

- Edit ooaofooa.c to get diffs similar to those listed below
- Edit ooaofooa_TE_ABA_class.h:
  + c_t * code;
- Edit ooaofooa_TE_BLK_class.h:
  + c_t declaration[16000];
  + c_t deallocation[8000];
- Edit ooaofooa_TE_SMT_class.h:
  + c_t buffer[2500];

- gcc -DTEMPLATE_ENGINE -Wno-pointer-to-int-cast *.c -lfl -o mcmc











16a17,18
> extern void mark_pass( c_t * );
> 
1730,1731c1732,1733
<     /* ASSIGN s = v_lst.Value */
<     Escher_strcpy( s, v_lst->Value );
---
>     /* ASSIGN s = T::t(s:v_lst.Value) */
>     Escher_strcpy( s, T_t( v_lst->Value ) );
1733c1735
<     if ( ( Escher_strcmp( ({, s ) == 0 ) ) {
---
>     if ( strstr(s,"({") ) {
3096,3097c3098,3099
<     /* T::b( s:ws ) */
<     T_b( ws );
---
>     /* T::b( s:} ) */
>     T_b( "}" );
3100a3103,3104
>     /* T::b( s:\n ) */
>     T_b( "\n" );
6951c6955
<   Escher_strcpy( s, p_s );
---
>   //Escher_strcpy( s, p_s );
6953c6957,6958
<   Escher_strcpy( te_aba->code, Escher_stradd( te_aba->code, s ) );
---
>   if ( strlen( p_te_aba->code ) > (400000-ESCHER_SYS_MAX_STRING_LEN) ) fprintf( stderr, "TE_ABA:  Code is too big!\n" );
>   else strcat( p_te_aba->code, p_s );
6967c6972
<   Escher_strcpy( s, p_s );
---
>   //Escher_strcpy( s, p_s );
6969c6974,6975
<   Escher_strcpy( te_blk->deallocation, Escher_stradd( te_blk->deallocation, s ) );
---
>   if ( strlen( p_te_blk->deallocation ) > (8000 - ESCHER_SYS_MAX_STRING_LEN) ) fprintf( stderr, "TE_BLK:  Deallocation is too big!\n" );
>   else strcat( p_te_blk->deallocation, p_s );
6983c6989
<   Escher_strcpy( s, p_s );
---
>   //Escher_strcpy( s, p_s );
6985c6991,6992
<   Escher_strcpy( te_blk->declaration, Escher_stradd( te_blk->declaration, s ) );
---
>   if ( strlen( p_te_blk->declaration ) > (16000 - ESCHER_SYS_MAX_STRING_LEN) ) fprintf( stderr, "TE_BLK:  Declaration is too big!\n" );
>   else strcat( p_te_blk->declaration, p_s );
6999c7006
<   Escher_strcpy( s, p_s );
---
>   //Escher_strcpy( s, p_s );
7001c7008,7009
<   Escher_strcpy( te_smt->buffer, Escher_stradd( te_smt->buffer, s ) );
---
>   if ( (strlen(p_te_smt->buffer)+strlen(T_body())) > (2500 - 1) ) fprintf( stderr, "TE_SMT:  Buffer is too big!\n" );
>   else strncat( p_te_smt->buffer, T_body(), 2500 - 1 );
7736,7738c7744
<   Escher_strcpy( s, p_s );
<   /* RETURN 0 */
<   return 0;
---
>   return strtol( p_s, 0, 10 );
13685a13692
> T_clear(); 
17214a17222
>   te_aba->code = (c_t *) Escher_malloc( 400000 );
24659a24668
> mark_pass("1");
24661a24671
> mark_pass("2");

-- BP 7.1.6 content: Package syschar: 3 persistence-version: 7.1.6

INSERT INTO EP_PKG
	VALUES ("e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	"d9bc5487-4193-4817-be1c-6c3f3339aebf",
	'afun',
	'',
	0);
INSERT INTO GD_MD
	VALUES ("0621fcb5-c026-4d92-93b3-509f2bbbfd38",
	112,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	108,
	0,
	0,
	1,
	1,
	1,
	12,
	1,
	0,
	0,
	0,
	0,
	0,
	'',
	'com.mentor.nucleus.bp.core::components::ooaofooa::ooaofooa::afun');
INSERT INTO DIM_DIA
	VALUES ("0621fcb5-c026-4d92-93b3-509f2bbbfd38",
	'',
	1.000000,
	4000.000000,
	3000.000000,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO S_SYNC
	VALUES ("17b26926-9233-4f3b-bf40-b2ba7a6e61f2",
	"00000000-0000-0000-0000-000000000000",
	'a0',
	'',
	'::parm_sort();
::rel_pseudoformalize();
::sys_singletons();
::sys_populate();',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("17b26926-9233-4f3b-bf40-b2ba7a6e61f2",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("55b9c2e5-1cb2-4b6c-ace1-26b0d7b37527",
	"00000000-0000-0000-0000-000000000000",
	'sparm_sort',
	'',
	'// CDS temporarily order parameters alphabetically for backwards compatibility
s_sparms = param.s_sparms;
for each s_sparm in s_sparms
  select one prev_s_sparm related by s_sparm->S_SPARM[R54.''precedes''];
  if ( not_empty prev_s_sparm )
    unrelate s_sparm from prev_s_sparm across R54.''precedes'';
  end if;
end for;
// Declare an empty instance reference.
select any head_s_sparm related by s_sparms->S_SPARM[R54.''precedes''] where ( false );
for each s_sparm in s_sparms
  r = ::sparm_insert( head_s_sparm:head_s_sparm, s_sparm:s_sparm );
  head_s_sparm = r;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("89bd4ed9-ab2e-4788-aea3-1672c790110e",
	"55b9c2e5-1cb2-4b6c-ace1-26b0d7b37527",
	's_sparms',
	"a397ce5f-c02a-4167-b722-9876a55f62c0",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("a397ce5f-c02a-4167-b722-9876a55f62c0",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Function Parameter>',
	'',
	'',
	'../Domain/Domain.xtuml');
INSERT INTO PE_PE
	VALUES ("55b9c2e5-1cb2-4b6c-ace1-26b0d7b37527",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("e44b9ce9-a21d-4783-bf94-5ce9a913e161",
	"00000000-0000-0000-0000-000000000000",
	'sparm_insert',
	'',
	'head_s_sparm = param.head_s_sparm;
s_sparm = param.s_sparm;
result = s_sparm;
if ( empty head_s_sparm )
  // Just starting.  Return s_sparm as head.
elif ( s_sparm.Name <= head_s_sparm.Name )
  // insert before
  relate s_sparm to head_s_sparm across R54.''succeeds'';
else
  // find bigger
  result = head_s_sparm;
  prev_s_sparm = head_s_sparm;
  select one cursor_s_sparm related by head_s_sparm->S_SPARM[R54.''succeeds''];
  while ( not_empty cursor_s_sparm )
    if ( s_sparm.Name <= cursor_s_sparm.Name )
      break;
    else
      prev_s_sparm = cursor_s_sparm;
      select one cursor_s_sparm related by cursor_s_sparm->S_SPARM[R54.''succeeds''];
    end if;
  end while;
  relate prev_s_sparm to s_sparm across R54.''succeeds'';
  if ( not_empty cursor_s_sparm )
    relate s_sparm to cursor_s_sparm across R54.''succeeds'';
  end if;
end if;
return result;
',
	"f822fb34-452f-42a9-8480-07154f3890a4",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("ebc36d44-f384-4b4f-903e-39f67c05b85b",
	"e44b9ce9-a21d-4783-bf94-5ce9a913e161",
	'head_s_sparm',
	"f822fb34-452f-42a9-8480-07154f3890a4",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("f822fb34-452f-42a9-8480-07154f3890a4",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Function Parameter>',
	'',
	'',
	'../Domain/Domain.xtuml');
INSERT INTO S_SPARM
	VALUES ("2fc67575-d099-40f8-9909-c217329361a8",
	"e44b9ce9-a21d-4783-bf94-5ce9a913e161",
	's_sparm',
	"f822fb34-452f-42a9-8480-07154f3890a4",
	0,
	'',
	"ebc36d44-f384-4b4f-903e-39f67c05b85b",
	'');
INSERT INTO PE_PE
	VALUES ("e44b9ce9-a21d-4783-bf94-5ce9a913e161",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("195c6cf5-b7cc-425b-89f5-0a843870c624",
	"00000000-0000-0000-0000-000000000000",
	'bparm_sort',
	'',
	'//
//
s_bparms = param.s_bparms;
for each s_bparm in s_bparms
  select one prev_s_bparm related by s_bparm->S_BPARM[R55.''precedes''];
  if ( not_empty prev_s_bparm )
    unrelate s_bparm from prev_s_bparm across R55.''precedes'';
  end if;
end for;
// Declare an empty instance reference.
select any head_s_bparm related by s_bparms->S_BPARM[R55.''precedes''] where ( false );
for each s_bparm in s_bparms
  r = ::bparm_insert( head_s_bparm:head_s_bparm, s_bparm:s_bparm );
  head_s_bparm = r;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("cc0ecb83-0dd3-40e8-8006-a8ce75cbbe88",
	"195c6cf5-b7cc-425b-89f5-0a843870c624",
	's_bparms',
	"15271e51-8d77-4dc6-bc1d-a9cb226962e3",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("15271e51-8d77-4dc6-bc1d-a9cb226962e3",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Bridge Parameter>',
	'',
	'',
	'../Domain/Domain.xtuml');
INSERT INTO PE_PE
	VALUES ("195c6cf5-b7cc-425b-89f5-0a843870c624",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("073f4059-3739-4bea-9c4f-51ffea82c092",
	"00000000-0000-0000-0000-000000000000",
	'bparm_insert',
	'',
	'head_s_bparm = param.head_s_bparm;
s_bparm = param.s_bparm;
result = s_bparm;
if ( empty head_s_bparm )
  // Just starting.  Return s_bparm as head.
elif ( s_bparm.Name <= head_s_bparm.Name )
  // insert before
  relate s_bparm to head_s_bparm across R55.''succeeds'';
else
  // find bigger
  result = head_s_bparm;
  prev_s_bparm = head_s_bparm;
  select one cursor_s_bparm related by head_s_bparm->S_BPARM[R55.''succeeds''];
  while ( not_empty cursor_s_bparm )
    if ( s_bparm.Name <= cursor_s_bparm.Name )
      break;
    else
      prev_s_bparm = cursor_s_bparm;
      select one cursor_s_bparm related by cursor_s_bparm->S_BPARM[R55.''succeeds''];
    end if;
  end while;
  relate prev_s_bparm to s_bparm across R55.''succeeds'';
  if ( not_empty cursor_s_bparm )
    relate s_bparm to cursor_s_bparm across R55.''succeeds'';
  end if;
end if;
return result;
',
	"6ba9a48e-9b83-47fe-a1ac-915dbf9d3ef3",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("eba4c51e-a667-431a-9fd2-362cce7b0ad7",
	"073f4059-3739-4bea-9c4f-51ffea82c092",
	'head_s_bparm',
	"6ba9a48e-9b83-47fe-a1ac-915dbf9d3ef3",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("6ba9a48e-9b83-47fe-a1ac-915dbf9d3ef3",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Bridge Parameter>',
	'',
	'',
	'../Domain/Domain.xtuml');
INSERT INTO S_SPARM
	VALUES ("90ca31e9-2662-4e02-a338-a7fa7c46777a",
	"073f4059-3739-4bea-9c4f-51ffea82c092",
	's_bparm',
	"6ba9a48e-9b83-47fe-a1ac-915dbf9d3ef3",
	0,
	'',
	"eba4c51e-a667-431a-9fd2-362cce7b0ad7",
	'');
INSERT INTO PE_PE
	VALUES ("073f4059-3739-4bea-9c4f-51ffea82c092",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("d3fc8a9c-ac4d-42cc-ad44-9470602449eb",
	"00000000-0000-0000-0000-000000000000",
	'tparm_sort',
	'',
	'//
//
o_tparms = param.o_tparms;
for each o_tparm in o_tparms
  select one prev_o_tparm related by o_tparm->O_TPARM[R124.''precedes''];
  if ( not_empty prev_o_tparm )
    unrelate o_tparm from prev_o_tparm across R124.''precedes'';
  end if;
end for;
// Declare an empty instance reference.
select any head_o_tparm related by o_tparms->O_TPARM[R124.''precedes''] where ( false );
for each o_tparm in o_tparms
  r = ::tparm_insert( head_o_tparm:head_o_tparm, o_tparm:o_tparm );
  head_o_tparm = r;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("c23a9fa3-a2f7-4d70-99fe-cd8b127ea5fe",
	"d3fc8a9c-ac4d-42cc-ad44-9470602449eb",
	'o_tparms',
	"8223e432-cc81-4a56-a7e3-7dbfcea931f2",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("8223e432-cc81-4a56-a7e3-7dbfcea931f2",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Operation Parameter>',
	'',
	'',
	'../Subsystem/Subsystem.xtuml');
INSERT INTO PE_PE
	VALUES ("d3fc8a9c-ac4d-42cc-ad44-9470602449eb",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("776498bc-a7ca-4fe0-b50a-8d6e73b3077a",
	"00000000-0000-0000-0000-000000000000",
	'tparm_insert',
	'',
	'head_o_tparm = param.head_o_tparm;
o_tparm = param.o_tparm;
result = o_tparm;
if ( empty head_o_tparm )
  // Just starting.  Return o_tparm as head.
elif ( o_tparm.Name <= head_o_tparm.Name )
  // insert before
  relate o_tparm to head_o_tparm across R124.''succeeds'';
else
  // find bigger
  result = head_o_tparm;
  prev_o_tparm = head_o_tparm;
  select one cursor_o_tparm related by head_o_tparm->O_TPARM[R124.''succeeds''];
  while ( not_empty cursor_o_tparm )
    if ( o_tparm.Name <= cursor_o_tparm.Name )
      break;
    else
      prev_o_tparm = cursor_o_tparm;
      select one cursor_o_tparm related by cursor_o_tparm->O_TPARM[R124.''succeeds''];
    end if;
  end while;
  relate prev_o_tparm to o_tparm across R124.''succeeds'';
  if ( not_empty cursor_o_tparm )
    relate o_tparm to cursor_o_tparm across R124.''succeeds'';
  end if;
end if;
return result;
',
	"3f86efb0-5d9c-4ace-b91a-14a50aa50c48",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("41f50044-69d0-47a8-8dae-3adb47ae2a66",
	"776498bc-a7ca-4fe0-b50a-8d6e73b3077a",
	'head_o_tparm',
	"3f86efb0-5d9c-4ace-b91a-14a50aa50c48",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("3f86efb0-5d9c-4ace-b91a-14a50aa50c48",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Operation Parameter>',
	'',
	'',
	'../Subsystem/Subsystem.xtuml');
INSERT INTO S_SPARM
	VALUES ("e5839167-1fcd-4049-b3e9-1f482a15ab56",
	"776498bc-a7ca-4fe0-b50a-8d6e73b3077a",
	'o_tparm',
	"3f86efb0-5d9c-4ace-b91a-14a50aa50c48",
	0,
	'',
	"41f50044-69d0-47a8-8dae-3adb47ae2a66",
	'');
INSERT INTO PE_PE
	VALUES ("776498bc-a7ca-4fe0-b50a-8d6e73b3077a",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("cc43add3-6cf2-41e2-8c76-f15d978a34a8",
	"00000000-0000-0000-0000-000000000000",
	'evtdi_sort',
	'',
	'//
//
sm_evtdis = param.sm_evtdis;
for each sm_evtdi in sm_evtdis
  select one prev_sm_evtdi related by sm_evtdi->SM_EVTDI[R533.''precedes''];
  if ( not_empty prev_sm_evtdi )
    unrelate sm_evtdi from prev_sm_evtdi across R533.''precedes'';
  end if;
end for;
// Declare an empty instance reference.
select any head_sm_evtdi related by sm_evtdis->SM_EVTDI[R533.''precedes''] where ( false );
for each sm_evtdi in sm_evtdis
  r = ::evtdi_insert( head_sm_evtdi:head_sm_evtdi, sm_evtdi:sm_evtdi );
  head_sm_evtdi = r;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("6ad2ab00-d28c-4a88-8130-8fdec61d0fda",
	"cc43add3-6cf2-41e2-8c76-f15d978a34a8",
	'sm_evtdis',
	"8d48c15e-5425-419d-a407-d6d4338150d4",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("8d48c15e-5425-419d-a407-d6d4338150d4",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<State Machine Event Data Item>',
	'',
	'',
	'../State Machine/State Machine.xtuml');
INSERT INTO PE_PE
	VALUES ("cc43add3-6cf2-41e2-8c76-f15d978a34a8",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("e7d7fe6f-bf52-4de9-b62f-7aaaa8a94371",
	"00000000-0000-0000-0000-000000000000",
	'evtdi_insert',
	'',
	'head_sm_evtdi = param.head_sm_evtdi;
sm_evtdi = param.sm_evtdi;
result = sm_evtdi;
if ( empty head_sm_evtdi )
  // Just starting.  Return sm_evtdi as head.
elif ( sm_evtdi.Name <= head_sm_evtdi.Name )
  // insert before
  relate sm_evtdi to head_sm_evtdi across R533.''succeeds'';
else
  // find bigger
  result = head_sm_evtdi;
  prev_sm_evtdi = head_sm_evtdi;
  select one cursor_sm_evtdi related by head_sm_evtdi->SM_EVTDI[R533.''succeeds''];
  while ( not_empty cursor_sm_evtdi )
    if ( sm_evtdi.Name <= cursor_sm_evtdi.Name )
      break;
    else
      prev_sm_evtdi = cursor_sm_evtdi;
      select one cursor_sm_evtdi related by cursor_sm_evtdi->SM_EVTDI[R533.''succeeds''];
    end if;
  end while;
  relate prev_sm_evtdi to sm_evtdi across R533.''succeeds'';
  if ( not_empty cursor_sm_evtdi )
    relate sm_evtdi to cursor_sm_evtdi across R533.''succeeds'';
  end if;
end if;
return result;
',
	"aa498bc5-0f18-424e-9588-09bbffb0b5ec",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("a5b3ce3c-ceb5-49ba-8939-350b56e459df",
	"e7d7fe6f-bf52-4de9-b62f-7aaaa8a94371",
	'head_sm_evtdi',
	"aa498bc5-0f18-424e-9588-09bbffb0b5ec",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("aa498bc5-0f18-424e-9588-09bbffb0b5ec",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<State Machine Event Data Item>',
	'',
	'',
	'../State Machine/State Machine.xtuml');
INSERT INTO S_SPARM
	VALUES ("7d3a91a4-a4a7-4c3e-8b91-439ef9b4adff",
	"e7d7fe6f-bf52-4de9-b62f-7aaaa8a94371",
	'sm_evtdi',
	"aa498bc5-0f18-424e-9588-09bbffb0b5ec",
	0,
	'',
	"a5b3ce3c-ceb5-49ba-8939-350b56e459df",
	'');
INSERT INTO PE_PE
	VALUES ("e7d7fe6f-bf52-4de9-b62f-7aaaa8a94371",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("e772fbc1-d49d-45c5-a4e2-a6fff83ebde5",
	"00000000-0000-0000-0000-000000000000",
	'pp_sort',
	'',
	'//
//
c_pps = param.c_pps;
for each c_pp in c_pps
  select one prev_c_pp related by c_pp->C_PP[R4021.''precedes''];
  if ( not_empty prev_c_pp )
    unrelate c_pp from prev_c_pp across R4021.''precedes'';
  end if;
end for;
// Declare an empty instance reference.
select any head_c_pp related by c_pps->C_PP[R4021.''precedes''] where ( false );
for each c_pp in c_pps
  r = ::pp_insert( head_c_pp:head_c_pp, c_pp:c_pp );
  head_c_pp = r;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("310ed607-605d-4ec6-a6a3-72887d5be864",
	"e772fbc1-d49d-45c5-a4e2-a6fff83ebde5",
	'c_pps',
	"47b05aeb-144f-4981-85ca-cec108b82bb7",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("47b05aeb-144f-4981-85ca-cec108b82bb7",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Property Parameter>',
	'',
	'',
	'../Component/Component.xtuml');
INSERT INTO PE_PE
	VALUES ("e772fbc1-d49d-45c5-a4e2-a6fff83ebde5",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("53bcb773-4e45-464a-a6e1-e66f7f464640",
	"00000000-0000-0000-0000-000000000000",
	'pp_insert',
	'',
	'head_c_pp = param.head_c_pp;
c_pp = param.c_pp;
result = c_pp;
if ( empty head_c_pp )
  // Just starting.  Return c_pp as head.
elif ( c_pp.Name <= head_c_pp.Name )
  // insert before
  relate c_pp to head_c_pp across R4021.''succeeds'';
else
  // find bigger
  result = head_c_pp;
  prev_c_pp = head_c_pp;
  select one cursor_c_pp related by head_c_pp->C_PP[R4021.''succeeds''];
  while ( not_empty cursor_c_pp )
    if ( c_pp.Name <= cursor_c_pp.Name )
      break;
    else
      prev_c_pp = cursor_c_pp;
      select one cursor_c_pp related by cursor_c_pp->C_PP[R4021.''succeeds''];
    end if;
  end while;
  relate prev_c_pp to c_pp across R4021.''succeeds'';
  if ( not_empty cursor_c_pp )
    relate c_pp to cursor_c_pp across R4021.''succeeds'';
  end if;
end if;
return result;
',
	"b38e0639-ac8f-4bfb-b8a4-0a2ee533862b",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("06e8e80e-cc0d-40e7-9cf3-23f9735245cc",
	"53bcb773-4e45-464a-a6e1-e66f7f464640",
	'head_c_pp',
	"b38e0639-ac8f-4bfb-b8a4-0a2ee533862b",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("b38e0639-ac8f-4bfb-b8a4-0a2ee533862b",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Property Parameter>',
	'',
	'',
	'../Component/Component.xtuml');
INSERT INTO S_SPARM
	VALUES ("081246b7-29c6-4ebc-b2e3-2ef584b8c22a",
	"53bcb773-4e45-464a-a6e1-e66f7f464640",
	'c_pp',
	"b38e0639-ac8f-4bfb-b8a4-0a2ee533862b",
	0,
	'',
	"06e8e80e-cc0d-40e7-9cf3-23f9735245cc",
	'');
INSERT INTO PE_PE
	VALUES ("53bcb773-4e45-464a-a6e1-e66f7f464640",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b80d00cb-2093-4c9e-bc4f-3566aba18ffd",
	"00000000-0000-0000-0000-000000000000",
	'parm_sort',
	'',
	'//
// CDS temporary for sorting model data parameters
if ( true )
  select many s_syncs from instances of S_SYNC;
  for each s_sync in s_syncs
    select many s_sparms related by s_sync->S_SPARM[R24];
    ::sparm_sort( s_sparms:s_sparms );
  end for;
  select many s_brgs from instances of S_BRG;
  for each s_brg in s_brgs
    select many s_bparms related by s_brg->S_BPARM[R21];
    ::bparm_sort( s_bparms:s_bparms );
  end for;
  select many o_tfrs from instances of O_TFR;
  for each o_tfr in o_tfrs
    select many o_tparms related by o_tfr->O_TPARM[R117];
    ::tparm_sort( o_tparms:o_tparms );
  end for;
  select many sm_evts from instances of SM_EVT;
  for each sm_evt in sm_evts
    select many sm_evtdis related by sm_evt->SM_EVTDI[R532];
    ::evtdi_sort( sm_evtdis:sm_evtdis );
  end for;
  select many c_eps from instances of C_EP;
  for each c_ep in c_eps
    select many c_pps related by c_ep->C_PP[R4006];
    ::pp_sort( c_pps:c_pps );
  end for;
end if;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("b80d00cb-2093-4c9e-bc4f-3566aba18ffd",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("d8a20993-142f-422f-93c7-0ab78f4c2605",
	"00000000-0000-0000-0000-000000000000",
	'rel_pseudoformalize',
	'',
	'//============================================================================
// $RCSfile: q.assoc.pseudoformalize.arc,v $
//
// Description:
// This query/transformation archetype file contains the functionality
// that will allow the model compiler to generate code for unformalized 
// associations (associations that have not been formalized).
//
// Notice:
// (C) Copyright 1998-2013 Mentor Graphics Corporation
//     All rights reserved.
//
// This document contains confidential and proprietary information and
// property of Mentor Graphics Corp.  No part of this document may be
// reproduced without the express written permission of Mentor Graphics Corp.
//============================================================================
//
// Find the associations that are not formalized.  They are characterized
// by the existence of 2 instances of R_PART linked to one R_SIMP.
// Migrate the R_PART/R_RTO pair to R_FORM/R_RGO.
// It does not matter which participant we choose unless this is a many
// association.  Grab the many side of a 1-M or any random R_PART and
// migrate it and its parent R_RTO to R_FORM and R_RGO respectively.
select many r_simps from instances of R_SIMP;
for each r_simp in r_simps
  select many r_parts related by r_simp->R_PART[R207];
  if ( ( cardinality r_parts ) > 1 )
    select any r_part related by r_simp->R_PART[R207] where ( selected.Mult == 1 );
    if ( empty r_part )
      select any r_part related by r_simp->R_PART[R207];
    end if;
    select one r_rto related by r_part->R_RTO[R204];
    select one r_oir related by r_rto->R_OIR[R203];
    //
    create object instance r_rgo of R_RGO;
    create object instance r_form of R_FORM;
    //
    // Copy the R_PART to the new R_FORM.
    r_form.Mult = r_part.Mult;
    r_form.Cond = r_part.Cond;
    r_form.Txt_Phrs = r_part.Txt_Phrs;
    //
    unrelate r_part from r_rto across R204;
    unrelate r_part from r_simp across R207;
    delete object instance r_part;
    //
    unrelate r_rto from r_oir across R203;
    delete object instance r_rto;
    //
    relate r_rgo to r_oir across R203;
    relate r_form to r_rgo across R205;
    relate r_form to r_simp across R208;
  end if;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("d8a20993-142f-422f-93c7-0ab78f4c2605",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("0a402f39-92ab-4e2c-874c-b27c502a46b1",
	"00000000-0000-0000-0000-000000000000",
	'container_factory',
	'',
	'//
te_container = param.te_container;
te_container.flavor = "";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("5263df4e-4f7d-4666-9966-d47ac7f27e0a",
	"0a402f39-92ab-4e2c-874c-b27c502a46b1",
	'te_container',
	"bed7aed0-a8ba-4e93-acaa-c7c0ef17e639",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("bed7aed0-a8ba-4e93-acaa-c7c0ef17e639",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<container>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("0a402f39-92ab-4e2c-874c-b27c502a46b1",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("da964798-1821-40bb-a661-8b5a2c897b61",
	"00000000-0000-0000-0000-000000000000",
	'copyright_factory',
	'',
	'//
//
te_copyright = param.te_copyright;
te_copyright.body = "your copyright statement can go here (from te_copyright.body)";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("b71cd542-5665-4091-92f6-5c5b65a179d2",
	"da964798-1821-40bb-a661-8b5a2c897b61",
	'te_copyright',
	"66047ebf-b4d3-4c3f-ac61-a72efcb39e53",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("66047ebf-b4d3-4c3f-ac61-a72efcb39e53",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<copyright>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("da964798-1821-40bb-a661-8b5a2c897b61",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("1efa41f4-0afd-42aa-8c0e-a956fa564c01",
	"00000000-0000-0000-0000-000000000000",
	'dlist_factory',
	'',
	'//
//
te_dlist = param.te_dlist;
select any te_prefix from instances of TE_PREFIX;
te_dlist.remove_node = te_prefix.result + "SetRemoveDlistNode";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("11e5334f-1790-40ae-bcf3-6af679cd059c",
	"1efa41f4-0afd-42aa-8c0e-a956fa564c01",
	'te_dlist',
	"ae4a14e9-ebe7-41e2-97d0-0b6e1b15ceea",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("ae4a14e9-ebe7-41e2-97d0-0b6e1b15ceea",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<dlist>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("1efa41f4-0afd-42aa-8c0e-a956fa564c01",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("8e01fc7c-0df3-4892-b849-375e1f65896d",
	"00000000-0000-0000-0000-000000000000",
	'dma_factory',
	'',
	'//
//
te_dma = param.te_dma;
select any te_prefix from instances of TE_PREFIX;
te_dma.file = "sys_memory";
te_dma.allocate = te_prefix.result + "malloc";
te_dma.release = te_prefix.result + "free";
te_dma.debugging_heap = false;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("39ccccc4-819b-4f26-ad4b-721bc0c65740",
	"8e01fc7c-0df3-4892-b849-375e1f65896d",
	'te_dma',
	"95c40567-3d38-4e09-ab51-e0a2883d1bae",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("95c40567-3d38-4e09-ab51-e0a2883d1bae",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<dynamic memory allocation>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("8e01fc7c-0df3-4892-b849-375e1f65896d",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("5084715d-2eff-43aa-acae-cf74f4ef0a6d",
	"00000000-0000-0000-0000-000000000000",
	'eq_factory',
	'',
	'//
//
te_eq = param.te_eq;
select any te_prefix from instances of TE_PREFIX;
te_eq.ignored = "EVENT_IS_IGNORED";
te_eq.cant_happen = "EVENT_CANT_HAPPEN";
te_eq.system_events_union = te_prefix.result + "systemxtUMLevents";
te_eq.system_event_pool = te_prefix.result + "xtUML_event_pool";
te_eq.constant_type = te_prefix.result + "xtUMLEventConstant_t";
te_eq.base_event_type = te_prefix.result + "xtUMLEvent_t";
te_eq.base_variable = "mc_event_base";
te_eq.max_events = te_prefix.define_u + "SYS_MAX_XTUML_EVENTS";
te_eq.max_self_events = te_prefix.define_u + "SYS_MAX_SELF_EVENTS";
te_eq.max_nonself_events = te_prefix.define_u + "SYS_MAX_NONSELF_EVENTS";
te_eq.new = te_prefix.result + "NewxtUMLEvent";
te_eq.allocate = te_prefix.result + "AllocatextUMLEvent";
te_eq.delete = te_prefix.result + "DeletextUMLEvent";
te_eq.modify = te_prefix.result + "ModifyxtUMLEvent";
te_eq.self = te_prefix.result + "SendSelfEvent";
te_eq.non_self = te_prefix.result + "SendEvent";
te_eq.search_and_destroy = te_prefix.result + "EventSearchAndDestroy";
te_eq.run_flag = te_prefix.result + "run_flag";
te_eq.event_message_variable = "e";
te_eq.scope = "";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("b5a2a499-6ec1-4f75-9228-df757ef12b65",
	"5084715d-2eff-43aa-acae-cf74f4ef0a6d",
	'te_eq',
	"d6d92349-6671-4f67-b702-a8dcef6f4bab",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("d6d92349-6671-4f67-b702-a8dcef6f4bab",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<event queue>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("5084715d-2eff-43aa-acae-cf74f4ef0a6d",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("4e55db3e-d011-411b-b738-ecedf8989b7a",
	"00000000-0000-0000-0000-000000000000",
	'extent_factory',
	'',
	'//
//
te_extent = param.te_extent;
select any te_prefix from instances of TE_PREFIX;
select any te_set from instances of TE_SET;
select any te_typemap from instances of TE_TYPEMAP;
select any te_instance from instances of TE_INSTANCE;
te_extent.sets_type = te_set.base_class;
te_extent.type = te_prefix.result + "Extent_t";
te_extent.active = "active";
te_extent.inactive = "inactive";
te_extent.initializer = "{0}";
te_extent.size_type = te_typemap.object_size_name;
te_extent.istate_type = te_typemap.state_number_name;
te_extent.istate_name = "initial_state";
te_extent.container_type = te_set.element_type + "*";
te_extent.container_name = "container";
te_extent.pool_type = te_instance.handle;
te_extent.pool_name = "pool";
te_extent.population_type = te_typemap.instance_index_name;
te_extent.population_name = "population";
te_extent.rstorsize_type = te_typemap.object_size_name;
te_extent.rstorsize_name = "size_no_rel";
te_extent.linkfunc_name = "link_function";
te_extent.size_name = "size";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("f282c918-e6f8-4f53-bc23-00d2b891abfa",
	"4e55db3e-d011-411b-b738-ecedf8989b7a",
	'te_extent',
	"1f3bdad1-ec0f-48e9-8084-9a44d3c52a99",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("1f3bdad1-ec0f-48e9-8084-9a44d3c52a99",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<extent>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("4e55db3e-d011-411b-b738-ecedf8989b7a",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("18947502-e8bc-4d4a-ad11-4bc464be768f",
	"00000000-0000-0000-0000-000000000000",
	'file_factory',
	'',
	'//
//
te_file = param.te_file;
select any te_prefix from instances of TE_PREFIX;
te_file.hdr_file_ext = "h";
te_file.src_file_ext = "c";
te_file.sys_main = te_prefix.file + "sys_main";
te_file.factory = te_prefix.file + "sys_xtuml";
te_file.events = te_prefix.file + "sys_events";
te_file.asm_file_ext = "s";
te_file.obj_file_ext = "o";
te_file.rpt_file_ext = "rpt";
te_file.nvs = te_prefix.file + "sys_nvs";
te_file.sets = te_prefix.file + "sys_sets";
te_file.types = te_prefix.file + "sys_types";
te_file.thread = te_prefix.file + "sys_thread";
te_file.trace = te_prefix.file + "sys_trace";
te_file.tim = te_prefix.file + "TIM_bridge";
te_file.callout = te_prefix.file + "sys_user_co";
te_file.ilb = te_prefix.file + "sys_ilb";
te_file.persist = te_prefix.file + "sys_persist";
te_file.xtumlload = te_prefix.file + "sys_xtumlload";
te_file.interfaces = te_prefix.file + "sysc_interfaces";
te_file.registers = te_prefix.file + "RegDefs";
te_file.domain_color_path = ".";
te_file.domain_source_path = "_ch";
te_file.domain_include_path = "_ch";
te_file.domain_sql_path = "schema/sql";
te_file.system_source_path = "_ch";
te_file.system_include_path = "_ch";
te_file.system_color_path = ".";
te_file.registry_mark = "registry.mark";
te_file.system_mark = "system.mark";
te_file.datatype_mark = "datatype.mark";
te_file.event_mark = "event.mark";
te_file.class_mark = "class.mark";
te_file.domain_mark = "domain.mark";
te_file.domain_functions_mark = "dom_functions.arc";
te_file.system_functions_mark = "sys_functions.arc";
te_file.bridge_mark = "bridge.mark";
te_file.nvs_bridge = te_prefix.file + "NVS_bridge";
te_file.arc_path = "mc3020/arc";
te_file.root_path = ".";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("f1787536-d2c5-483c-8662-ea1a95caad12",
	"18947502-e8bc-4d4a-ad11-4bc464be768f",
	'te_file',
	"0036820d-a4f4-4951-aaba-f90c9abe57f1",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("0036820d-a4f4-4951-aaba-f90c9abe57f1",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<file>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("18947502-e8bc-4d4a-ad11-4bc464be768f",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("92f4ece3-a751-40e0-82a1-c54a5d2d5a21",
	"00000000-0000-0000-0000-000000000000",
	'instance_factory',
	'',
	'//
//
te_instance = param.te_instance;
select any te_prefix from instances of TE_PREFIX;
te_instance.scope = "";
te_instance.create = te_prefix.result + "CreateInstance";
te_instance.create_persistent = te_prefix.result + "CreatePersistent";
te_instance.delete = te_prefix.result + "DeleteInstance";
te_instance.delete_persistent = te_prefix.result + "DeletePersistent";
te_instance.self = "self";
te_instance.global_self = te_prefix.result + "GetSelf";
te_instance.base = te_prefix.result + "InstanceBase_t";
te_instance.handle = te_prefix.result + "iHandle_t";
te_instance.factory_init = te_prefix.result + "ClassFactoryInit";
te_instance.get_dci = te_prefix.result + "GetDCI";
te_instance.get_event_dispatcher = te_prefix.result + "GetEventDispatcher";
te_instance.get_thread_assignment = te_prefix.result + "GetThreadAssignment";
te_instance.base_class = te_prefix.result + "Object_s";
te_instance.max_extent = te_prefix.define_u + "SYS_MAX_OBJECT_EXTENT";
te_instance.max_association_extent = te_prefix.define_u + "SYS_MAX_ASSOCIATION_EXTENT";
te_instance.max_transient_extent = te_prefix.define_u + "SYS_MAX_TRANSIENT_EXTENT";
te_instance.current_state = "current_state";
te_instance.module = "";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("701778c8-3948-4403-b0b9-8878894b4f33",
	"92f4ece3-a751-40e0-82a1-c54a5d2d5a21",
	'te_instance',
	"f0202e24-f724-4165-9b1f-c61a34457bc8",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("f0202e24-f724-4165-9b1f-c61a34457bc8",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<instance>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("92f4ece3-a751-40e0-82a1-c54a5d2d5a21",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("3bbd2669-ab86-49ba-ae0a-444d26e29085",
	"00000000-0000-0000-0000-000000000000",
	'ilb_factory',
	'',
	'//
//
te_ilb = param.te_ilb;
select any te_prefix from instances of TE_PREFIX;
te_ilb.file = "sys_ilb";
te_ilb.interleave_bridge = "InterleaveBridge";
te_ilb.define_name = te_prefix.define_u + "SYS_MAX_INTERLEAVED_BRIDGES";
te_ilb.data_define_name = te_prefix.define_u + "SYS_MAX_INTERLEAVED_BRIDGE_DATA";
te_ilb.interleave_bridge_done = "InterleaveBridgeDone";
te_ilb.get_data = "GetILBData";
te_ilb.dispatch = "DispatchInterleaveBridge";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("8b138a95-b05c-465c-9f51-dba1779e5e02",
	"3bbd2669-ab86-49ba-ae0a-444d26e29085",
	'te_ilb',
	"9607434a-e180-4f6f-bfad-1014845a2102",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("9607434a-e180-4f6f-bfad-1014845a2102",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<interleaved bridge>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("3bbd2669-ab86-49ba-ae0a-444d26e29085",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a4863801-8bdd-4408-8b32-742dbef6e987",
	"00000000-0000-0000-0000-000000000000",
	'persist_factory',
	'',
	'//
//
te_persist = param.te_persist;
select any te_prefix from instances of TE_PREFIX;
select any te_typemap from instances of TE_TYPEMAP;
te_persist.class_union = "";
te_persist.instance_cache_depth = te_prefix.define_u + "PERSIST_INST_CACHE_DEPTH";
te_persist.check_mark = "check_mark_post";
te_persist.post_link = "";
te_persist.link_type_name = te_prefix.type + "link_t";
te_persist.persist_file = "sys_persist";
te_persist.factory_init = te_prefix.result + "PersistFactoryInit";
te_persist.commit = te_prefix.result + "PersistenceCommit";
te_persist.restore = te_prefix.result + "PersistenceRestore";
te_persist.remove = te_prefix.result + "PersistDelete";
te_persist.link_cache_depth = te_prefix.define_u + "PERSIST_LINK_CACHE_DEPTH";
// Return the name of the extended attribute variable for use by
// the persistent restore operation.  This attribute represents the
// instance index of the class extent at time of persistent stowage
// together with the class number (across domains) of the class.
// Also return the types for this attribute variable.
te_persist.domainnum_name = "domainnum";
te_persist.domainnum_type = te_typemap.domain_number_name;
te_persist.classnum_name = "classnum";
te_persist.classnum_type = te_typemap.object_number_name;
te_persist.index_name = "index";
te_persist.index_type = te_typemap.instance_index_name;
te_persist.instid_type = "InstanceIdentifier_t";
te_persist.instid_name = "instance_identifier";
te_persist.dirty_type = "s1_t";
te_persist.dirty_name = "persist_dirty";
te_persist.dirty_dirty = 1;
te_persist.dirty_clean = 0;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("e0e8ec46-92bb-4aae-b88a-af58ac3467f7",
	"a4863801-8bdd-4408-8b32-742dbef6e987",
	'te_persist',
	"64c42b53-ed69-45a1-b7de-39fa11bfa5de",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("64c42b53-ed69-45a1-b7de-39fa11bfa5de",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<persistence>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("a4863801-8bdd-4408-8b32-742dbef6e987",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("3a12ea89-c610-4a5d-a833-0f18cb9e63c1",
	"00000000-0000-0000-0000-000000000000",
	'prefix_factory',
	'',
	'//
//
te_prefix = param.te_prefix;
te_prefix.symbol = "Escher_";
te_prefix.type = "Escher_";
te_prefix.define_u = "ESCHER_";
te_prefix.define_c = "Escher_";
te_prefix.symbolsw = "";
te_prefix.typesw = "";
te_prefix.result = "Escher_";
te_prefix.define_csw = "";
te_prefix.define_usw = "";
te_prefix.file = "";
te_prefix.provided_port = "pport_";
te_prefix.required_port = "rport_";
te_prefix.channel = "channel_";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("0c1a7813-18fb-4199-99e6-5259aea9131f",
	"3a12ea89-c610-4a5d-a833-0f18cb9e63c1",
	'te_prefix',
	"3afdbefc-08c0-46d7-8e35-39767bc796a8",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("3afdbefc-08c0-46d7-8e35-39767bc796a8",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<prefix>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("3a12ea89-c610-4a5d-a833-0f18cb9e63c1",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("971852a3-1237-47a8-816d-186d37051aa9",
	"00000000-0000-0000-0000-000000000000",
	'relinfo_factory',
	'',
	'//
//
te_relinfo = param.te_relinfo;
te_relinfo.multiplicity = 0;
te_relinfo.rel_phrase = "";
te_relinfo.is_formalizer = false;
te_relinfo.is_supertype = false;
te_relinfo.generate_subtype = false;
te_relinfo.gen_declaration = false;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("48cbe107-904d-415e-b651-4fe84907c974",
	"971852a3-1237-47a8-816d-186d37051aa9",
	'te_relinfo',
	"4ac9e914-7a2d-42a4-afbb-979afa290813",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("4ac9e914-7a2d-42a4-afbb-979afa290813",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<relationship information>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("971852a3-1237-47a8-816d-186d37051aa9",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("d5240fd9-ac88-45c5-8006-c55b7f47b8eb",
	"00000000-0000-0000-0000-000000000000",
	'relstore_factory',
	'',
	'//
//
te_relstore = param.te_relstore;
te_relstore.data_init = "";
te_relstore.link_calls = "";
te_relstore.link_index = 0;
te_relstore.data_fini = "";
te_relstore.self_name = "self";
te_relstore.data_declare = "";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("fdb7ead9-3663-4b79-ad7f-9dc7cf4b852e",
	"d5240fd9-ac88-45c5-8006-c55b7f47b8eb",
	'te_relstore',
	"e0eff310-4301-4d0e-892a-5e44db181c35",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("e0eff310-4301-4d0e-892a-5e44db181c35",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<relationship storage>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("d5240fd9-ac88-45c5-8006-c55b7f47b8eb",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("1994ae9b-ccb4-41e5-8ffe-b6fb73c57ac2",
	"00000000-0000-0000-0000-000000000000",
	'set_factory',
	'',
	'//
//
te_set = param.te_set;
select any te_prefix from instances of TE_PREFIX;
te_set.module = "";
te_set.copy = te_prefix.result + "CopySet";
te_set.clear = te_prefix.result + "ClearSet";
te_set.insert_element = te_prefix.result + "SetInsertElement";
te_set.element_count = te_prefix.result + "SetCardinality";
te_set.iterator_class_name = te_prefix.result + "Iterator_s";
te_set.number_of_containoids = te_prefix.define_usw + "SYS_MAX_CONTAINERS";
te_set.factory = te_prefix.result + "SetFactoryInit";
te_set.insert_block = te_prefix.result + "SetInsertBlock";
te_set.remove_instance = te_prefix.result + "SetRemoveInstance";
te_set.contains = te_prefix.result + "SetContains";
te_set.equality = te_prefix.result + "SetEquality";
te_set.init = te_prefix.result + "InitSet";
te_set.insert_instance = te_prefix.result + "SetInsertInstance";
te_set.emptiness = te_prefix.result + "SetIsEmpty";
te_set.get_any = te_prefix.result + "SetGetAny";
te_set.remove_element = te_prefix.result + "SetRemoveElement";
te_set.iterator_reset = te_prefix.result + "IteratorReset";
te_set.iterator_next = te_prefix.result + "IteratorNext";
te_set.base_class = te_prefix.result + "ObjectSet_s";
te_set.element_type = te_prefix.result + "SetElement_s";
te_set.scope = "";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("c0edf5fa-108c-4a73-b221-6b16e4e4ddf8",
	"1994ae9b-ccb4-41e5-8ffe-b6fb73c57ac2",
	'te_set',
	"acfc1b52-78f3-4f68-9025-f05d65609d43",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("acfc1b52-78f3-4f68-9025-f05d65609d43",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<set>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("1994ae9b-ccb4-41e5-8ffe-b6fb73c57ac2",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("273c8f41-60cc-42a0-b2f2-ccaff4864e04",
	"00000000-0000-0000-0000-000000000000",
	'slist_factory',
	'',
	'//
//
te_slist = param.te_slist;
select any te_prefix from instances of TE_PREFIX;
te_slist.remove_node = te_prefix.result + "SetRemoveNode";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("31bb831c-594f-4d9b-8dfa-9daa745adc1d",
	"273c8f41-60cc-42a0-b2f2-ccaff4864e04",
	'te_slist',
	"976fc510-71b7-4ace-b099-c840dff5f3de",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("976fc510-71b7-4ace-b099-c840dff5f3de",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<slist>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("273c8f41-60cc-42a0-b2f2-ccaff4864e04",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("ae1e7947-4023-4879-ac87-fcf889be9a83",
	"00000000-0000-0000-0000-000000000000",
	'string_factory',
	'',
	'//
//
te_string = param.te_string;
select any te_prefix from instances of TE_PREFIX;
te_string.memset = te_prefix.result + "memset";
te_string.memmove = te_prefix.result + "memmove";
te_string.strcpy = te_prefix.result + "strcpy";
te_string.stradd = te_prefix.result + "stradd";
te_string.strlen = te_prefix.result + "strlen";
te_string.itoa = te_prefix.result + "itoa";
te_string.atoi = te_prefix.result + "atoi";
te_string.strcmp = te_prefix.result + "strcmp";
te_string.strget = te_prefix.result + "strget";
te_string.max_string_length = te_prefix.define_u + "SYS_MAX_STRING_LEN";
te_string.debug_buffer_depth = te_prefix.define_u + "DEBUG_BUFFER_DEPTH";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("5ec3e361-ebea-451a-98d5-238a2b7313d1",
	"ae1e7947-4023-4879-ac87-fcf889be9a83",
	'te_string',
	"950366c4-a10b-4518-8cdb-3dc0f89902cc",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("950366c4-a10b-4518-8cdb-3dc0f89902cc",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<string>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("ae1e7947-4023-4879-ac87-fcf889be9a83",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("3f165de7-08fd-4532-8e10-6c127abd8917",
	"00000000-0000-0000-0000-000000000000",
	'thread_factory',
	'',
	'//
//
te_thread = param.te_thread;
select any te_prefix from instances of TE_PREFIX;
te_thread.file = "sys_thread";
te_thread.mutex_lock = te_prefix.result + "mutex_lock";
te_thread.mutex_unlock = te_prefix.result + "mutex_unlock";
te_thread.nonbusy_wait = te_prefix.result + "nonbusy_wait";
te_thread.nonbusy_wake = te_prefix.result + "nonbusy_wake";
te_thread.shutdown = te_prefix.result + "thread_shutdown";
te_thread.create = te_prefix.result + "thread_create";
te_thread.enabled = false;
te_thread.flavor = "POSIX";
te_thread.serialize = false;
te_thread.number_of_threads = 1;
te_thread.extra_initialization = "";
te_thread.AUTOSAR_enabled = te_prefix.define_usw + "AUTOSAR_ENABLED";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("aaea231e-478e-4ce5-b237-624f414240ba",
	"3f165de7-08fd-4532-8e10-6c127abd8917",
	'te_thread',
	"11e51b45-1939-4fba-8271-981f25fb85e0",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("11e51b45-1939-4fba-8271-981f25fb85e0",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<thread>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("3f165de7-08fd-4532-8e10-6c127abd8917",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("8e1301d4-3d14-4c04-ae57-91896dc0e45e",
	"00000000-0000-0000-0000-000000000000",
	'tim_factory',
	'',
	'//
//
te_tim = param.te_tim;
select any te_prefix from instances of TE_PREFIX;
te_tim.max_timers = te_prefix.define_u + "SYS_MAX_XTUML_TIMERS";
te_tim.keyed_timer_support = false;
te_tim.recurring_timer_support = true;
te_tim.internal_type = "ETimer_t";
te_tim.timer_event_search_and_destroy = false;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("07cf727a-8fb2-46d4-9fc2-9074c0549427",
	"8e1301d4-3d14-4c04-ae57-91896dc0e45e",
	'te_tim',
	"64135dee-0504-4c8d-b94c-4103b7459fc0",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("64135dee-0504-4c8d-b94c-4103b7459fc0",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<timer>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("8e1301d4-3d14-4c04-ae57-91896dc0e45e",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("beae8ec3-9c45-4b5e-9e6f-31734eda97b4",
	"00000000-0000-0000-0000-000000000000",
	'typemap_factory',
	'',
	'//
//
te_typemap = param.te_typemap;
select any te_prefix from instances of TE_PREFIX;
te_typemap.instance_index_name = te_prefix.result + "InstanceIndex_t";
te_typemap.instance_index_type = "u2_t";
te_typemap.object_size_name = te_prefix.type + "ClassSize_t";
te_typemap.object_size_type = "u2_t";
te_typemap.object_number_name = te_prefix.type + "ClassNumber_t";
te_typemap.object_number_type = "u2_t";
te_typemap.state_number_name = te_prefix.type + "StateNumber_t";
te_typemap.state_number_type = "u1_t";
te_typemap.domain_number_name = te_prefix.type + "DomainNumber_t";
te_typemap.domain_number_type = "u1_t";
te_typemap.event_number_name = te_prefix.type + "EventNumber_t";
te_typemap.event_number_type = "u1_t";
te_typemap.event_priority_name = te_prefix.type + "EventPriority_t";
te_typemap.event_priority_type = "u1_t";
te_typemap.event_flags_name = te_prefix.type + "EventFlags_t";
te_typemap.event_flags_type = "u1_t";
te_typemap.poly_return_name = te_prefix.type + "PolyEventRC_t";
te_typemap.poly_return_type = "u1_t";
te_typemap.SEM_cell_type = "u1_t";
te_typemap.SEM_cell_name = te_prefix.type + "SEMcell_t";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("65d277f7-18fc-4dc0-8f73-8b911e4750d6",
	"beae8ec3-9c45-4b5e-9e6f-31734eda97b4",
	'te_typemap',
	"d98a6bae-7ee6-42d2-a8a1-2f809cba7b82",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("d98a6bae-7ee6-42d2-a8a1-2f809cba7b82",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<type map>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("beae8ec3-9c45-4b5e-9e6f-31734eda97b4",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("092fa45b-5e69-43b4-beac-c03f08eadd7c",
	"00000000-0000-0000-0000-000000000000",
	'callout_factory',
	'',
	'//
//
te_callout = param.te_callout;
select any te_prefix from instances of TE_PREFIX;
te_callout.initialization = te_prefix.symbolsw + "UserInitializationCallout";
te_callout.pre_xtUML_initialization = te_prefix.symbolsw + "UserPreOoaInitializationCallout";
te_callout.post_xtUML_initialization = te_prefix.symbolsw + "UserPostOoaInitializationCallout";
te_callout.background_processing = te_prefix.symbolsw + "UserBackgroundProcessingCallout";
te_callout.pre_shutdown = te_prefix.symbolsw + "UserPreShutdownCallout";
te_callout.event_no_instance = te_prefix.symbolsw + "UserEventNoInstanceCallout";
te_callout.event_free_list_empty = te_prefix.symbolsw + "UserEventFreeListEmptyCallout";
te_callout.object_pool_empty = te_prefix.symbolsw + "UserObjectPoolEmptyCallout";
te_callout.node_list_empty = te_prefix.symbolsw + "UserNodeListEmptyCallout";
te_callout.interleaved_bridge_overflow = te_prefix.symbolsw + "UserInterleavedBridgeOverflowCallout";
te_callout.self_event_queue_empty = te_prefix.symbolsw + "UserSelfEventQueueEmptyCallout";
te_callout.non_self_event_queue_empty = te_prefix.symbolsw + "UserNonSelfEventQueueEmptyCallout";
te_callout.persistence_error = te_prefix.symbolsw + "UserPersistenceErrorCallout";
te_callout.file = "sys_user_co";
te_callout.post_shutdown = te_prefix.symbolsw + "UserPostShutdownCallout";
te_callout.event_cant_happen = te_prefix.symbolsw + "UserEventCantHappenCallout";
te_callout.empty_handle_detected = te_prefix.symbolsw + "UserEmptyHandleDetectedCallout";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("5d46ca3a-dabe-4393-ab6e-ca35e00b9de4",
	"092fa45b-5e69-43b4-beac-c03f08eadd7c",
	'te_callout',
	"93f43d4c-fd60-4b31-97f4-e74103f19dc9",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("93f43d4c-fd60-4b31-97f4-e74103f19dc9",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<user callout>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("092fa45b-5e69-43b4-beac-c03f08eadd7c",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("51b6d1e5-8eb7-4c2f-9a2f-008de1326a49",
	"00000000-0000-0000-0000-000000000000",
	'trace_factory',
	'',
	'//
//
te_trace = param.te_trace;
select any te_prefix from instances of TE_PREFIX;
te_trace.component_msg_start = te_prefix.define_usw + "COMP_MSG_START_TRACE";
te_trace.component_msg_end = te_prefix.define_usw + "COMP_MSG_END_TRACE";
te_trace.state_txn_start = te_prefix.define_usw + "STATE_TXN_START_TRACE";
te_trace.oal_trace = te_prefix.define_usw + "OAL_ACTION_TRACE";
te_trace.state_txn_end = te_prefix.define_usw + "STATE_TXN_END_TRACE";
te_trace.state_txn_event_ignored = te_prefix.define_usw + "STATE_TXN_IG_TRACE";
te_trace.state_txn_cant_happen = te_prefix.define_usw + "STATE_TXN_CH_TRACE";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("ddd78773-5ab3-4299-a8df-308935245a71",
	"51b6d1e5-8eb7-4c2f-9a2f-008de1326a49",
	'te_trace',
	"1aa80d4d-ce32-4473-9aa3-f54ad1ca398e",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("1aa80d4d-ce32-4473-9aa3-f54ad1ca398e",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<trace>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("51b6d1e5-8eb7-4c2f-9a2f-008de1326a49",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("034a1cf9-b552-4e24-843f-14cb1a0fc484",
	"00000000-0000-0000-0000-000000000000",
	'target_factory',
	'',
	'//
te_target = param.te_target;
te_target.language = "C";
te_target.c2cplusplus_linkage_begin = "#ifdef\t__cplusplus\nextern\tC\t{\n#endif";
te_target.c2cplusplus_linkage_end = "#ifdef\t__cplusplus\n}\n#endif";
te_target.main = "main";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("c4b33d30-c052-4763-85ba-ff851aff1a92",
	"034a1cf9-b552-4e24-843f-14cb1a0fc484",
	'te_target',
	"87352925-0272-4445-84b6-d8c3f983377f",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("87352925-0272-4445-84b6-d8c3f983377f",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<target>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("034a1cf9-b552-4e24-843f-14cb1a0fc484",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("1c1d2a3c-aed8-4e1f-a949-18552fb2c657",
	"00000000-0000-0000-0000-000000000000",
	'sys_singletons',
	'',
	'//
create object instance te_prefix of TE_PREFIX;
::prefix_factory( te_prefix:te_prefix );
create object instance te_typemap of TE_TYPEMAP;
::typemap_factory( te_typemap:te_typemap );
create object instance te_container of TE_CONTAINER;
::container_factory( te_container:te_container );
create object instance te_copyright of TE_COPYRIGHT;
::copyright_factory( te_copyright:te_copyright );
create object instance te_dlist of TE_DLIST;
::dlist_factory( te_dlist:te_dlist );
create object instance te_dma of TE_DMA;
::dma_factory( te_dma:te_dma );
create object instance te_eq of TE_EQ;
::eq_factory( te_eq:te_eq );
create object instance te_file of TE_FILE;
::file_factory( te_file:te_file );
create object instance te_instance of TE_INSTANCE;
::instance_factory( te_instance:te_instance );
create object instance te_ilb of TE_ILB;
::ilb_factory( te_ilb:te_ilb );
create object instance te_persist of TE_PERSIST;
::persist_factory( te_persist:te_persist );
create object instance te_relinfo of TE_RELINFO;
::relinfo_factory( te_relinfo:te_relinfo );
create object instance te_relstore of TE_RELSTORE;
::relstore_factory( te_relstore:te_relstore );
create object instance te_set of TE_SET;
::set_factory( te_set:te_set );
create object instance te_slist of TE_SLIST;
::slist_factory( te_slist:te_slist );
create object instance te_string of TE_STRING;
::string_factory( te_string:te_string );
create object instance te_thread of TE_THREAD;
::thread_factory( te_thread:te_thread );
create object instance te_tim of TE_TIM;
::tim_factory( te_tim:te_tim );
create object instance te_callout of TE_CALLOUT;
::callout_factory( te_callout:te_callout );
create object instance te_trace of TE_TRACE;
::trace_factory( te_trace:te_trace );
create object instance te_extent of TE_EXTENT;
::extent_factory( te_extent:te_extent );
create object instance te_target of TE_TARGET;
::target_factory( te_target:te_target );
//
create object instance te_assign of TE_ASSIGN;
create object instance te_create_instance of TE_CREATE_INSTANCE;
create object instance te_for of TE_FOR;
create object instance te_if of TE_IF;
create object instance te_while of TE_WHILE;
create object instance te_elif of TE_ELIF;
create object instance te_delete_instance of TE_DELETE_INSTANCE;
create object instance te_create_event of TE_CREATE_EVENT;
create object instance te_relate of TE_RELATE;
create object instance te_relate_using of TE_RELATE_USING;
create object instance te_unrelate of TE_UNRELATE;
create object instance te_unrelate_using of TE_UNRELATE_USING;
create object instance te_select of TE_SELECT;
create object instance te_select_where of TE_SELECT_WHERE;
create object instance te_generate_precreated_event of TE_GENERATE_PRECREATED_EVENT;
create object instance te_event_parameters of TE_EVENT_PARAMETERS;
create object instance te_generate of TE_GENERATE;
create object instance te_generate_creator_event of TE_GENERATE_CREATOR_EVENT;
create object instance te_generate_to_class of TE_GENERATE_TO_CLASS;
create object instance te_sgn of TE_SGN;
create object instance te_iop of TE_IOP;
create object instance te_operation of TE_OPERATION;
create object instance te_bridge of TE_BRIDGE;
create object instance te_function of TE_FUNCTION;
create object instance te_return of TE_RETURN;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("1c1d2a3c-aed8-4e1f-a949-18552fb2c657",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("cd2f41bf-ac04-4c98-b518-2e249fa6bbfb",
	"00000000-0000-0000-0000-000000000000",
	'GetBaseTypeForUDT',
	'',
	'//============================================================================
// $RCSfile: q.datatype.arc,v $
//
// Notice:
// (C) Copyright 1998-2013 Mentor Graphics Corporation
//     All rights reserved.
//
// This document contains confidential and proprietary information and
// property of Mentor Graphics Corp.  No part of this document may be
// reproduced without the express written permission of Mentor Graphics Corp.
//============================================================================
//
//
//============================================================================
// Recursively locate the datatype at the base of the UDT type definition 
// chain. Traverses up through UDTs based on UDTs until we find the underlying
// S_DT instance (which may actually be EDT, SDT, IRDT or CDT).
//============================================================================
s_udt = param.s_udt;
select one s_dt related by s_udt->S_DT[R18];
select one s_udt related by s_dt->S_UDT[R17];
if ( not_empty s_udt )
  r = ::GetBaseTypeForUDT( s_udt:s_udt );
  s_dt = r;
end if;
return s_dt;
',
	"3f421b34-9cdd-4a99-947a-7224e3b97776",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("943575b9-f0ed-411b-aa33-397a538860b5",
	"cd2f41bf-ac04-4c98-b518-2e249fa6bbfb",
	's_udt',
	"fbb3cc5a-c0d2-405d-a9fd-46fcd925a160",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("fbb3cc5a-c0d2-405d-a9fd-46fcd925a160",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<User Data Type>',
	'',
	'',
	'../Domain/Domain.xtuml');
INSERT INTO PE_PE
	VALUES ("cd2f41bf-ac04-4c98-b518-2e249fa6bbfb",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_DT_PROXY
	VALUES ("3f421b34-9cdd-4a99-947a-7224e3b97776",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Data Type>',
	'',
	'',
	'../Instance Reference Data Types/Instance Reference Data Types.xtuml');
INSERT INTO S_SYNC
	VALUES ("ab253848-cf0e-436a-b10a-fa55aa022ed8",
	"00000000-0000-0000-0000-000000000000",
	'GetAttributeCodeGenType',
	'',
	'//
//============================================================================
//   Get the S_DT and S_CDT object references for a given attribute
//   (O_ATTR) instance.
//============================================================================
o_attr = param.o_attr;
//
select one s_dt related by o_attr->S_DT[R114];
select one s_udt related by s_dt->S_UDT[R17];
if ( not_empty s_udt )
  r = ::GetBaseTypeForUDT( s_udt:s_udt );
  s_dt = r;
end if;
select one te_dt related by s_dt->TE_DT[R2021];
select one s_cdt related by s_dt->S_CDT[R17];
//
if ( empty s_cdt )
  select one s_edt related by s_dt->S_EDT[R17];
  if ( empty s_edt )
    select one s_sdt related by s_dt->S_SDT[R17];
    if ( empty s_sdt )
      select one s_irdt related by s_dt->S_IRDT[R17];
      if ( empty s_irdt )
        T::print(s:"Error in attribute T::s(i:o_attr.Name)");
        T::print(s:"with data type T::s(i:s_dt.Name)");
        T::exit(i:100);
      end if;
    end if;
  else
    // Enum, use integer type.
    // CDS Some day we should pass along the enumeration type.
    select any s_cdt from instances of S_CDT where ( selected.Core_Typ == 2 );
  end if;
end if;
//
if ( not_empty s_cdt )
  if ( 7 == s_cdt.Core_Typ )
    // s_cdt.Core_Typ is "same_as<Base_Attribute>"
    select one base_o_attr related by o_attr->O_RATTR[R106]->O_BATTR[R113]->O_ATTR[R106];
    if ( empty base_o_attr )
      select one o_obj related by o_attr->O_OBJ[R102];
      T::print(s:"\nCould not find O_BATTR for object T::s(i:o_obj.Name) (T::s(i:o_obj.Key_Lett)) attribute T::s(i:o_attr.Name) !");
      T::print(s:"\nDid you combine a referential and then rename the combined attribute?");
      T::exit(i:101);
    end if;
    // Note: the following is a recursive call to this function
    r = ::GetAttributeCodeGenType( o_attr:base_o_attr );
    te_dt = r;
  end if;
end if;
return te_dt;
',
	"5b20f7fb-179b-4254-a8de-922a50a1225d",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("7eaff938-c8b9-4365-8087-2c9367825ff9",
	"ab253848-cf0e-436a-b10a-fa55aa022ed8",
	'o_attr',
	"f597d699-ee8c-4635-9196-5082b710160d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("f597d699-ee8c-4635-9196-5082b710160d",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Attribute>',
	'',
	'',
	'../Instance Reference Data Types/Instance Reference Data Types.xtuml');
INSERT INTO PE_PE
	VALUES ("ab253848-cf0e-436a-b10a-fa55aa022ed8",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_DT_PROXY
	VALUES ("5b20f7fb-179b-4254-a8de-922a50a1225d",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Data Type>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO S_SYNC
	VALUES ("f9b303bd-8c22-4f19-8808-1b0fdd26d1ed",
	"00000000-0000-0000-0000-000000000000",
	'MapUserSpecifiedDataTypePrecision',
	'',
	'//
//============================================================================
// Map a user defined data types precision into its corresponding instance
// of Data Type (S_DT).
// Note:  Might prefer POSIX type support here, but doubt we can count
// on most embedded targets thinking this way.  Thus brute force the types.
//============================================================================
te_dt = param.te_dt;
mapping = param.mapping;
error = false;
type = mapping;
if ( ( type == "uchar_t" ) or ( ( type == "u_char" ) or ( type == "unsignedchar" ) ) )
  te_dt.ExtName = "unsigned char";
elif ( ( type == "char_t" ) or ( type == "char" ) )
  te_dt.ExtName = "char";
elif ( type == "signedchar" )
  te_dt.ExtName = "signed char";
elif ( ( type == "ushort_t" ) or ( ( type == "u_short" ) or ( type == "unsignedshort" ) ) )
  te_dt.ExtName = "unsigned short";
elif ( ( type == "short_t" ) or ( type == "short" ) )
  te_dt.ExtName = "short";
elif ( type == "signedshort" )
  te_dt.ExtName = "signed short";
elif ( ( type == "uint_t" ) or ( ( type == "u_int" ) or ( type == "unsignedint" ) ) )
  te_dt.ExtName = "unsigned int";
elif ( type == "s1_t" )
  te_dt.ExtName = "s1_t";
elif ( type == "u1_t" )
  te_dt.ExtName = "u1_t";
elif ( type == "s2_t" )
  te_dt.ExtName = "s2_t";
elif ( type == "u2_t" )
  te_dt.ExtName = "u2_t";
elif ( type == "s4_t" )
  te_dt.ExtName = "s4_t";
elif ( type == "u4_t" )
  te_dt.ExtName = "u4_t";
elif ( type == "i_t" )
  te_dt.ExtName = "i_t";
elif ( ( type == "int_t" ) or ( type == "int" ) )
  te_dt.ExtName = "int";
elif ( type == "signedint" )
  te_dt.ExtName = "signed int";
elif ( ( type == "ulong_t" ) or ( ( type == "u_long" ) or ( type == "unsignedlong" ) ) )
  te_dt.ExtName = "unsigned long";
elif ( ( type == "long_t" ) or ( type == "long" ) )
  te_dt.ExtName = "long";
elif ( type == "signedlong" )
  te_dt.ExtName = "signed long";
elif ( ( type == "u_longlong_t" ) or ( ( type == "u_longlong_t" ) or ( type == "unsignedlonglong" ) ) )
  te_dt.ExtName = "unsigned long long";
elif ( ( type == "longlong_t" ) or ( ( type == "longlong" ) or ( type == "signedlonglong" ) ) )
  te_dt.ExtName = "long long";
  //
elif ( type == "float" )
  te_dt.ExtName = "float";
elif ( type == "r4_t" )
  te_dt.ExtName = "r4_t";
elif ( type == "double" )
  te_dt.ExtName = "double";
elif ( type == "r8_t" )
  te_dt.ExtName = "r8_t";
  //
elif ( type == "size_t" )
  te_dt.ExtName = "size_t";
elif ( type == "ssize_t" )
  te_dt.ExtName = "ssize_t";
elif ( type == "time_t" )
  te_dt.ExtName = "time_t";
elif ( type == "clock_t" )
  te_dt.ExtName = "clock_t";
elif ( type == "volatile_clock_t" )
  te_dt.ExtName = "volatile unsigned long";
  //
else
  error = true;
end if;
return error;
',
	"ba5eda7a-def5-0000-0000-000000000001",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("c606003d-40cd-494f-a865-a85e4138c853",
	"f9b303bd-8c22-4f19-8808-1b0fdd26d1ed",
	'te_dt',
	"5b20f7fb-179b-4254-a8de-922a50a1225d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("e7560f0a-db7b-4ddf-8824-66f5eeef8dd7",
	"f9b303bd-8c22-4f19-8808-1b0fdd26d1ed",
	'mapping',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"c606003d-40cd-494f-a865-a85e4138c853",
	'');
INSERT INTO PE_PE
	VALUES ("f9b303bd-8c22-4f19-8808-1b0fdd26d1ed",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a5f293e8-6202-48bb-a411-325db42e0dc3",
	"00000000-0000-0000-0000-000000000000",
	'UserSuppliedDataTypeIncludes',
	'',
	'//
// Return the structure type for persistent links.
select any te_file from instances of TE_FILE;
sys_types_file_name = ( te_file.types + "." ) + te_file.hdr_file_ext;
select many special_te_dts from instances of TE_DT where ( ( selected.Include_File != "" ) and ( selected.Include_File != sys_types_file_name ) );
s = "";
for each special_te_dt in special_te_dts
  s = ( s + "#include " ) + ( special_te_dt.Include_File + "\n" );
end for;
return s;
',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("a5f293e8-6202-48bb-a411-325db42e0dc3",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("1c3ed675-cfa5-40f7-91c6-a9ef59e19610",
	"00000000-0000-0000-0000-000000000000",
	'te_parm_RenderParameters',
	'',
	'//============================================================================
// $RCSfile: q.parameters.arc,v $
//
// Description:
// Here we deal with parameters.  The declaration, definition and invocation
// renderings are built.
//
// Notice:
// (C) Copyright 1998-2013 Mentor Graphics Corporation
//     All rights reserved.
//
// This document contains confidential and proprietary information and
// property of Mentor Graphics Corp.  No part of this document may be
// reproduced without the express written permission of Mentor Graphics Corp.
//============================================================================
//
//
te_parms = param.te_parms;
te_aba = param.te_aba;
// Consider that we may have additional parameters (like for passing "self").
defn = "";
decl = "";
if ( empty te_parms )
  decl = " void";
end if;
invo = "";
stru = "";
parameter_trace = "";
string_format = "";
assn = "";
assnbase = "";
param_delimiter = " ";
format_delimiter = "";
Order = 0;
// Be sure we have the first parameter.
for each te_parm in te_parms
  break;
end for;
while ( not_empty te_parm )
  select one prev_te_parm related by te_parm->TE_PARM[R2041.''precedes''];
  if ( empty prev_te_parm )
    break;
  else
    te_parm = prev_te_parm;
  end if;
end while;
while ( not_empty te_parm )
  te_parm.Order = Order;
  Order = Order + 1;
  select one te_dt related by te_parm->TE_DT[R2049];
  te_dt.Included = true;
  defn = defn + param_delimiter;
  decl = decl + param_delimiter;
  param_qual = "";
  if ( 0 != te_parm.By_Ref )
    param_qual = param_qual + " *";
  else
    // CDS const correctness goes here
    // Arrays in C are always by ref, so add const to scalars only.
    if ( ( "" == te_parm.array_spec ) and ( ( 1 <= te_dt.Core_Typ ) and ( te_dt.Core_Typ <= 3 ) ) )
      defn = defn + "const ";
      decl = decl + "const ";
    end if;
  end if;
  defn = ( ( defn + te_dt.ExtName ) + ( param_qual + " " ) ) + ( te_parm.GeneratedName + te_parm.array_spec );
  decl = ( ( decl + te_dt.ExtName ) + ( param_qual + te_parm.array_spec ) );
  invo = ( invo + param_delimiter ) + te_parm.GeneratedName;
  stru = ( ( stru + te_dt.ExtName ) + ( param_qual + " " ) ) + ( ( te_parm.GeneratedName + te_parm.array_spec ) + ";\n" );
  if ( ( "" != te_dt.string_format ) and ( "" == te_parm.array_spec ) )
    // Do not trace structures or arrays.
    dereference = "";
    if ( 0 != te_parm.By_Ref )
      dereference = "*";
    end if;
    parameter_trace = ( parameter_trace + ", " ) + ( dereference + te_parm.GeneratedName );
    string_format = ( string_format + format_delimiter ) + te_dt.string_format;
  else
    string_format = ( string_format + format_delimiter ) + "[]";
  end if;
  r = ::t_oal_smt_event_parameters( evt_msg_var:"", parameter:te_parm.Name, value:te_parm.GeneratedName, value_type:te_dt.Core_Typ, ws:"" );
  assn = assn + r;
  if ( "A00portindex" != te_parm.Name )
    assnbase = assnbase + r;
  end if;
  param_delimiter = ", ";
  format_delimiter = ",";
  select one te_parm related by te_parm->TE_PARM[R2041.''succeeds''];
end while;
if ( "" != defn )
  defn = defn + " ";
end if;
te_aba.ParameterDefinition = defn;
te_aba.ParameterDeclaration = decl + " ";
te_aba.ParameterInvocation = invo;
te_aba.ParameterStructure = stru;
te_aba.ParameterTrace = parameter_trace;
te_aba.ParameterFormat = string_format;
te_aba.ParameterAssignment = assn;
te_aba.ParameterAssignmentBase = assnbase;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("879cb618-5a37-41fc-b5fb-b171c84e2fde",
	"1c3ed675-cfa5-40f7-91c6-a9ef59e19610",
	'te_parms',
	"954dc6bb-6e2a-47a5-aa3b-886723803133",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("954dc6bb-6e2a-47a5-aa3b-886723803133",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Extended Parameter>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO S_SPARM
	VALUES ("b5418221-23e7-4010-b071-a2b5ab3e92b9",
	"1c3ed675-cfa5-40f7-91c6-a9ef59e19610",
	'te_aba',
	"5fb4bb14-9533-4d0c-bec8-44e5e22fbbfd",
	0,
	'',
	"879cb618-5a37-41fc-b5fb-b171c84e2fde",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("5fb4bb14-9533-4d0c-bec8-44e5e22fbbfd",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Action Block Anchor>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("1c3ed675-cfa5-40f7-91c6-a9ef59e19610",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("073e63d8-578b-445c-ad2f-06ae0d3649d8",
	"00000000-0000-0000-0000-000000000000",
	'sys_populate',
	'',
	'//============================================================================
// $RCSfile: q.mc_metamodel.populate.arc,v $
//
// Description:
// This query/transformation archetype file queries the customer model
// and populates the model compiler extensions to the meta-model.
// Instances of the extended classes are created, related and initialized.
//
// Create architectural system-level artifacts first.
// Create leaf-node artifacts (like TE_DT, TE_VAL and TE_PAR) which may need
// to be updated as information is gathered.
// Create component-level artifacts.
// Briefly create and link components, data types.  Select them afterwards.
// Create and link middled-level classes.
// Drill down into component and create object, attributes and the rest.
//
// Notice:
// (C) Copyright 1998-2013 Mentor Graphics Corporation
//     All rights reserved.
//
// This document contains confidential and proprietary information and
// property of Mentor Graphics Corp.  No part of this document may be
// reproduced without the express written permission of Mentor Graphics Corp.
//============================================================================
//
//
// Create the system interfaces (sys, dom, ee).
//
// Select singletons into scope.
select any te_file from instances of TE_FILE;
select any te_eq from instances of TE_EQ;
select any te_extent from instances of TE_EXTENT;
select any te_instance from instances of TE_INSTANCE;
select any te_prefix from instances of TE_PREFIX;
select any te_set from instances of TE_SET;
select any te_string from instances of TE_STRING;
select any te_target from instances of TE_TARGET;
select any te_tim from instances of TE_TIM;
select any te_typemap from instances of TE_TYPEMAP;
select any empty_cp_cp from instances of CP_CP where ( false );
select many empty_ep_pkgs from instances of EP_PKG where ( false );
select any empty_te_c from instances of TE_C where ( false );
select any empty_te_dim from instances of TE_DIM where ( false );
select any empty_o_obj from instances of O_OBJ where ( false );
select any empty_te_attr from instances of TE_ATTR where ( false );
select any empty_te_mact from instances of TE_MACT where ( false );
select many empty_te_dts from instances of TE_DT where ( false );
select many empty_te_parms from instances of TE_PARM where ( false );
// CDS - Note that in a multiple-system build, we will get lucky, and the
// s_sys from the local project will be selected first.
select any s_sys from instances of S_SYS;
if ( empty s_sys )
  create object instance s_sys of S_SYS;
  s_sys.Name = "sys";
end if;
// Create the system translation extension and relate it.
select any te_sys from instances of TE_SYS;
if ( empty te_sys )
  create object instance te_sys of TE_SYS;
  te_sys.SystemID = 1;
end if;
relate s_sys to te_sys across R2018;
te_sys.Name = T::r(s:s_sys.Name);
if ( "" == te_sys.Name )
  te_sys.Name = "sys";
end if;
te_sys.MaxStringLen = 32;
te_sys.PersistInstanceCacheDepth = 128;
te_sys.PersistLinkCacheDepth = 128;
te_sys.AUTOSAR = false;
te_sys.AllPortsPoly = false;
//
//Updating te_sys with system marks
select any tm_systag from instances of TM_SYSTAG;
if ( not_empty tm_systag )
  te_sys.MaxStringLen = tm_systag.MaxStringLen;
  te_sys.MaxRelExtent = tm_systag.MaxRelExtent;
  te_sys.MaxSelectExtent = tm_systag.MaxSelectExtent;
  te_sys.MaxSelfEvents = tm_systag.MaxSelfEvents;
  te_sys.MaxNonSelfEvents = tm_systag.MaxNonSelfEvents;
  te_sys.MaxTimers = tm_systag.MaxTimers;
  te_sys.MaxInterleavedBridges = tm_systag.MaxInterleavedBridges;
  te_sys.MaxInterleavedBridgeDataSize = tm_systag.MaxInterleavedBridgeDataSize;
  te_sys.CollectionsFlavor = tm_systag.CollectionsFlavor;
  te_sys.PersistInstanceCacheDepth = tm_systag.PersistInstanceCacheDepth;
  te_sys.PersistLinkCacheDepth = tm_systag.PersistLinkCacheDepth;
  te_sys.UnitsToDynamicallyAllocate = tm_systag.UnitsToDynamicallyAllocate;
  te_sys.VFB = tm_systag.VFB;
  te_sys.InstanceLoading = tm_systag.InstanceLoading;
  te_sys.SystemCPortsType = tm_systag.SystemCPortsType;
  te_sys.AllPortsPoly = tm_systag.AllPortsPoly;
else
  te_sys.SystemCPortsType = "sc_interface";
end if;
//
//Update the tasking threads based on marking.
select any tm_thread from instances of TM_THREAD;
if ( not_empty tm_thread )
  select any te_thread from instances of TE_THREAD;
  te_thread.extra_initialization = tm_thread.extra_initialization;
  te_thread.number_of_threads = tm_thread.number_of_threads;
  te_thread.enabled = tm_thread.enabled;
  te_thread.serialize = tm_thread.serialize;
  te_thread.flavor = tm_thread.flavor;
  if ( "AUTOSAR" == te_thread.flavor )
    te_sys.AUTOSAR = true;
  end if;
end if;
//
select any te_disp from instances of TE_DISP;
if ( empty te_disp )
  create object instance te_disp of TE_DISP;
  te_disp.Dispatcher_ID = 1;
  relate te_disp to te_sys across R2003;
end if;
te_disp.Descrip = "dispatcher";
te_disp.Name = "main";
select any te_queue from instances of TE_QUEUE;
select any nonself_te_queue from instances of TE_QUEUE;
if ( empty te_queue )
  create object instance te_queue of TE_QUEUE;
  te_queue.Queue_ID = 1;
  relate te_queue to te_disp across R2004;
  create object instance nonself_te_queue of TE_QUEUE;
  nonself_te_queue.Queue_ID = 2;
  relate nonself_te_queue to te_disp across R2004;
end if;
// Self Queue
te_queue.Descrip = "Self Queue";
te_queue.RenderCode = false;
te_queue.MaxDepth = 0;
te_queue.Type = 1;
// NonSelf Queue
nonself_te_queue.Descrip = "NonSelf Queue";
nonself_te_queue.RenderCode = false;
nonself_te_queue.MaxDepth = 0;
nonself_te_queue.Type = 2;
//
// Create the (domain) class info array instance.
// CDS - This may end up being part of a component rather than a system.
create object instance te_cia of TE_CIA;
te_cia.class_info_name = "domain_class_info";
te_cia.class_info_type = te_extent.type;
te_cia.active_count = "active_count";
te_cia.class_count = "domain_class_count";
te_cia.count_type = te_typemap.object_number_name;
//
//
// Create the Extended Component instance(s) and link them up.
select many c_cs from instances of C_C;
for each c_c in c_cs
  create object instance te_c of TE_C;
  relate te_c to c_c across R2054;
  relate te_c to te_sys across R2065;
  te_c.Name = T::r(s:c_c.Name);
  te_c.Descrip = c_c.Descrip;
  te_c.included_in_build = true;
    select any tm_c from instances of TM_C where ( selected.Name == c_c.Name );
  if ( not_empty tm_c )
    if ( ( tm_c.isRealized ) or ( c_c.isRealized ) )
      // Component is realized, so skip translation of internals.
      te_c.isRealized = true;
    end if;
  end if;
  te_c.internal_behavior = false;
  te_c.module_file = te_c.Name;
  te_c.port_file = te_c.Name;
  te_c.classes_file = te_c.Name + "_classes";
  te_c.CodeComments = true;
  // Create and relate the domain class info to carry details about
  // class extents for this component.
  create object instance te_dci of TE_DCI;
  relate te_dci to te_c across R2090;
  te_dci.class_numbers = te_c.Name + "_CLASS_NUMBERS";
  te_dci.persist_union = te_c.Name + "_CLASS_U";
  te_dci.task_list = te_c.Name + "_task_numbers";
  te_dci.task_numbers = te_c.Name + "_TASK_NUMBERS";
  te_dci.max = te_c.Name + "_MAX_CLASS_NUMBERS";
  te_dci.max_models = te_c.Name + "_STATE_MODELS";
  te_dci.init = te_c.Name + "_CLASS_INFO_INIT";
  te_dci.array_name = te_c.Name + "_class_info";
  // Create the Component Instance instances.
  select many cl_ics related by c_c->CL_IC[R4201];
  for each cl_ic in cl_ics
    create object instance te_ci of TE_CI;
    te_ci.Name = te_c.Name;
    if ( "" == cl_ic.ClassifierName )
      te_ci.ClassifierName = "i" + te_c.Name;
    else
      te_ci.ClassifierName = T::r(s:cl_ic.ClassifierName);
    end if;
    relate te_ci to te_c across R2008;
    relate te_ci to cl_ic across R2009;
  end for;
  // Create the Extended Ports.
  select many c_pos related by c_c->C_PO[R4010];
  for each c_po in c_pos
    select any c_i related by c_po->C_IR[R4016]->C_I[R4012];
    if ( not_empty c_i )
      create object instance te_po of TE_PO;
      relate te_po to c_po across R2044;
      relate te_po to te_c across R2005;
      relate te_po to c_i across R2007;
      te_po.InterfaceName = T::r(s:c_i.Name);
      select any c_r related by c_po->C_IR[R4016]->C_R[R4009];
      if ( not_empty c_r )
        te_po.Provision = false;
      else
        te_po.Provision = true;
      end if;
      te_po.polymorphic = false;
      te_po.sibling = 0;
      te_po.Name = c_po.Name;
      te_po.GeneratedName = T::r(s:te_po.Name);
      // Create the Interface Instance instances.
      select many c_irs related by c_po->C_IR[R4016];
      for each c_ir in c_irs
        create object instance te_iir of TE_IIR;
                        relate te_iir to c_ir across R2046;
        relate te_iir to te_po across R2080;
        te_iir.component_name = c_c.Name;
        te_iir.port_name = te_po.Name;
        te_iir.interface_name = te_po.InterfaceName;
        te_iir.polymorphic = false;
        select many cl_iirs related by c_ir->CL_IIR[R4701];
        for each cl_iir in cl_iirs
          create object instance te_iir of TE_IIR;
                              relate te_iir to cl_iir across R2013;
          relate te_iir to te_po across R2080;
          te_iir.port_name = te_po.Name;
          te_iir.interface_name = te_po.InterfaceName;
          te_iir.polymorphic = false;
        end for;
      end for;
    end if;
  end for;
  // Identify polymorhic ports.
  // Polymorphic ports exist more than once in the same orientation on a component.
  port_counter = 0;
  select many te_pos related by te_c->TE_PO[R2005];
  for each te_po in te_pos
    te_po.Order = port_counter;
    port_counter = port_counter + 1;
    select many poly_te_pos related by te_po->TE_C[R2005]->TE_PO[R2005] where ( ( ( selected.c_iId == te_po.c_iId ) and ( selected.Provision == te_po.Provision ) ) and ( selected.ID != te_po.ID ) );
    if ( not_empty poly_te_pos )
      // If we have seen this port already, it will be marked as polymorphic.
      // So, no need to iterate marking as not the first sibling.
      if ( not te_po.polymorphic )
        sibling_counter = 1;
        for each poly_te_po in poly_te_pos
          poly_te_po.polymorphic = true;
          poly_te_po.sibling = sibling_counter;
          sibling_counter = sibling_counter + 1;
        end for;
      end if;
      te_po.polymorphic = true;
      // Now mark the related interface reference instances as polymorphic.
      select many te_iirs related by te_po->TE_IIR[R2080];
      for each te_iir in te_iirs
        te_iir.polymorphic = true;
      end for;
    end if;
  end for;
end for;
// Here we force all the ports and interface references to be polymorphic.  
// We do this step via a second loop here so that we could set up the 
// sibling values earlier before all the ports potentially get forced to polymorphic.
// This loop also configures the satisfaction shortcut we create between local and
// foreign interface references.
select many te_pos from instances of TE_PO;
for each te_po in te_pos
  // CDS - review/remove
  if ( te_sys.AllPortsPoly )
    te_po.polymorphic = true;
  end if;
  select many te_iirs related by te_po->TE_IIR[R2080];
  for each te_iir in te_iirs
    // CDS - review/remove
    if ( te_sys.AllPortsPoly )
      te_iir.polymorphic = true;
    end if;
    // Select across the satisfaction to get the related TE_IIR.
    if ( te_po.Provision )
      // provision side first
      // CDS There may be more than one here.
      select any foreign_te_iir related by te_iir->CL_IIR[R2013]->CL_IP[R4703]->CL_IPINS[R4705]->C_SF[R4705]->CL_IR[R4706]->CL_IIR[R4703]->TE_IIR[R2013];
      if ( empty foreign_te_iir )
        // We are dealing with TE_IIRs that may be on non-imported interface references (connected to C_Cs).
        select any foreign_te_iir related by te_iir->C_IR[R2046]->C_P[R4009]->C_SF[R4002]->C_R[R4002]->C_IR[R4009]->TE_IIR[R2046];
        if ( empty foreign_te_iir )
          select any foreign_te_iir related by te_iir->CL_IIR[R2013]->CL_IP[R4703]->CL_IPINS[R4705]->C_SF[R4705]->C_R[R4002]->C_IR[R4009]->TE_IIR[R2046];
          if ( empty foreign_te_iir )
            select any foreign_te_iir related by te_iir->C_IR[R2046]->C_P[R4009]->C_SF[R4002]->CL_IR[R4706]->CL_IIR[R4703]->TE_IIR[R2013];
          end if;
        end if;
      end if;
      if ( not_empty foreign_te_iir )
        relate te_iir to foreign_te_iir across R2081.''provides or is delegated'';
      end if;
    else
      // requirement side first
      select one foreign_te_iir related by te_iir->CL_IIR[R2013]->CL_IR[R4703]->C_SF[R4706]->CL_IPINS[R4705]->CL_IP[R4705]->CL_IIR[R4703]->TE_IIR[R2013];
      if ( empty foreign_te_iir )
        select any foreign_te_iir related by te_iir->C_IR[R2046]->C_R[R4009]->C_SF[R4002]->C_P[R4002]->C_IR[R4009]->TE_IIR[R2046];
        if ( empty foreign_te_iir )
          select one foreign_te_iir related by te_iir->CL_IIR[R2013]->CL_IR[R4703]->C_SF[R4706]->C_P[R4002]->C_IR[R4009]->TE_IIR[R2046];
          if ( empty foreign_te_iir )
            select any foreign_te_iir related by te_iir->C_IR[R2046]->C_R[R4009]->C_SF[R4002]->CL_IPINS[R4705]->CL_IP[R4705]->CL_IIR[R4703]->TE_IIR[R2013];
          end if;
        end if;
      end if;
      if ( not_empty foreign_te_iir )
        relate te_iir to foreign_te_iir across R2081.''requires or delegates'';
      end if;
    end if;
  end for;
end for;
//
// By default, select all components to be translated.  However, if
// a package has been marked, translate only the components contained
// in the package (or referenced from it).
ep_pkgs = empty_ep_pkgs;
cp_cp = empty_cp_cp;
package_to_build = "";
select any tm_build from instances of TM_BUILD;
markedsystems = 0;
if ( not_empty tm_build )
  select many ep_pkgs from instances of EP_PKG where ( selected.Name == tm_build.package_to_build );
  markedsystems = cardinality ep_pkgs;
  if ( empty ep_pkgs )
    T::print(s:"ERROR:  Marked configuration package T::s(i:tm_build.package_to_build) was not found in model.  Exiting.");
    T::exit(i:11);
  end if;
  package_to_build = tm_build.package_to_build;
end if;
if ( markedsystems > 1 )
  T::print(s:"WARNING:  More than one package is marked as a system build... choose only one.");
end if;
if ( "" != package_to_build )
  T::print(s:"Marked configuration package T::s(i:package_to_build) found.");
  select many te_cs from instances of TE_C;
  // Clear the build flag for all components and then mark only those
  // requested by the marking.
  for each te_c in te_cs
    te_c.included_in_build = false;
  end for;
  select many te_cs related by ep_pkgs->PE_PE[R8000]->C_C[R8001]->TE_C[R2054];
  select many nested_te_cs related by ep_pkgs->PE_PE[R8000]->EP_PKG[R8001]->PE_PE[R8000]->C_C[R8001]->TE_C[R2054];
  te_cs = te_cs;
  select many referenced_te_cs related by ep_pkgs->PE_PE[R8000]->CL_IC[R8001]->C_C[R4201]->TE_C[R2054];
  te_cs = te_cs;
  select many nested_referenced_te_cs related by ep_pkgs->PE_PE[R8000]->EP_PKG[R8001]->PE_PE[R8000]->CL_IC[R8001]->C_C[R4201]->TE_C[R2054];
  te_cs = te_cs;
  ::TE_C_mark_nested_system( te_cs:te_cs );
  // Uncomment the line below to use package name instead of project for the top-level files.
  //.assign te_sys.Name = "$r{package_to_build}"
else
  // Here we use the default name for the system derived from the project name.
end if;
te_file.types = ( te_sys.Name + "_" ) + te_file.types;
te_file.sys_main = ( te_sys.Name + "_" ) + te_file.sys_main;
//
// Create and link the Extended model compiler instances.
// Do not fully initialize, yet.  Create and link and mark.
// These artifacts contain important naming that must propagate.
//
// Create the Generated Data Type instances and link them in.
select many s_dts from instances of S_DT;
for each s_dt in s_dts
  create object instance te_dt of TE_DT;
  relate te_dt to s_dt across R2021;
  te_dt.Name = s_dt.Name;
  te_dt.Core_Typ = -1;
  te_dt.string_format = "";
    // Link the ownership if contained in a component.
  te_c = empty_te_c;
  select one ep_pkg related by s_dt->PE_PE[R8001]->EP_PKG[R8000];
  if ( not_empty ep_pkg )
    r = ::TE_C_getContainingComponent( ep_pkg:ep_pkg );
    te_c = r;
  end if;
  if ( empty te_c )
    // Default the owner to be the system.
    te_dt.Owning_Dom_Name = te_sys.Name;
  else
    te_dt.Owning_Dom_Name = te_c.Name;
    relate te_dt to te_c across R2086;
  end if;
end for;
select any converted_bool_te_dt from instances of TE_DT where ( selected.Name == "integer" );
//
select many o_objs from instances of O_OBJ;
for each o_obj in o_objs
  te_c = empty_te_c;
  select one ep_pkg related by o_obj->PE_PE[R8001]->EP_PKG[R8000];
  r = ::TE_C_getContainingComponent( ep_pkg:ep_pkg );
  te_c = r;
  if ( not_empty te_c )
    if ( ( te_c.included_in_build ) and ( not te_c.isRealized ) )
      te_c.internal_behavior = true;
      // Create the Generated Class instance and link it to the real one.
      r1 = ::FactoryTE_CLASS( o_obj:o_obj, te_c:te_c );
      te_class = r1;
    end if;
  end if;
end for;
//
select many s_syncs from instances of S_SYNC;
for each s_sync in s_syncs
  te_c = empty_te_c;
  select one ep_pkg related by s_sync->PE_PE[R8001]->EP_PKG[R8000];
  r = ::TE_C_getContainingComponent( ep_pkg:ep_pkg );
  te_c = r;
  if ( not_empty te_c )
    if ( ( te_c.included_in_build ) and ( not te_c.isRealized ) )
      te_c.internal_behavior = true;
      // Create the Extended Function instance and link it to the real one.
      create object instance te_sync of TE_SYNC;
      relate s_sync to te_sync across R2023;
      relate te_sync to te_c across R2084;
      te_sync.Name = s_sync.Name;
      te_sync.GeneratedName = ( te_c.Name + "_" ) + te_sync.Name;
    end if;
  end if;
end for;
//
select many s_ees from instances of S_EE;
for each s_ee in s_ees
  select one ep_pkg related by s_ee->PE_PE[R8001]->EP_PKG[R8000];
  r = ::TE_C_getContainingComponent( ep_pkg:ep_pkg );
  te_c = r;
  if ( empty te_c )
    // Here we have an EE in a package outside of a component.
    create object instance te_ee of TE_EE;
    relate te_ee to s_ee across R2020;
    // Be sure we are not related to any te_c across R2085
      else
    if ( ( te_c.included_in_build ) and ( not te_c.isRealized ) )
      te_c.internal_behavior = true;
      // Create the Extended EE instance and link it to the real one.
      create object instance te_ee of TE_EE;
      relate te_ee to s_ee across R2020;
      relate te_ee to te_c across R2085;
    end if;
  end if;
end for;
//
//
// Create the low-level leaf items.
//
// Initialize information for a core data type:  the ANSI C typedef
// that the data type is known by in the generated code in both a
// normal object declaration and an event declaration and the initial
// value of the data element.
select many s_cdts from instances of S_CDT;
for each s_cdt in s_cdts
  select one te_dt related by s_cdt->S_DT[R17]->TE_DT[R2021];
  te_dt.Core_Typ = s_cdt.Core_Typ;
  te_dt.Include_File = te_file.types + ( "." + te_file.hdr_file_ext );
  if ( 0 == te_dt.Core_Typ )
    // void
    te_dt.ExtName = "void";
    te_dt.Initial_Value = "0";
    te_dt.string_format = "";
  elif ( 1 == te_dt.Core_Typ )
    // boolean
    if ( te_sys.AUTOSAR )
      te_dt.ExtName = "dt_xtUMLBoolean";
    else
      te_dt.ExtName = "bool";
    end if;
    te_dt.Initial_Value = "false";
    te_dt.string_format = "%d";
  elif ( 2 == te_dt.Core_Typ )
    // integer
    if ( te_sys.AUTOSAR )
      te_dt.ExtName = "dt_xtUMLInteger";
    else
      te_dt.ExtName = "i_t";
    end if;
    te_dt.Initial_Value = "0";
    te_dt.string_format = "%d";
  elif ( 3 == te_dt.Core_Typ )
    // real
    // float or double:  Default to smaller type for embedded.
    // This can be expanded with the TagDatatypePrecision marking.
    if ( te_sys.AUTOSAR )
      te_dt.ExtName = "dt_xtUMLReal";
    else
      te_dt.ExtName = "r_t";
    end if;
    te_dt.Initial_Value = "0.0";
    te_dt.string_format = "%f";
  elif ( 4 == te_dt.Core_Typ )
    // string
    te_dt.ExtName = "c_t";
    te_dt.Initial_Value = "CTOR";
    te_dt.string_format = "''%s''";
  elif ( 5 == te_dt.Core_Typ )
    // unique_id
    te_dt.ExtName = te_prefix.type + "UniqueID_t";
    te_dt.Initial_Value = "0";
    te_dt.string_format = "%p";
    //
  elif ( 6 == te_dt.Core_Typ )
    // current_state
    te_dt.ExtName = "";
    te_dt.Initial_Value = "";
    te_dt.string_format = "%d";
  elif ( 7 == te_dt.Core_Typ )
    // same as base<Attribute>
    te_dt.ExtName = "";
    te_dt.Initial_Value = "";
    te_dt.string_format = "%p";
  elif ( 8 == te_dt.Core_Typ )
    // inst_ref<Object>
    te_dt.ExtName = "void *";
    te_dt.Initial_Value = "";
    te_dt.string_format = "%p";
  elif ( 9 == te_dt.Core_Typ )
    // inst_ref_set<Object>
    te_dt.ExtName = te_set.base_class + " *";
    te_dt.Initial_Value = "";
    te_dt.string_format = "%p";
  elif ( 10 == te_dt.Core_Typ )
    // inst<Event>
    te_dt.ExtName = te_eq.base_event_type + " *";
    te_dt.Initial_Value = "0";
    te_dt.string_format = "%p";
    //
  elif ( 11 == te_dt.Core_Typ )
    // inst<Mapping>
    te_dt.ExtName = "";
    te_dt.Initial_Value = "";
    te_dt.string_format = "%d";
  elif ( 12 == te_dt.Core_Typ )
    // inst_ref<Mapping>
    te_dt.ExtName = "i_t";
    te_dt.Initial_Value = "0";
    te_dt.string_format = "%d";
  else
    // undefined
    te_dt.ExtName = "";
    te_dt.Initial_Value = "";
    te_dt.string_format = "%x";
  end if;
end for;
//
// Initialize information for user data types.
select many s_udts from instances of S_UDT;
for each s_udt in s_udts
  r = ::GetBaseTypeForUDT( s_udt:s_udt );
  base_s_dt = r;
  select one core_te_dt related by base_s_dt->TE_DT[R2021];
  // Given a user data type (S_UDT) and a core data type (S_CDT), set
  // the C typedef that the user data type is known by in the generated
  // code.  Also set the initial value of the attribute.
  // Note:  An initial value of "CTOR" means to run the constructor.
  select one s_dt related by s_udt->S_DT[R17];
  select one te_dt related by s_dt->TE_DT[R2021];
  te_dt.Is_Enum = false;
  te_dt.Core_Typ = core_te_dt.Core_Typ;
  te_dt.Include_File = core_te_dt.Include_File;
  te_dt.ExtName = core_te_dt.ExtName;
  te_dt.string_format = core_te_dt.string_format;
  if ( "" != s_dt.DefaultValue )
    te_dt.Initial_Value = s_dt.DefaultValue;
  else
    te_dt.Initial_Value = core_te_dt.Initial_Value;
  end if;
  //
  // CTOR is a special string used to invoke the constructor of a data
  // attribute on the initialization list of the object constructor.
  if ( s_dt.Name == "date" )
    te_dt.ExtName = te_prefix.type + "Date_t";
    te_dt.Initial_Value = "CTOR";
  elif ( s_dt.Name == "timestamp" )
    te_dt.ExtName = te_prefix.type + "TimeStamp_t";
    te_dt.Initial_Value = "CTOR";
  elif ( s_dt.Name == "inst_ref<Timer>" )
    if ( te_tim.keyed_timer_support )
      te_dt.ExtName = te_prefix.type + "Timer_t";
    else
      te_dt.ExtName = te_prefix.type + "Timer_t *";
    end if;
    te_dt.Initial_Value = "0";
  elif ( s_dt.Name == "inst_ref<StateMachine>" )
    te_dt.ExtName = "<T::s(i:te_prefix.type)Object Type *>";
    te_dt.Initial_Value = "0";
  elif ( s_dt.Name == "arbitrary_id" )
    te_dt.ExtName = te_prefix.type + "UniqueID_t";
    te_dt.Initial_Value = "0";
  end if;
end for;
//
// Initialize information for enumeration data types.
select many s_edts from instances of S_EDT;
for each s_edt in s_edts
  select one s_dt related by s_edt->S_DT[R17];
  select one te_dt related by s_dt->TE_DT[R2021];
  // NOTE: We should allow the size of an enum to be colored.
  // For now use small type.
  if ( te_sys.AUTOSAR )
    te_dt.ExtName = "en_" + te_dt.Name;
  elif ( "C" == te_target.language )
    te_dt.ExtName = ( te_sys.Name + "_" ) + ( te_dt.Name + "_t" );
  else
    te_dt.ExtName = te_dt.Name + "_t";
  end if;
  // CDS We should some day pass along the EDT.
  te_dt.Core_Typ = 2;
  te_dt.Is_Enum = true;
  te_dt.Initial_Value = ( te_dt.Owning_Dom_Name + "_" ) + ( te_dt.Name + "__UNINITIALIZED__e" );
  te_dt.Value = "-1";
  te_dt.string_format = "%d";
  if ( te_dt.Owning_Dom_Name == "sys" )
    te_dt.Include_File = ( te_file.types + "." ) + te_file.hdr_file_ext;
  end if;
  //
  // Create the Generated Enumerators and link them to the real ones.
  select many s_enums related by s_edt->S_ENUM[R27];
  for each s_enum in s_enums
    create object instance te_enum of TE_ENUM;
    relate s_enum to te_enum across R2027;
    te_enum.Name = s_enum.Name;
    te_enum.GeneratedName = ( ( te_dt.Owning_Dom_Name + "_" ) + ( te_dt.Name + "_" ) ) + ( T::r(s:te_enum.Name) + "_e" );
  end for;
end for;
//
// Initialize structured data types.
select many s_sdts from instances of S_SDT;
for each s_sdt in s_sdts
  select one te_dt related by s_sdt->S_DT[R17]->TE_DT[R2021];
  te_dt.ExtName = ( te_dt.Owning_Dom_Name + "_sdt_" ) + te_dt.Name;
  te_dt.string_format = "";
  select many s_mbrs related by s_sdt->S_MBR[R44];
  for each s_mbr in s_mbrs
    create object instance te_mbr of TE_MBR;
    relate s_mbr to te_mbr across R2047;
    select one mbr_te_dt related by s_mbr->S_DT[R45]->TE_DT[R2021];
    relate te_mbr to mbr_te_dt across R2068;
  end for;
  for each s_mbr in s_mbrs
    select one te_mbr related by s_mbr->TE_MBR[R2047];
    select one previous_te_mbr related by s_mbr->S_MBR[R46.''precedes'']->TE_MBR[R2047];
    if ( not_empty previous_te_mbr )
      relate te_mbr to previous_te_mbr across R2067.''precedes'';
    else
          end if;
    te_mbr.Name = s_mbr.Name;
    te_mbr.GeneratedName = T::r(s:s_mbr.Name);
    select many s_dims related by s_mbr->S_DIM[R53];
    array_spec = "";
    te_mbr.dimensions = cardinality s_dims;
    te_dim = empty_te_dim;
    dim_index = 0;
    while ( dim_index < te_mbr.dimensions )
      select any s_dim related by s_mbr->S_DIM[R53] where ( selected.dimensionCount == dim_index );
      r = ::FactoryTE_DIM( s_dim:s_dim, predecessor_te_dim:te_dim );
      te_dim = r;
      if ( dim_index == 0 )
        relate te_dim to te_mbr across R2059;
      end if;
      array_spec = ( array_spec + "[" ) + ( T::s(i:te_dim.elementCount) + "]" );
      dim_index = dim_index + 1;
    end while;
    te_mbr.array_spec = array_spec;
    // In the C model compiler, treat strings as arrays.
    select one mbr_te_dt related by s_mbr->S_DT[R45]->TE_DT[R2021];
    if ( 4 == mbr_te_dt.Core_Typ )
      // string
      te_mbr.dimensions = te_mbr.dimensions + 1;
      te_mbr.array_spec = ( te_mbr.array_spec + "[" ) + ( te_string.max_string_length + "]" );
    end if;
  end for;
end for;
//
// Initialize instance reference data types.
select many s_irdts from instances of S_IRDT;
for each s_irdt in s_irdts
  select one te_dt related by s_irdt->S_DT[R17]->TE_DT[R2021];
  select one te_class related by s_irdt->O_OBJ[R123]->TE_CLASS[R2019];
  if ( s_irdt.isSet )
    te_dt.ExtName = te_set.base_class + " *";
  else
    if ( not_empty te_class )
      te_dt.ExtName = te_class.GeneratedName + " *";
    end if;
  end if;
end for;
//
// Update the precision of the integer and real types based on marking.
select many tm_precisions from instances of TM_PRECISION;
for each tm_precision in tm_precisions
  te_dts = empty_te_dts;
  if ( ( "*" == tm_precision.Domain ) or ( "" == tm_precision.Domain ) )
    select many te_dts from instances of TE_DT where ( selected.Name == tm_precision.DT_name );
  else
    select any te_c from instances of TE_C where ( selected.Name == tm_precision.Domain );
    // TODO SKB - we do not handle any deep nesting here.  Just datatypes right under the component and under a package under the component
    select many te_dts related by te_c->C_C[R2054]->PE_PE[R8003]->EP_PKG[R8001]->PE_PE[R8000]->S_DT[R8001]->TE_DT[R2021] where ( selected.Name == tm_precision.DT_name );
  end if;
  for each te_dt in te_dts
    // Only allow precision specification of core types integer
    // and real and user defined types (UDTs) that are enums
    // (including S_EDT).
    // S_CDT.Core_Typ == 2 is integer, S_CDT.Core_Typ == 3 is real
    select one s_dt related by te_dt->S_DT[R2021];
    select one s_edt related by s_dt->S_EDT[R17];
    select one s_cdt related by s_dt->S_CDT[R17];
    if ( empty s_cdt )
      select one s_udt related by s_dt->S_UDT[R17];
      if ( not_empty s_udt )
        r = ::GetBaseTypeForUDT( s_udt:s_udt );
        base_s_dt = r;
        select one s_cdt related by base_s_dt->S_CDT[R17];
      end if;
      if ( empty s_cdt )
        select one s_irdt related by s_dt->S_IRDT[R17];
        if ( empty s_irdt )
          if ( empty s_edt )
            T::print(s:"Warning:  Could not find a core data type (S_CDT) for input type.");
            T::exit(i:101);
          end if;
          // Enumeration Data Type (S_EDT) - give it a core type of integer.
          select any s_cdt from instances of S_CDT where ( selected.Core_Typ == 2 );
        else
          if ( s_irdt.isSet )
            select any s_cdt from instances of S_CDT where ( selected.Core_Typ == 9 );
          else
            select any s_cdt from instances of S_CDT where ( selected.Core_Typ == 8 );
          end if;
        end if;
      end if;
    end if;
    if ( ( s_cdt.Core_Typ == 2 ) or ( s_cdt.Core_Typ == 3 ) )
      r = ::MapUserSpecifiedDataTypePrecision( te_dt:te_dt, mapping:tm_precision.xName );
      status_error = r;
      if ( status_error )
        te_dt.ExtName = tm_precision.xName;
      end if;
      if ( ( "" != tm_precision.initial_value ) and ( empty s_edt ) )
        te_dt.Initial_Value = tm_precision.initial_value;
      end if;
    end if;
  end for;
end for;
//
// Map data types to pointers based on marking.
select many tm_pointers from instances of TM_POINTER;
for each tm_pointer in tm_pointers
  te_dts = empty_te_dts;
  if ( ( "*" == tm_pointer.Domain ) or ( "" == tm_pointer.Domain ) )
    select many te_dts from instances of TE_DT where ( selected.Name == tm_pointer.DT_name );
  else
    select any te_c from instances of TE_C where ( selected.Name == tm_pointer.Domain );
    // TODO SKB - we do not handle any deep nesting here.  Just datatypes right under the component and under a package under the component
    select many te_dts related by te_c->C_C[R2054]->PE_PE[R8003]->EP_PKG[R8001]->PE_PE[R8000]->S_DT[R8001]->TE_DT[R2021] where ( selected.Name == tm_pointer.DT_name );
  end if;
  for each te_dt in te_dts
    te_dt.ExtName = tm_pointer.pointer_type + " *";
    te_dt.Initial_Value = "0";
    te_dt.Include_File = tm_pointer.include_file;
    te_dt.Is_Enum = false;
    if ( 4 == te_dt.Core_Typ )
      // Change core type so that dimensions are not added to the pointer.
      te_dt.Core_Typ = -4;
    end if;
  end for;
end for;
//
// Mark enumerator discrete values (from marking).
select many tm_enumvals from instances of TM_ENUMVAL;
for each tm_enumval in tm_enumvals
  te_dts = empty_te_dts;
  if ( ( "*" == tm_enumval.Domain ) or ( "" == tm_enumval.Domain ) )
    select many te_dts from instances of TE_DT where ( selected.Name == tm_enumval.enumeration );
  else
    select any te_c from instances of TE_C where ( selected.Name == tm_enumval.Domain );
    // TODO SKB - we do not handle any deep nesting here.  Just datatypes right under the component and under a package under the component
    select many te_dts related by te_c->C_C[R2054]->PE_PE[R8003]->EP_PKG[R8001]->PE_PE[R8000]->S_DT[R8001]->TE_DT[R2021] where ( selected.Name == tm_enumval.enumeration );
  end if;
  for each te_dt in te_dts
    select any te_enum related by te_dt->S_DT[R2021]->S_EDT[R17]->S_ENUM[R27]->TE_ENUM[R2027] where ( selected.Name == tm_enumval.enumerator );
    if ( not_empty te_enum )
      te_enum.Value = tm_enumval.value;
    end if;
  end for;
end for;
//
// Mark enumerator default uninitialized values (from marking).
select many tm_enuminits from instances of TM_ENUMINIT;
for each tm_enuminit in tm_enuminits
  te_dts = empty_te_dts;
  if ( ( "*" == tm_enuminit.Domain ) or ( "" == tm_enuminit.Domain ) )
    select many te_dts from instances of TE_DT where ( selected.Name == tm_enuminit.enumeration );
  else
    select any te_c from instances of TE_C where ( selected.Name == tm_enuminit.Domain );
    // TODO SKB - we do not handle any deep nesting here.  Just datatypes right under the component and under a package under the component
    select many te_dts related by te_c->C_C[R2054]->PE_PE[R8003]->EP_PKG[R8001]->PE_PE[R8000]->S_DT[R8001]->S_EDT[R17]->S_DT[R17]->TE_DT[R2021] where ( selected.Name == tm_enuminit.enumeration );
  end if;
  for each te_dt in te_dts
    te_dt.Value = tm_enuminit.value;
  end for;
end for;
//
// Create the values and connect them to the V_VAL.
select many v_vals from instances of V_VAL;
for each v_val in v_vals
  create object instance te_val of TE_VAL;
  relate v_val to te_val across R2040;
  te_val.array_spec = "";
  te_val.dimensions = 0;
end for;
//
// Create the extended actual parameters and connect them to V_PAR.
select many v_pars from instances of V_PAR;
for each v_par in v_pars
  create object instance te_par of TE_PAR;
  te_par.Name = v_par.Name;
  te_par.By_Ref = 0;
  relate te_par to v_par across R2063;
end for;
//
// Create the Generated Parameters needed for all types of parameters.
// During this process, te_pars created above will be updated with
// By_Ref information.
// The TE_PARM instances must exist before creating the action bodies
// (for functions, operation, messages, etc).
prefix = "p_";
select many s_bparms from instances of S_BPARM;
for each s_bparm in s_bparms
  select many s_dims related by s_bparm->S_DIM[R49];
  select one te_dt related by s_bparm->S_DT[R22]->TE_DT[R2021];
  r = ::FactoryTE_PARM( s_dims:s_dims, te_dt:te_dt, prefix:prefix, name:s_bparm.Name, description:s_bparm.Descrip, by_ref:s_bparm.By_Ref );
  te_parm = r;
  relate s_bparm to te_parm across R2028;
  select many te_pars related by s_bparm->S_BRG[R21]->ACT_BRG[R674]->V_PAR[R628]->TE_PAR[R2063] where ( selected.Name == te_parm.Name );
  for each te_par in te_pars
    te_par.By_Ref = te_parm.By_Ref;
    relate te_par to te_parm across R2091;
  end for;
  select many te_pars related by s_bparm->S_BRG[R21]->V_BRV[R828]->V_PAR[R810]->TE_PAR[R2063] where ( selected.Name == te_parm.Name );
  for each te_par in te_pars
    te_par.By_Ref = te_parm.By_Ref;
    relate te_par to te_parm across R2091;
  end for;
end for;
// Link the event parameters into order.
for each s_bparm in s_bparms
  select one te_parm related by s_bparm->TE_PARM[R2028];
  select one next_te_parm related by s_bparm->S_BPARM[R55.''succeeds'']->TE_PARM[R2028];
  if ( not_empty next_te_parm )
    relate te_parm to next_te_parm across R2041.''succeeds'';
  end if;
end for;
select many o_tparms from instances of O_TPARM;
for each o_tparm in o_tparms
  select many s_dims related by o_tparm->S_DIM[R121];
  select one te_dt related by o_tparm->S_DT[R118]->TE_DT[R2021];
  r = ::FactoryTE_PARM( s_dims:s_dims, te_dt:te_dt, prefix:prefix, name:o_tparm.Name, description:o_tparm.Descrip, by_ref:o_tparm.By_Ref );
  te_parm = r;
  relate o_tparm to te_parm across R2029;
  select many te_pars related by o_tparm->O_TFR[R117]->ACT_TFM[R673]->V_PAR[R627]->TE_PAR[R2063] where ( selected.Name == te_parm.Name );
  for each te_par in te_pars
    te_par.By_Ref = te_parm.By_Ref;
    relate te_par to te_parm across R2091;
  end for;
  select many te_pars related by o_tparm->O_TFR[R117]->V_TRV[R829]->V_PAR[R811]->TE_PAR[R2063] where ( selected.Name == te_parm.Name );
  for each te_par in te_pars
    te_par.By_Ref = te_parm.By_Ref;
    relate te_par to te_parm across R2091;
  end for;
end for;
// Link the event parameters into order.
for each o_tparm in o_tparms
  select one te_parm related by o_tparm->TE_PARM[R2029];
  select one next_te_parm related by o_tparm->O_TPARM[R124.''succeeds'']->TE_PARM[R2029];
  if ( not_empty next_te_parm )
    relate te_parm to next_te_parm across R2041.''succeeds'';
  end if;
end for;
select many s_sparms from instances of S_SPARM;
for each s_sparm in s_sparms
  select many s_dims related by s_sparm->S_DIM[R52];
  select one te_dt related by s_sparm->S_DT[R26]->TE_DT[R2021];
  r = ::FactoryTE_PARM( s_dims:s_dims, te_dt:te_dt, prefix:prefix, name:s_sparm.Name, description:s_sparm.Descrip, by_ref:s_sparm.By_Ref );
  te_parm = r;
  relate s_sparm to te_parm across R2030;
  select many te_pars related by s_sparm->S_SYNC[R24]->ACT_FNC[R675]->V_PAR[R669]->TE_PAR[R2063] where ( selected.Name == te_parm.Name );
  for each te_par in te_pars
    te_par.By_Ref = te_parm.By_Ref;
    relate te_par to te_parm across R2091;
  end for;
  select many te_pars related by s_sparm->S_SYNC[R24]->V_FNV[R827]->V_PAR[R817]->TE_PAR[R2063] where ( selected.Name == te_parm.Name );
  for each te_par in te_pars
    te_par.By_Ref = te_parm.By_Ref;
    relate te_par to te_parm across R2091;
  end for;
end for;
// Link the event parameters into order.
for each s_sparm in s_sparms
  select one te_parm related by s_sparm->TE_PARM[R2030];
  select one next_te_parm related by s_sparm->S_SPARM[R54.''succeeds'']->TE_PARM[R2030];
  if ( not_empty next_te_parm )
    relate te_parm to next_te_parm across R2041.''succeeds'';
  end if;
end for;
select many sm_evtdis from instances of SM_EVTDI;
for each sm_evtdi in sm_evtdis
  select many s_dims related by sm_evtdi->S_DIM[R531];
  select one te_dt related by sm_evtdi->S_DT[R524]->TE_DT[R2021];
  // Event data items are not passable By_Ref at this time.
  r = ::FactoryTE_PARM( s_dims:s_dims, te_dt:te_dt, prefix:prefix, name:sm_evtdi.Name, description:sm_evtdi.Descrip, by_ref:0 );
  te_parm = r;
  relate te_parm to sm_evtdi across R2031;
end for;
// Link the event parameters into order.
for each sm_evtdi in sm_evtdis
  select one te_parm related by sm_evtdi->TE_PARM[R2031];
  select one next_te_parm related by sm_evtdi->SM_EVTDI[R533.''succeeds'']->TE_PARM[R2031];
  if ( not_empty next_te_parm )
    relate te_parm to next_te_parm across R2041.''succeeds'';
  end if;
end for;
select many c_pps from instances of C_PP;
for each c_pp in c_pps
  select many s_dims related by c_pp->S_DIM[R4017];
  select one te_dt related by c_pp->S_DT[R4007]->TE_DT[R2021];
  c_pp_name = c_pp.Name;
  if ( "SystemC" == te_target.language )
    select one c_as related by c_pp->C_EP[R4006]->C_AS[R4004];
    if ( not_empty c_as )
      c_pp_name = ( c_as.Name + "_" ) + c_pp_name;
    else
      select one c_io related by c_pp->C_EP[R4006]->C_IO[R4004];
      c_pp_name = ( c_io.Name + "_" ) + c_pp_name;
    end if;
  end if;
  r = ::FactoryTE_PARM( s_dims:s_dims, te_dt:te_dt, prefix:prefix, name:c_pp_name, description:c_pp.Descrip, by_ref:c_pp.By_Ref );
  te_parm = r;
  relate c_pp to te_parm across R2048;
  select many spr_reps related by c_pp->C_EP[R4006]->SPR_REP[R4500];
  if ( not_empty spr_reps )
    select many te_pars related by spr_reps->SPR_RS[R4502]->ACT_SGN[R660]->V_PAR[R662]->TE_PAR[R2063] where ( selected.Name == c_pp.Name );
    for each te_par in te_pars
      te_par.By_Ref = te_parm.By_Ref;
      relate te_par to te_parm across R2091;
    end for;
    select many te_pars related by spr_reps->SPR_RO[R4502]->ACT_IOP[R657]->V_PAR[R679]->TE_PAR[R2063] where ( selected.Name == c_pp.Name );
    for each te_par in te_pars
      te_par.By_Ref = te_parm.By_Ref;
      relate te_par to te_parm across R2091;
    end for;
    select many te_pars related by spr_reps->V_MSV[R845]->V_PAR[R842]->TE_PAR[R2063] where ( selected.Name == c_pp.Name );
    for each te_par in te_pars
      te_par.By_Ref = te_parm.By_Ref;
      relate te_par to te_parm across R2091;
    end for;
  end if;
  select many spr_peps related by c_pp->C_EP[R4006]->SPR_PEP[R4501];
  if ( not_empty spr_peps )
    select many te_pars related by spr_peps->SPR_PS[R4503]->ACT_SGN[R663]->V_PAR[R662]->TE_PAR[R2063] where ( selected.Name == c_pp.Name );
    for each te_par in te_pars
      te_par.By_Ref = te_parm.By_Ref;
      relate te_par to te_parm across R2091;
    end for;
    select many te_pars related by spr_peps->SPR_PO[R4503]->ACT_IOP[R680]->V_PAR[R679]->TE_PAR[R2063] where ( selected.Name == c_pp.Name );
    for each te_par in te_pars
      te_par.By_Ref = te_parm.By_Ref;
      relate te_par to te_parm across R2091;
    end for;
    select many te_pars related by spr_peps->V_MSV[R841]->V_PAR[R842]->TE_PAR[R2063] where ( selected.Name == c_pp.Name );
    for each te_par in te_pars
      te_par.By_Ref = te_parm.By_Ref;
      relate te_par to te_parm across R2091;
    end for;
  end if;
end for;
// Link the event parameters into order.
for each c_pp in c_pps
  select one te_parm related by c_pp->TE_PARM[R2048];
  select one next_te_parm related by c_pp->C_PP[R4021.''succeeds'']->TE_PARM[R2048];
  if ( not_empty next_te_parm )
    relate te_parm to next_te_parm across R2041.''succeeds'';
  end if;
end for;
//
//
select any void_te_dt from instances of TE_DT where ( selected.Core_Typ == 0 );
//
// Create the port message actions.  There are four types.  Use
// a common extension class for all of them.
// Populate the extension with all of the names it will need from
// the component, interface, port and message.
select many spr_ros from instances of SPR_RO;
for each spr_ro in spr_ros
  select one spr_rep related by spr_ro->SPR_REP[R4502];
  select one te_po related by spr_rep->C_R[R4500]->C_IR[R4009]->C_PO[R4016]->TE_PO[R2044];
  select one te_c related by te_po->TE_C[R2005];
  select one c_io related by spr_rep->C_EP[R4500]->C_IO[R4004];
  select one te_dt related by c_io->S_DT[R4008]->TE_DT[R2021];
  // If we are using TLM ports, convert booleans to integers
  if ( "SystemC" == te_target.language )
    if ( ( 1 == te_dt.Core_Typ ) and ( te_sys.SystemCPortsType == "TLM" ) )
      te_dt = converted_bool_te_dt;
    end if;
  end if;
  select many te_parms related by spr_rep->C_EP[R4500]->C_PP[R4006]->TE_PARM[R2048];
  r = ::FactoryTE_MACT( te_parms:te_parms, te_dt:te_dt, te_c:te_c, te_po:te_po, message_name:spr_ro.Name, description:c_io.Descrip, subtypeKL:"SPR_RO" );
  te_mact = r;
  te_mact.Direction = c_io.Direction;
  relate te_mact to spr_ro across R2052;
end for;
select many spr_rss from instances of SPR_RS;
for each spr_rs in spr_rss
  select one spr_rep related by spr_rs->SPR_REP[R4502];
  select one te_po related by spr_rep->C_R[R4500]->C_IR[R4009]->C_PO[R4016]->TE_PO[R2044];
  select one te_c related by te_po->TE_C[R2005];
  select one c_as related by spr_rep->C_EP[R4500]->C_AS[R4004];
  select many te_parms related by spr_rep->C_EP[R4500]->C_PP[R4006]->TE_PARM[R2048];
  r = ::FactoryTE_MACT( te_parms:te_parms, te_dt:void_te_dt, te_c:te_c, te_po:te_po, message_name:spr_rs.Name, description:c_as.Descrip, subtypeKL:"SPR_RS" );
  te_mact = r;
  te_mact.Direction = c_as.Direction;
  relate te_mact to spr_rs across R2053;
end for;
select many spr_pos from instances of SPR_PO;
for each spr_po in spr_pos
  select one spr_pep related by spr_po->SPR_PEP[R4503];
  select one te_po related by spr_pep->C_P[R4501]->C_IR[R4009]->C_PO[R4016]->TE_PO[R2044];
  select one te_c related by te_po->TE_C[R2005];
  select one c_io related by spr_pep->C_EP[R4501]->C_IO[R4004];
  select one te_dt related by c_io->S_DT[R4008]->TE_DT[R2021];
  // If we are using TLM ports, convert booleans to integers
  if ( "SystemC" == te_target.language )
    if ( ( 1 == te_dt.Core_Typ ) and ( te_sys.SystemCPortsType == "TLM" ) )
      te_dt = converted_bool_te_dt;
    end if;
  end if;
  select many te_parms related by spr_pep->C_EP[R4501]->C_PP[R4006]->TE_PARM[R2048];
  r = ::FactoryTE_MACT( te_parms:te_parms, te_dt:te_dt, te_c:te_c, te_po:te_po, message_name:spr_po.Name, description:c_io.Descrip, subtypeKL:"SPR_PO" );
  te_mact = r;
  te_mact.Direction = c_io.Direction;
  relate te_mact to spr_po across R2050;
end for;
select many spr_pss from instances of SPR_PS;
for each spr_ps in spr_pss
  select one spr_pep related by spr_ps->SPR_PEP[R4503];
  select one te_po related by spr_pep->C_P[R4501]->C_IR[R4009]->C_PO[R4016]->TE_PO[R2044];
  select one te_c related by te_po->TE_C[R2005];
  select one c_as related by spr_pep->C_EP[R4501]->C_AS[R4004];
  select many te_parms related by spr_pep->C_EP[R4501]->C_PP[R4006]->TE_PARM[R2048];
  r = ::FactoryTE_MACT( te_parms:te_parms, te_dt:void_te_dt, te_c:te_c, te_po:te_po, message_name:spr_ps.Name, description:c_as.Descrip, subtypeKL:"SPR_PS" );
  te_mact = r;
  te_mact.Direction = c_as.Direction;
  relate te_mact to spr_ps across R2051;
end for;
// All the te_pos and te_macts are created now.  Order the te_macts alphabetically inside the ports.
select many te_pos from instances of TE_PO;
for each te_po in te_pos
  select many te_macts related by te_po->TE_MACT[R2006];
  ::mact_sort( te_macts:te_macts );
end for;
//
//
// Create the generated links (associations) and connect them.
select many r_rels from instances of R_REL;
for each r_rel in r_rels
  create object instance te_rel of TE_REL;
  te_rel.Numb = r_rel.Numb;
  if ( te_sys.InstanceLoading )
    te_rel.LinkNeeded = true;
  else
    te_rel.LinkNeeded = false;
  end if;
  te_rel.UnlinkNeeded = false;
  te_rel.Navigated = false;
  te_rel.Order = 0;
  te_rel.storage_needed = false;
  relate r_rel to te_rel across R2034;
end for;
//
// Create the navigations and connect them to the R_OIRs.
select many r_oirs from instances of R_OIR;
for each r_oir in r_oirs
  create object instance te_oir of TE_OIR;
  select one o_obj related by r_oir->O_OBJ[R201];
  select one r_rel related by r_oir->R_REL[R201];
  te_oir.data_member = ( o_obj.Key_Lett + "_R" ) + T::s(i:r_rel.Numb);
  te_oir.assoc_type = "";
  te_oir.Mult = 0;
  te_oir.object_id = "";
  te_oir.NavigatedTo = false;
  relate r_oir to te_oir across R2035;
end for;
select many r_parts related by r_rels->R_SIMP[R206]->R_PART[R207];
for each r_part in r_parts
  select one te_oir related by r_part->R_RTO[R204]->R_OIR[R203]->TE_OIR[R2035];
  te_oir.assoc_type = "part";
  te_oir.rel_phrase = T::underscore(s:r_part.Txt_Phrs);
  te_oir.Mult = r_part.Mult;
  if ( "" != te_oir.rel_phrase )
    te_oir.data_member = ( te_oir.data_member + "_" ) + te_oir.rel_phrase;
  end if;
end for;
select many r_forms from instances of R_FORM;
for each r_form in r_forms
  select one te_oir related by r_form->R_RGO[R205]->R_OIR[R203]->TE_OIR[R2035];
  te_oir.assoc_type = "form";
  te_oir.rel_phrase = T::underscore(s:r_form.Txt_Phrs);
  te_oir.Mult = r_form.Mult;
  if ( "" != te_oir.rel_phrase )
    te_oir.data_member = ( te_oir.data_member + "_" ) + te_oir.rel_phrase;
  end if;
end for;
select many r_aones from instances of R_AONE;
for each r_aone in r_aones
  select one te_oir related by r_aone->R_RTO[R204]->R_OIR[R203]->TE_OIR[R2035];
  te_oir.assoc_type = "aone";
  te_oir.rel_phrase = T::underscore(s:r_aone.Txt_Phrs);
  te_oir.Mult = r_aone.Mult;
  if ( "" != te_oir.rel_phrase )
    te_oir.data_member = ( te_oir.data_member + "_" ) + te_oir.rel_phrase;
  end if;
end for;
select many r_aoths from instances of R_AOTH;
for each r_aoth in r_aoths
  select one te_oir related by r_aoth->R_RTO[R204]->R_OIR[R203]->TE_OIR[R2035];
  te_oir.assoc_type = "aoth";
  te_oir.rel_phrase = T::underscore(s:r_aoth.Txt_Phrs);
  te_oir.Mult = r_aoth.Mult;
  if ( "" != te_oir.rel_phrase )
    te_oir.data_member = ( te_oir.data_member + "_" ) + te_oir.rel_phrase;
  end if;
end for;
select many r_assrs from instances of R_ASSR;
for each r_assr in r_assrs
  select one te_oir related by r_assr->R_RGO[R205]->R_OIR[R203]->TE_OIR[R2035];
  te_oir.assoc_type = "assr";
  te_oir.Mult = r_assr.Mult;
end for;
select many r_subs from instances of R_SUB;
for each r_sub in r_subs
  select one te_oir related by r_sub->R_RGO[R205]->R_OIR[R203]->TE_OIR[R2035];
  select one r_rel related by r_sub->R_SUBSUP[R213]->R_REL[R206];
  te_oir.assoc_type = "subsuper";
  te_oir.object_id = ( "R" + T::s(i:r_rel.Numb) ) + "_object_id";
  te_oir.data_member = ( "R" + T::s(i:r_rel.Numb) ) + "_subtype";
end for;
select many r_supers from instances of R_SUPER;
for each r_super in r_supers
  select one te_oir related by r_super->R_RTO[R204]->R_OIR[R203]->TE_OIR[R2035];
  te_oir.assoc_type = "subsuper";
end for;
//
// Create the blocks and connect them to the ACT_BLKs.
select many act_blks from instances of ACT_BLK;
for each act_blk in act_blks
  create object instance te_blk of TE_BLK;
  relate act_blk to te_blk across R2016;
  te_blk.OAL = "";
  te_blk.declaration = "";
  te_blk.initialization = "";
  te_blk.deallocation = "";
  te_blk.code = "";
  te_blk.depth = 1;
  first_smt = true;
  // Create the statements and connect them to the ACT_SMTs.
  select many act_smts related by act_blk->ACT_SMT[R602];
  for each act_smt in act_smts
    create object instance te_smt of TE_SMT;
    relate act_smt to te_smt across R2038;
    // Connect the statement to its parent block.
    relate te_smt to te_blk across R2078;
    if ( first_smt )
      // CDS WARNING!! This assumes the gen_erate will give us the first statement first!
      relate te_blk to te_smt across R2014;
      first_smt = false;
    else
          end if;
    te_smt.OAL = "";
    te_smt.declaration = "";
    te_smt.initialization = "";
    te_smt.deallocation = "";
    te_smt.buffer = "";
    te_smt.buffer2 = "";
    te_smt.trace = "";
          end for;
  // Link the te_smts into order like the act_smts.
  for each act_smt in act_smts
    select one te_smt related by act_smt->TE_SMT[R2038];
    select one next_act_smt related by act_smt->ACT_SMT[R661.''succeeds''];
    if ( not_empty next_act_smt )
      select one next_te_smt related by next_act_smt->TE_SMT[R2038];
      relate te_smt to next_te_smt across R2012.''succeeds'';
    end if;
  end for;
end for;
//
// Connect up statements and blocks in the extended subsystem.
// We want statements to know:
// 1) containing block
// 2) sub-block
// [for, while, if, elif and else statements have sub-blocks.]
select many act_fors from instances of ACT_FOR;
for each act_for in act_fors
  select one te_smt related by act_for->ACT_SMT[R603]->TE_SMT[R2038];
  select one te_blk related by act_for->ACT_BLK[R605]->TE_BLK[R2016];
  relate te_smt to te_blk across R2015;
  te_smt.subtypeKL = "TE_FOR";
end for;
select many act_whls from instances of ACT_WHL;
for each act_whl in act_whls
  select one te_smt related by act_whl->ACT_SMT[R603]->TE_SMT[R2038];
  select one te_blk related by act_whl->ACT_BLK[R608]->TE_BLK[R2016];
  relate te_smt to te_blk across R2015;
  te_smt.subtypeKL = "TE_WHL";
end for;
select many act_ifs from instances of ACT_IF;
for each act_if in act_ifs
  select one te_smt related by act_if->ACT_SMT[R603]->TE_SMT[R2038];
  select one te_blk related by act_if->ACT_BLK[R607]->TE_BLK[R2016];
  relate te_smt to te_blk across R2015;
  te_smt.subtypeKL = "TE_IF";
end for;
select many act_els from instances of ACT_EL;
for each act_el in act_els
  select one te_smt related by act_el->ACT_SMT[R603]->TE_SMT[R2038];
  select one te_blk related by act_el->ACT_BLK[R658]->TE_BLK[R2016];
  relate te_smt to te_blk across R2015;
  te_smt.subtypeKL = "TE_EL";
end for;
select many act_es from instances of ACT_E;
for each act_e in act_es
  select one te_smt related by act_e->ACT_SMT[R603]->TE_SMT[R2038];
  select one te_blk related by act_e->ACT_BLK[R606]->TE_BLK[R2016];
  relate te_smt to te_blk across R2015;
  te_smt.subtypeKL = "TE_E";
end for;
// Calculate the block depth to be used for indentation.
select many te_blks from instances of TE_BLK;
for each te_blk in te_blks
  select one parent_te_blk related by te_blk->TE_SMT[R2015]->TE_BLK[R2078];
  while ( not_empty parent_te_blk )
    te_blk.depth = te_blk.depth + 1;
    select one parent_te_blk related by parent_te_blk->TE_SMT[R2015]->TE_BLK[R2078];
  end while;
  r = ::blk_indentwhitespace( indentation:te_blk.depth );
  te_blk.indentation = r;
end for;
//
// Create the generated chain links and connect them to the ACT_LNKs.
select many act_lnks from instances of ACT_LNK;
for each act_lnk in act_lnks
  ::FactoryTE_LNK( act_lnk:act_lnk );
end for;
// Link the chain links together in extensions as in meta-model proper.
select many te_lnks from instances of TE_LNK;
for each te_lnk in te_lnks
  select one act_lnk related by te_lnk->ACT_LNK[R2042];
  select one next_act_lnk related by act_lnk->ACT_LNK[R604.''succeeds''];
  if ( not_empty next_act_lnk )
    select one next_te_lnk related by next_act_lnk->TE_LNK[R2042];
    relate te_lnk to next_te_lnk across R2075.''succeeds'';
    // We populate this here.  Populate firsts during statement linkage.
    next_te_lnk.left = te_lnk.linkage;
    // We may have traversed directly from aoth to aone (or vice versa)
    // across an associative association.  If so, insert the associative
    // link between the two ends to enable the traversal.
    r = ::detect_and_insert_associator_TE_LNK( te_lnk:te_lnk, next_te_lnk:next_te_lnk, act_lnk:act_lnk, next_act_lnk:next_act_lnk, start_o_obj:empty_o_obj );
    discard = r;
  else
    // We can detect the end of the chain here.
    // We will detect the beginning during statement linkage.
    if ( not_empty te_lnk )
      te_lnk.last = true;
    end if;
  end if;
end for;
//
// Create the variables and connect them to the V_VAR.
select many v_vars from instances of V_VAR;
for each v_var in v_vars
  create object instance te_var of TE_VAR;
  relate v_var to te_var across R2039;
  if ( T::l(s:v_var.Name) == "self" )
    te_var.OAL = "self";
    te_var.buffer = te_instance.self;
  else
    te_var.OAL = v_var.Name;
    te_var.buffer = T::underscore(s:v_var.Name);
    if ( "SystemC" == te_target.language )
      // This prepends characters to transients in case the modeler used a C keyword.
      te_var.buffer = "v_" + te_var.buffer;
    end if;
  end if;
  array_spec = "";
  select many s_dims related by v_var->S_DIM[R849];
  te_var.dimensions = cardinality s_dims;
  te_dim = empty_te_dim;
  dim_index = 0;
  while ( dim_index < te_var.dimensions )
    select any s_dim related by v_var->S_DIM[R849] where ( selected.dimensionCount == dim_index );
    r = ::FactoryTE_DIM( s_dim:s_dim, predecessor_te_dim:te_dim );
    te_dim = r;
    if ( dim_index == 0 )
      relate te_dim to te_var across R2057;
    end if;
    array_spec = ( array_spec + "[" ) + ( T::s(i:te_dim.elementCount) + "]" );
    dim_index = dim_index + 1;
  end while;
  te_var.array_spec = array_spec;
  select one te_dt related by v_var->S_DT[R848]->TE_DT[R2021];
  if ( not_empty te_dt )
    // In the C model compiler, treat strings as arrays.
    if ( 4 == te_dt.Core_Typ )
      // string
      te_var.dimensions = te_var.dimensions + 1;
      te_var.array_spec = ( te_var.array_spec + "[" ) + ( te_string.max_string_length + "]" );
    end if;
  else
    //T::print(s:"\nERROR:  Did not find a datatype associated with variable ""T::s(i:v_var.Name)"".");
    //T::print(s:"Check usages of ""T::s(i:v_var.Name)"" for parse errors in the action language.");
    T::print(s:"[Parse All Activies and look for errors in the Problems view.]\n");
  end if;
end for;
//
//
//
// Continue initializing the components created and linked above.
// Recurse down into the component-level artifacts.
select many te_cs from instances of TE_C where ( selected.included_in_build );
for each te_c in te_cs
  // Initialize the te_sync instances.
  select many te_syncs related by te_c->TE_SYNC[R2084];
  for each te_sync in te_syncs
    select one s_sync related by te_sync->S_SYNC[R2023];
    te_sync.Included = false;
    te_sync.IsInitFunction = false;
    te_sync.IsSafeForInterrupts = false;
    te_sync.XlateSemantics = true;
    te_sync.deferred_method = te_sync.GeneratedName + "_deferred";
    select any tm_sync from instances of TM_SYNC where ( ( selected.RegisteredDomain == te_c.Name ) and ( selected.Name == te_sync.Name ) );
    if ( not_empty tm_sync )
      te_sync.IsSafeForInterrupts = tm_sync.IsSafeForInterrupts;
      select one rval_dt related by s_sync->S_DT[R25];
      if ( rval_dt.Name != "void" )
        T::print(s:"ERROR:  Function T::s(i:te_sync.Name) in T::s(i:te_c.Name)");
        T::print(s:"is trying to return data.  Functions marked as safe for");
        T::print(s:"interrupt invocation cannot return data.  They must be");
        T::print(s:"of return type void.");
        T::print(s:"Change the return type of the function or do not mark");
        T::print(s:"it as SafeForInterrupts.");
        T::exit(i:100);
      end if;
    end if;
    if ( te_sync.IsSafeForInterrupts )
      te_sync.intraface_method = te_sync.GeneratedName + "_sync";
    else
      te_sync.intraface_method = te_sync.GeneratedName;
    end if;
    select one te_dt related by s_sync->S_DT[R25]->TE_DT[R2021];
    select many te_parms related by s_sync->S_SPARM[R24]->TE_PARM[R2030];
    r = ::FactoryTE_ABA( te_c:te_c, te_parms:te_parms, scope:te_c.Name, name:te_sync.GeneratedName, subtypeKL:"S_SYNC", te_dt:te_dt );
    te_aba = r;
    relate te_sync to te_aba across R2010;
  end for;
  //
  // Create the Generated External Entity instances and link them in.
  select many te_ees related by te_c->TE_EE[R2085];
  for each te_ee in te_ees
    ::TE_EE_init( te_ee:te_ee, te_c:te_c );
  end for;
  //
  // Initialize the Generated Class instances.
  select many te_classs related by te_c->TE_CLASS[R2064];
  for each te_class in te_classs
    select one o_obj related by te_class->O_OBJ[R2019];
    // Initialize model compiler extension attributes.
    te_class.SelfCreated = false;
    te_class.NonSelfCreated = false;
    te_class.Included = false;
    te_class.IsFixedPopulation = false;
    te_class.PEIsDefinedInData = false;
    te_class.IsReadOnly = false;
    // Default is 10 instances per class.
    te_class.MaxExtentSize = 10;
    te_class.Persistent = false;
    te_class.ExcludeFromGen = false;
    te_class.IsTrace = true;
    te_class.ContainerIndex = 0;
    te_class.Task = 0;
    te_class.class_file = te_class.GeneratedName + "_class";
    te_class.system_class_number = te_class.GeneratedName + "_CLASS_NUMBER";
    te_class.CBsystem_class_number = te_class.GeneratedName + "_CLASS_NUMBER_CB";
    te_class.dispatcher = "";
    te_class.CBdispatcher = "";
    select one sm_ism related by o_obj->SM_ISM[R518];
    if ( not_empty sm_ism )
      te_class.dispatcher = te_class.GeneratedName + "_Dispatch";
    end if;
    select one sm_asm related by o_obj->SM_ASM[R519];
    if ( not_empty sm_asm )
      te_class.CBdispatcher = te_class.GeneratedName + "_CBDispatch";
    end if;
    te_class.persist_link = te_class.GeneratedName + "_LinkCentral";
    //
    // Create the Generated Attribute instances and link them to the real ones.
    delimiter = "";
    prev_te_attr = empty_te_attr;
    // Find first o_attr.
    select any o_attr related by o_obj->O_ATTR[R102];
    while ( not_empty o_attr )
      select one prev_o_attr related by o_attr->O_ATTR[R103.''precedes''];
      if ( empty prev_o_attr )
        break;
      end if;
      o_attr = prev_o_attr;
    end while;
    while ( not_empty o_attr )
      create object instance te_attr of TE_ATTR;
      te_attr.Name = o_attr.Name;
      te_attr.GeneratedName = T::r(s:o_attr.Name);
      te_attr.DefaultValue = o_attr.DefaultValue;
      te_attr.Used = false;
      te_attr.read = false;
      te_attr.written = false;
      te_attr.Included = false;
      te_attr.Order = 0;
      te_attr.ParamBuffer = "";
      te_attr.translate = true;
      relate te_attr to o_attr across R2033;
      relate te_attr to te_class across R2061;
            if ( not_empty prev_te_attr )
        relate te_attr to prev_te_attr across R2087.''succeeds'';
      end if;
      select many s_dims related by o_attr->S_DIM[R120];
      array_spec = "";
      te_attr.dimensions = cardinality s_dims;
      te_dim = empty_te_dim;
      dim_index = 0;
      while ( dim_index < te_attr.dimensions )
        select any s_dim related by o_attr->S_DIM[R120] where ( selected.dimensionCount == dim_index );
        r = ::FactoryTE_DIM( s_dim:s_dim, predecessor_te_dim:te_dim );
        te_dim = r;
        if ( dim_index == 0 )
          relate te_dim to te_attr across R2055;
        end if;
        array_spec = ( array_spec + "[" ) + ( T::s(i:te_dim.elementCount) + "]" );
        dim_index = dim_index + 1;
      end while;
      te_attr.array_spec = array_spec;
      select one te_dt related by o_attr->S_DT[R114]->TE_DT[R2021];
      // Potentially substitute data type for base attribute data type.
      if ( 7 == te_dt.Core_Typ )
        // referential attribute
        r = ::GetAttributeCodeGenType( o_attr:o_attr );
        te_dt = r;
      end if;
      te_attr.GeneratedType = te_dt.ExtName;
      o_attr_Descrip_Persistent = T::parsekeyword(s:o_attr.Descrip,key:"Persistent");
      if ( o_attr_Descrip_Persistent != "false" )
        if ( "%p" == te_dt.string_format )
          te_class.attribute_format = ( te_class.attribute_format + delimiter ) + "%ld";
          te_class.attribute_dump = ( te_class.attribute_dump + ",\n    (long)self->" ) + te_attr.GeneratedName;
        else
          te_class.attribute_format = ( te_class.attribute_format + delimiter ) + te_dt.string_format;
          te_class.attribute_dump = ( te_class.attribute_dump + ",\n    self->" ) + te_attr.GeneratedName;
        end if;
      end if;
      // In the C model compiler, treat strings as arrays.
      if ( 4 == te_dt.Core_Typ )
        // string
        te_attr.dimensions = te_attr.dimensions + 1;
        te_attr.array_spec = ( te_attr.array_spec + "[" ) + ( te_string.max_string_length + "]" );
      end if;
      //
      // Create the Action Block Anchors associated with each action
      // in the user model.  Initialize and link them.
      // Create and link the Generated versions of each of the action homes.
      select one o_dbattr related by o_attr->O_BATTR[R106]->O_DBATTR[R107];
      if ( not_empty o_dbattr )
        create object instance te_dbattr of TE_DBATTR;
        te_dbattr.Included = false;
        te_dbattr.GeneratedName = ( te_class.GeneratedName + "_MDA_" ) + o_attr.Name;
        relate o_dbattr to te_dbattr across R2026;
        select one te_dt related by o_attr->S_DT[R114]->TE_DT[R2021];
        te_parms = empty_te_parms;
        r = ::FactoryTE_ABA( te_c:te_c, te_parms:te_parms, scope:"", name:te_dbattr.GeneratedName, subtypeKL:"O_DBATTR", te_dt:te_dt );
        te_aba = r;
        relate te_dbattr to te_aba across R2010;
      end if;
      delimiter = ",";
      prev_te_attr = te_attr;
      select one o_attr related by o_attr->O_ATTR[R103.''succeeds''];
    end while;
    //
    // Create the Generated State Machines and connect them to SM_SM.
    select one sm_sm related by o_obj->SM_ISM[R518]->SM_SM[R517];
    if ( not_empty sm_sm )
      ::FactoryTE_SM( is_ism:true, sm_sm:sm_sm, te_class:te_class );
    end if;
    select one sm_sm related by o_obj->SM_ASM[R519]->SM_SM[R517];
    if ( not_empty sm_sm )
      ::FactoryTE_SM( is_ism:false, sm_sm:sm_sm, te_class:te_class );
    end if;
    //
    // Create and relate the generated class operations.
    select many o_tfrs related by o_obj->O_TFR[R115];
    for each o_tfr in o_tfrs
      create object instance te_tfr of TE_TFR;
      te_tfr.Included = false;
      te_tfr.XlateSemantics = true;
      ib = Scope::Instance;
      if ( ib == o_tfr.Instance_Based )
        te_tfr.Instance_Based = 1;
      else
        te_tfr.Instance_Based = 0;
      end if;
      te_tfr.Key_Lett = te_class.Key_Lett;
      te_tfr.Name = o_tfr.Name;
      te_tfr.GeneratedName = ( ( te_c.Name + "_" ) + ( te_tfr.Key_Lett + "_op_" ) ) + te_tfr.Name;
      relate o_tfr to te_tfr across R2024;
      select one te_dt related by o_tfr->S_DT[R116]->TE_DT[R2021];
      select many te_parms related by o_tfr->O_TPARM[R117]->TE_PARM[R2029];
      r = ::FactoryTE_ABA( te_c:te_c, te_parms:te_parms, scope:te_class.GeneratedName, name:te_tfr.GeneratedName, subtypeKL:"O_TFR", te_dt:te_dt );
      te_aba = r;
      relate te_tfr to te_aba across R2010;
    end for;
    //
    // Create the WhereKey instance connected to O_ID.
    select many o_ids related by o_obj->O_ID[R104];
    for each o_id in o_ids
      create object instance te_where of TE_WHERE;
      te_where.WhereKey = false;
      relate te_where to o_id across R2032;
      number = te_where.Oid_ID + 1;
      te_where.select_any_where = ( te_class.GeneratedName + "_AnyWhere" ) + T::s(i:number);
    end for;
  end for;
end for;
//
select many te_ees from instances of TE_EE;
for each te_ee in te_ees
  select one te_c related by te_ee->TE_C[R2085];
  if ( empty te_c )
    ::TE_EE_init( te_ee:te_ee, te_c:empty_te_c );
  end if;
end for;
//
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("073e63d8-578b-445c-ad2f-06ae0d3649d8",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("883a7c30-f27b-4c19-b9b0-5147ce0fb647",
	"00000000-0000-0000-0000-000000000000",
	'FactoryTE_CLASS',
	'',
	'//
//
//============================================================================
// New and return instance of TE_CLASS.
//============================================================================
o_obj = param.o_obj;
te_c = param.te_c;
// Create the Generated Class instance and link it to the model one.
create object instance te_class of TE_CLASS;
relate te_class to o_obj across R2019;
relate te_class to te_c across R2064;
// Copy the Numb attribute for sorting purposes.
te_class.Numb = o_obj.Numb;
// Copy other attributes for convenience so we can avoid accessing o_obj.
te_class.Name = o_obj.Name;
te_class.Key_Lett = o_obj.Key_Lett;
te_class.Key_Lett = T::r(s:te_class.Key_Lett);
// Initialize model compiler extension attributes.
te_class.GeneratedName = ( te_c.Name + "_" ) + te_class.Key_Lett;
te_class.CBGeneratedName = te_class.GeneratedName + "_CB";
return te_class;
',
	"f975acb7-4246-4a87-9c5a-75481f096785",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("a76afaac-e48c-4267-8083-0ab7450546a0",
	"883a7c30-f27b-4c19-b9b0-5147ce0fb647",
	'o_obj',
	"d6b21eeb-39da-43bf-b503-c7bbc9ddf242",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("d6b21eeb-39da-43bf-b503-c7bbc9ddf242",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Model Class>',
	'',
	'',
	'../Instance Reference Data Types/Instance Reference Data Types.xtuml');
INSERT INTO S_SPARM
	VALUES ("796aa802-2da8-43ca-bc1b-09e93187c578",
	"883a7c30-f27b-4c19-b9b0-5147ce0fb647",
	'te_c',
	"af13e9b7-f940-4a62-b6da-d8fb321a8a39",
	0,
	'',
	"a76afaac-e48c-4267-8083-0ab7450546a0",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("af13e9b7-f940-4a62-b6da-d8fb321a8a39",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Component>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("883a7c30-f27b-4c19-b9b0-5147ce0fb647",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_DT_PROXY
	VALUES ("f975acb7-4246-4a87-9c5a-75481f096785",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Class>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO S_SYNC
	VALUES ("2fac406c-1e4f-4586-8b9a-6b679296a0bb",
	"00000000-0000-0000-0000-000000000000",
	'FactoryTE_DIM',
	'',
	'//
//
//============================================================================
// New and return instance of TE_DIM.
//============================================================================
s_dim = param.s_dim;
predecessor_te_dim = param.predecessor_te_dim;
create object instance te_dim of TE_DIM;
te_dim.elementCount = s_dim.elementCount;
if ( 0 == te_dim.elementCount )
  // Here we have a VLA (variable length array).
  // Add support here.
end if;
te_dim.dimensionCount = s_dim.dimensionCount;
if ( not_empty predecessor_te_dim )
  relate te_dim to predecessor_te_dim across R2060.''succeeds'';
end if;
return te_dim;
',
	"c0718fda-c6da-4d8b-99f8-c17ffd14b6b0",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("22e1bec7-6dd2-4126-8659-d1b5d99666fe",
	"2fac406c-1e4f-4586-8b9a-6b679296a0bb",
	's_dim',
	"15158ac6-71a4-4ce8-8756-ebf92d171d09",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("15158ac6-71a4-4ce8-8756-ebf92d171d09",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Dimensions>',
	'',
	'',
	'../Domain/Domain.xtuml');
INSERT INTO S_SPARM
	VALUES ("33c6d497-d1ee-4e69-9e38-ebb2b1c0ae2d",
	"2fac406c-1e4f-4586-8b9a-6b679296a0bb",
	'predecessor_te_dim',
	"c0718fda-c6da-4d8b-99f8-c17ffd14b6b0",
	0,
	'',
	"22e1bec7-6dd2-4126-8659-d1b5d99666fe",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("c0718fda-c6da-4d8b-99f8-c17ffd14b6b0",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Dimension>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("2fac406c-1e4f-4586-8b9a-6b679296a0bb",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("0bbf96d3-1cb0-4d01-a0c4-6e0225ab3def",
	"00000000-0000-0000-0000-000000000000",
	'FactoryTE_SM',
	'',
	'//
//
//============================================================================
// New and link state machine instances.
// Allocate and link state instances (in numerically sorted order).
//============================================================================
is_ism = param.is_ism;
sm_sm = param.sm_sm;
te_class = param.te_class;
select any void_te_dt from instances of TE_DT where ( selected.Core_Typ == 0 );
select many empty_te_parms from instances of TE_PARM where ( false );
select one te_c related by te_class->TE_C[R2064];
create object instance te_sm of TE_SM;
relate te_sm to te_class across R2072;
relate te_sm to sm_sm across R2043;
te_sm.complete = false;
class_based = "_CB";
if ( is_ism )
  class_based = "";
end if;
te_sm.SEMname = ( te_class.GeneratedName + class_based ) + "_StateEventMatrix";
te_sm.state_names_array = ( "state_name_strings" + class_based );
te_sm.action_array = ( te_class.GeneratedName + class_based ) + "_acts";
te_sm.txn_action_array = ( te_class.GeneratedName + class_based ) + "_xacts";
te_sm.action_type = "StateAction_t";
te_sm.events_union = ( te_class.GeneratedName + class_based ) + "_Events_u";
//
// Create the Generated States and connect them to SM_STATE.
select many sm_states related by sm_sm->SM_STATE[R501];
te_sm.num_states = cardinality sm_states;
for each sm_state in sm_states
  create object instance te_state of TE_STATE;
  te_state.Name = sm_state.Name;
  te_state.Numb = sm_state.Numb;
  relate te_state to sm_state across R2037;
  te_state.enumerator = ( te_class.GeneratedName + class_based ) + ( "_STATE_" + T::s(i:te_state.Numb) );
  //
  // Create the Extended Actions (TE_ACT) and connect them to SM_ACT.
  select one sm_act related by sm_state->SM_MOAH[R511]->SM_AH[R513]->SM_ACT[R514];
  create object instance te_act of TE_ACT;
  relate sm_act to te_act across R2022;
  te_act.GeneratedName = ( te_class.GeneratedName + class_based ) + ( "_act" + T::s(i:te_state.Numb) );
  //.select many te_parms related by sm_state->SM_SEME[R503]->SM_SEVT[R503]->SM_EVT[R525]->SM_EVTDI[R532]->TE_PARM[R2031]
  r = ::FactoryTE_ABA( te_c:te_c, te_parms:empty_te_parms, scope:"", name:te_act.GeneratedName, subtypeKL:"SM_ACT", te_dt:void_te_dt );
  te_aba = r;
  relate te_act to te_aba across R2010;
end for;
//
// Sort the states for later state event matrix generation.
select many te_states related by sm_states->TE_STATE[R2037];
//   Sort the instances in the instance set <item_set> in ascending numeric
// order, based on the value of the Numb (integer) attribute value of
// each instance. The Order (integer) attribute value of each instance will
// be set to contain a value relative to Numb, indicating the position
// the instance has in the ordered set.
//   This function is definately *slow*, but will work with any objects
// which contain integer attributes <Numb> and <Order>.
item_set = te_states;
//
// Clear the Order attribute of all set members.
for each item in item_set
  item.Order = 0;
end for;
// simple pseudo bubble sort
item_set_copy = item_set;
for each item in item_set
  for each item_copy in item_set_copy
    if ( item_copy.Numb > item.Numb )
      item_copy.Order = item_copy.Order + 1;
    end if;
  end for;
end for;
for each te_state in te_states
  te_state.number = te_state.Order + 1;
  if ( 0 == te_state.Order )
    te_sm.initial_state = te_state.enumerator;
  end if;
end for;
//
// Create the actions for the transitions.
counter = 1;
// This is the hairiest traversal we do.  We are finding actions
// that actually have action language.
select many sm_acts related by sm_sm->SM_TXN[R505]->SM_TAH[R530]->SM_AH[R513]->SM_ACT[R514]->ACT_TAB[R688]->ACT_ACT[R698]->ACT_BLK[R666]->ACT_SMT[R602]->ACT_BLK[R602]->ACT_ACT[R666]->ACT_TAB[R698]->SM_ACT[R688];
for each sm_act in sm_acts
  // Create the Extended Actions (TE_ACT) and connect them to SM_ACT.
  create object instance te_act of TE_ACT;
  relate sm_act to te_act across R2022;
  te_act.GeneratedName = ( te_class.GeneratedName + class_based ) + ( "_xact" + T::s(i:counter) );
  te_act.number = counter;
  //.select many te_parms related by sm_act->SM_AH[R514]->SM_TAH[R513]->SM_TXN[R530]->SM_NSTXN[R507]->SM_SEME[R504]->SM_SEVT[R503]->SM_EVT[R525]->SM_EVTDI[R532]->TE_PARM[R2031]
  r = ::FactoryTE_ABA( te_c:te_c, te_parms:empty_te_parms, scope:"", name:te_act.GeneratedName, subtypeKL:"SM_ACT", te_dt:void_te_dt );
  te_aba = r;
  relate te_act to te_aba across R2010;
  counter = counter + 1;
end for;
te_sm.txn_action_count = counter - 1;
//
// Create the Generated Events and connect them to SM_EVT.
select many sm_evts related by sm_sm->SM_EVT[R502];
te_sm.num_events = cardinality sm_evts;
for each sm_evt in sm_evts
  create object instance te_evt of TE_EVT;
  relate te_evt to te_sm across R2071;
  te_evt.Name = sm_evt.Mning;
  te_evt.Numb = sm_evt.Numb;
  te_evt.Order = 0;
  te_evt.Used = false;
  te_evt.UsedCount = 0;
  te_evt.Priority = 0;
  relate te_evt to sm_evt across R2036;
  suffix = T::s(i:te_evt.Numb);
  select one sm_nlevt related by sm_evt->SM_SEVT[R525]->SM_NLEVT[R526];
  if ( not_empty sm_nlevt )
    // Non local event defined by a polymorphic event
    select one super_sm_evt related by sm_nlevt->SM_PEVT[R527]->SM_EVT[R525];
    select one super_obj related by super_sm_evt->SM_SM[R502]->SM_ISM[R517]->O_OBJ[R518];
    suffix = ( "_" + T::r(s:super_obj.Key_Lett) ) + ( "_PE" + T::s(i:super_sm_evt.Numb) );
  end if;
  te_evt.GeneratedName = ( te_class.GeneratedName + class_based ) + ( "event" + suffix );
  te_evt.Enumerator = T::u(s:te_evt.GeneratedName) + "NUM";
end for;
// Select the local events (only in this state machine), the "true" events
// (land here but also seen as polys) and polymorphic events.  Order the
// events starting with local then true then polys.
select many sm_levts related by sm_sm->SM_EVT[R502]->SM_SEVT[R525]->SM_LEVT[R526];
select many local_te_evts related by sm_levts->SM_SEVT[R526]->SM_EVT[R525]->TE_EVT[R2036];
//   Sort the instances in the instance set <item_set> in ascending numeric
// order, based on the value of the Numb (integer) attribute value of
// each instance. The Order (integer) attribute value of each instance will
// be set to contain a value relative to Numb, indicating the position
// the instance has in the ordered set.
//   This function is definately *slow*, but will work with any objects
// which contain integer attributes <Numb> and <Order>.
item_set1 = local_te_evts;
//
// Clear the Order attribute of all set members.
for each item1 in item_set1
  item1.Order = 0;
end for;
// simple pseudo bubble sort
item_set1_copy = item_set1;
for each item1 in item_set1
  for each item1_copy in item_set1_copy
    if ( item1_copy.Numb > item1.Numb )
      item1_copy.Order = item1_copy.Order + 1;
    end if;
  end for;
end for;
last_event_number = cardinality local_te_evts;
last_event_number = last_event_number - 1;
select many sm_sgevts related by sm_sm->SM_EVT[R502]->SM_SEVT[R525]->SM_SGEVT[R526];
select many signal_te_evts related by sm_sgevts->SM_SEVT[R526]->SM_EVT[R525]->TE_EVT[R2036];
for each te_evt in signal_te_evts
  // Mark signals as used to be sure we get code.
  te_evt.Used = true;
  te_evt.UsedCount = 1;
  last_event_number = last_event_number + 1;
  te_evt.Order = last_event_number;
  // Link each signal te_mact to its associated signal te_evts.
  select one te_mact related by te_evt->SM_EVT[R2036]->SM_SEVT[R525]->SM_SGEVT[R526]->SPR_PS[R528]->TE_MACT[R2051];
  if ( empty te_mact )
    select one te_mact related by te_evt->SM_EVT[R2036]->SM_SEVT[R525]->SM_SGEVT[R526]->SPR_RS[R529]->TE_MACT[R2053];
  end if;
  if ( not_empty te_mact )
    relate te_mact to te_evt across R2082;
  end if;
end for;
select many sm_nlevts related by sm_sm->SM_EVT[R502]->SM_SEVT[R525]->SM_NLEVT[R526];
select many true_te_evts related by sm_nlevts->SM_SEVT[R526]->SM_EVT[R525]->TE_EVT[R2036];
for each te_evt in true_te_evts
  // Mark polys and non-locals as used to be sure we get code.
  te_evt.Used = true;
  te_evt.UsedCount = 1;
  last_event_number = last_event_number + 1;
  te_evt.Order = last_event_number;
end for;
// Finally, order the polymorphic events.
// We need their Order to be greater than local and true events, since
// polys are not state event matrix events.
select many poly_te_evts related by sm_sm->SM_EVT[R502]->SM_PEVT[R525]->SM_EVT[R525]->TE_EVT[R2036];
for each te_evt in poly_te_evts
  // Mark polys and non-locals as used to be sure we get code.
  te_evt.Used = true;
  te_evt.UsedCount = 1;
  last_event_number = last_event_number + 1;
  te_evt.Order = last_event_number;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("176fc52c-796b-4e9c-abd5-7f95a7df7f46",
	"0bbf96d3-1cb0-4d01-a0c4-6e0225ab3def",
	'is_ism',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("30e01827-90e4-4b30-9879-c374d031fc60",
	"0bbf96d3-1cb0-4d01-a0c4-6e0225ab3def",
	'sm_sm',
	"bf37869c-96be-4535-a678-ac4311589cbb",
	0,
	'',
	"176fc52c-796b-4e9c-abd5-7f95a7df7f46",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("bf37869c-96be-4535-a678-ac4311589cbb",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<State Machine>',
	'',
	'',
	'../State Machine/State Machine.xtuml');
INSERT INTO S_SPARM
	VALUES ("b0c6f8a9-f628-443b-a8f3-0ce1a665962c",
	"0bbf96d3-1cb0-4d01-a0c4-6e0225ab3def",
	'te_class',
	"f975acb7-4246-4a87-9c5a-75481f096785",
	0,
	'',
	"30e01827-90e4-4b30-9879-c374d031fc60",
	'');
INSERT INTO PE_PE
	VALUES ("0bbf96d3-1cb0-4d01-a0c4-6e0225ab3def",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b0499dc8-ddfd-4507-8d8e-013cdf195427",
	"00000000-0000-0000-0000-000000000000",
	'FactoryTE_MACT',
	'',
	'//
//
//============================================================================
// New and link message actions.
//============================================================================
te_parms = param.te_parms;
te_dt = param.te_dt;
te_c = param.te_c;
te_po = param.te_po;
message_name = param.message_name;
description = param.description;
subtypeKL = param.subtypeKL;
select any te_file from instances of TE_FILE;
select any te_sys from instances of TE_SYS;
select any te_target from instances of TE_TARGET;
create object instance te_mact of TE_MACT;
relate te_mact to te_c across R2002;
relate te_mact to te_po across R2006;
// We cannot just look to see if this port is polymorphic, we have to go to the
// associated interface and see if any port tied to that interface is polymorphic.
// TODO - We would like to move this -up- and handle it when the ports are created,
//   perhaps use 2081 for the satisfaction.
select one c_i related by te_po->C_I[R2007];
select any te_po_poly related by c_i->TE_PO[R2007] where ( ( selected.Provision == te_po.Provision ) and selected.polymorphic );
if ( empty te_po_poly )
  te_mact.polymorphic = false;
else
  te_mact.polymorphic = true;
end if;
te_mact.Descrip = description;
te_mact.subtypeKL = subtypeKL;
te_mact.Provision = te_po.Provision;
te_mact.MessageName = message_name;
te_mact.InterfaceName = te_po.InterfaceName;
te_mact.PortName = te_po.GeneratedName;
te_mact.ComponentName = te_c.Name;
te_mact.GeneratedName = ( ( te_mact.ComponentName + "_" ) + ( te_mact.PortName + "_" ) ) + message_name;
if ( "SystemC" == te_target.language )
  te_mact.GeneratedName = ( te_mact.InterfaceName + "_" ) + message_name;
end if;
te_mact.GeneratedName = T::r(s:te_mact.GeneratedName);
te_mact.Name = te_mact.GeneratedName;
select any converted_bool_te_dt from instances of TE_DT where ( selected.Name == "integer" );
if ( ( "SystemC" == te_target.language ) and ( te_sys.SystemCPortsType == "TLM" ) )
  for each te_parm in te_parms
    // If we are using TLM ports, convert booleans to integers
    select one param_te_dt related by te_parm->TE_DT[R2049];
    if ( 1 == param_te_dt.Core_Typ )
      relate te_parm to converted_bool_te_dt across R2049;
    end if;
  end for;
end if;
if ( ( te_mact.polymorphic ) and ( "SystemC" == te_target.language ) )
  // If polymorphic, then add a parameter that we can use to distinguish 
  // which port the message came in through.
  select many s_dims from instances of S_DIM where ( false );
  select any portindex_te_dt from instances of TE_DT where ( selected.Name == "integer" );
  r = ::FactoryTE_PARM( s_dims:s_dims, te_dt:portindex_te_dt, prefix:"", name:"A00portindex", description:"architectural port selector", by_ref:0 );
  polymorphic_te_parm = r;
  for each te_parm in te_parms
    if ( 0 == te_parm.Order )
      relate polymorphic_te_parm to te_parm across R2041.''succeeds'';
    end if;
  end for;
  te_parms = te_parms;
end if;
r = ::FactoryTE_ABA( te_c:te_c, te_parms:te_parms, scope:te_mact.ComponentName, name:te_mact.GeneratedName, subtypeKL:"TE_MACT", te_dt:te_dt );
te_aba = r;
relate te_mact to te_aba across R2010;
return te_mact;
',
	"7268e543-f48e-4464-ba70-227deff22727",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("8c9c9fda-9c0c-4d9c-ad1d-d5725777f2d7",
	"b0499dc8-ddfd-4507-8d8e-013cdf195427",
	'te_parms',
	"954dc6bb-6e2a-47a5-aa3b-886723803133",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("c35c39d8-bff2-4d9f-a016-28be1dc881d6",
	"b0499dc8-ddfd-4507-8d8e-013cdf195427",
	'te_dt',
	"5b20f7fb-179b-4254-a8de-922a50a1225d",
	0,
	'',
	"8c9c9fda-9c0c-4d9c-ad1d-d5725777f2d7",
	'');
INSERT INTO S_SPARM
	VALUES ("90efc384-5514-4cb8-840c-ac4c5735af60",
	"b0499dc8-ddfd-4507-8d8e-013cdf195427",
	'te_c',
	"af13e9b7-f940-4a62-b6da-d8fb321a8a39",
	0,
	'',
	"c35c39d8-bff2-4d9f-a016-28be1dc881d6",
	'');
INSERT INTO S_SPARM
	VALUES ("cd78ba43-1da2-4198-a3af-c94c6a70845c",
	"b0499dc8-ddfd-4507-8d8e-013cdf195427",
	'te_po',
	"472879e3-2bbf-4ca8-9fd2-6077af1f409a",
	0,
	'',
	"90efc384-5514-4cb8-840c-ac4c5735af60",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("472879e3-2bbf-4ca8-9fd2-6077af1f409a",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Port>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO S_SPARM
	VALUES ("33b57a58-97b8-4b6e-a871-47a345e67548",
	"b0499dc8-ddfd-4507-8d8e-013cdf195427",
	'message_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"cd78ba43-1da2-4198-a3af-c94c6a70845c",
	'');
INSERT INTO S_SPARM
	VALUES ("53ff6b42-13b5-4da8-9026-914a9149a4a0",
	"b0499dc8-ddfd-4507-8d8e-013cdf195427",
	'description',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"33b57a58-97b8-4b6e-a871-47a345e67548",
	'');
INSERT INTO S_SPARM
	VALUES ("63adca33-0550-4609-b24c-c97d1407e119",
	"b0499dc8-ddfd-4507-8d8e-013cdf195427",
	'subtypeKL',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"53ff6b42-13b5-4da8-9026-914a9149a4a0",
	'');
INSERT INTO PE_PE
	VALUES ("b0499dc8-ddfd-4507-8d8e-013cdf195427",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_DT_PROXY
	VALUES ("7268e543-f48e-4464-ba70-227deff22727",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Message Action>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO S_SYNC
	VALUES ("5f57ee74-0513-432b-91e5-d6f36cd9b7e6",
	"00000000-0000-0000-0000-000000000000",
	'TE_EE_init',
	'',
	'//
//============================================================================
// Initialize instance of TE_EE.
//============================================================================
te_ee = param.te_ee;
te_c = param.te_c;
select any te_file from instances of TE_FILE;
select any te_target from instances of TE_TARGET;
component_scope = "";
if ( not_empty te_c )
  component_scope = te_c.Name + "_";
end if;
select one s_ee related by te_ee->S_EE[R2020];
// Default the registered name to be the key letters.
// Bridge wiring will override this default, but the default may
// allow the code to compile.
te_ee.Name = s_ee.Name;
te_ee.Descrip = s_ee.Descrip;
te_ee.Key_Lett = s_ee.Key_Lett;
te_ee.RegisteredName = component_scope + T::r(s:te_ee.Key_Lett);
te_ee.Included = false;
te_ee.Used = false;
te_ee.file = te_ee.RegisteredName + "_bridge";
// Leave alone if marked.
if ( "" == te_ee.Include_File )
  te_ee.Include_File = te_ee.file + ( "." + te_file.hdr_file_ext );
end if;
if ( "TIM" == s_ee.Key_Lett )
  // Time (TIM) EE
  te_ee.RegisteredName = "TIM";
  te_ee.Include_File = te_file.tim + ( "." + te_file.hdr_file_ext );
end if;
bridge_scope = "";
if ( "C" == te_target.language )
  bridge_scope = te_ee.RegisteredName + "_";
end if;
select many s_brgs related by s_ee->S_BRG[R19];
for each s_brg in s_brgs
  create object instance te_brg of TE_BRG;
  relate te_brg to s_brg across R2025;
  relate te_brg to te_ee across R2089;
  te_brg.EEkeyletters = s_ee.Key_Lett;
  te_brg.EEname = s_ee.Name;
  te_brg.Name = s_brg.Name;
  te_brg.GeneratedName = bridge_scope + s_brg.Name;
  select one te_dt related by s_brg->S_DT[R20]->TE_DT[R2021];
  select many te_parms related by s_brg->S_BPARM[R21]->TE_PARM[R2028];
  r = ::FactoryTE_ABA( te_c:te_c, te_parms:te_parms, scope:te_ee.RegisteredName, name:te_brg.GeneratedName, subtypeKL:"S_BRG", te_dt:te_dt );
  te_aba = r;
  relate te_brg to te_aba across R2010;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("3ce910f1-b85d-42ef-a0d6-4913aa41de9a",
	"5f57ee74-0513-432b-91e5-d6f36cd9b7e6",
	'te_ee',
	"0be55aee-8704-4315-87a2-36ca7fc72b22",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("0be55aee-8704-4315-87a2-36ca7fc72b22",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended External Entity>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO S_SPARM
	VALUES ("88edf24d-3caa-454e-81dd-a69cc9d33f4c",
	"5f57ee74-0513-432b-91e5-d6f36cd9b7e6",
	'te_c',
	"af13e9b7-f940-4a62-b6da-d8fb321a8a39",
	0,
	'',
	"3ce910f1-b85d-42ef-a0d6-4913aa41de9a",
	'');
INSERT INTO PE_PE
	VALUES ("5f57ee74-0513-432b-91e5-d6f36cd9b7e6",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("5770d14c-94be-458e-ac82-88d61d675776",
	"00000000-0000-0000-0000-000000000000",
	'FactoryTE_ABA',
	'',
	'//
//============================================================================
// New and return instance of TE_ABA.
//============================================================================
te_c = param.te_c;
te_parms = param.te_parms;
scope = param.scope;
name = param.name;
subtypeKL = param.subtypeKL;
te_dt = param.te_dt;
select any te_target from instances of TE_TARGET;
create object instance te_aba of TE_ABA;
te_aba.SelfEventCount = 0;
te_aba.NonSelfEventCount = 0;
te_aba.subtypeKL = subtypeKL;
if ( not_empty te_c )
  relate te_aba to te_c across R2088;
end if;
duplicates_needed = false;
for each te_parm in te_parms
  select one existing_te_aba related by te_parm->TE_ABA[R2062];
  if ( empty existing_te_aba )
    relate te_parm to te_aba across R2062;
  else
    duplicates_needed = true;
  end if;
end for;
// This duplication is needed because multiple ports can use the same
// interface.  It would be nice to explore a method to avoid duplicating
// the parameter instances.
if ( duplicates_needed )
  select many duplicate_te_parms related by te_aba->TE_PARM[R2062] where ( false );
  // Find first te_parm.
  for each te_parm in te_parms
    break;
  end for;
  while ( not_empty te_parm )
    select one prev_te_parm related by te_parm->TE_PARM[R2041.''precedes''];
    if ( empty prev_te_parm )
      break;
    else
      te_parm = prev_te_parm;
    end if;
  end while;
  select one prev_te_parm related by te_parm->TE_PARM[R2041.''precedes''] where ( false );
  while ( not_empty te_parm )
    r = ::TE_PARM_duplicate( te_parm:te_parm );
    duplicate_te_parm = r;
    duplicate_te_parms = duplicate_te_parms;
    relate duplicate_te_parm to te_aba across R2062;
    if ( not_empty prev_te_parm )
      relate prev_te_parm to duplicate_te_parm across R2041.''succeeds'';
    end if;
    prev_te_parm = duplicate_te_parm;
    select one te_parm related by te_parm->TE_PARM[R2041.''succeeds''];
  end while;
  te_parms = duplicate_te_parms;
end if;
::te_parm_RenderParameters( te_parms:te_parms, te_aba:te_aba );
te_aba.scope = "";
if ( ( "C++" == te_target.language ) or ( "SystemC" == te_target.language ) )
  te_aba.scope = scope + "::";
  if ( not_empty te_c )
    if ( ( "S_BRG" == te_aba.subtypeKL ) or ( "O_TFR" == te_aba.subtypeKL ) )
      if ( empty te_parms )
        te_aba.ParameterDefinition = ( "" + te_c.Name ) + " * thismodule";
        te_aba.ParameterDeclaration = ( "" + te_c.Name ) + " *";
      else
        te_aba.ParameterDefinition = ( ( "" + te_c.Name ) + ( " * thismodule," + te_aba.ParameterDefinition ) );
        te_aba.ParameterDeclaration = ( ( "" + te_c.Name ) + ( " *," + te_aba.ParameterDeclaration ) );
      end if;
    end if;
  end if;
end if;
te_aba.GeneratedName = name;
te_aba.ReturnDataType = te_dt.ExtName;
te_aba.dimensions = 0;
// In the C model compiler, treat strings as arrays.
if ( 4 == te_dt.Core_Typ )
  // string
  select any te_string from instances of TE_STRING;
  te_aba.dimensions = te_aba.dimensions + 1;
  te_aba.array_spec = ( te_aba.array_spec + "[" ) + ( te_string.max_string_length + "]" );
end if;
// Allow arrays (including strings) to be returned as pointers.
if ( te_aba.dimensions > 0 )
  te_aba.ReturnDataType = te_aba.ReturnDataType + " *";
end if;
return te_aba;
',
	"5fb4bb14-9533-4d0c-bec8-44e5e22fbbfd",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("3e847c58-f3c7-4ee9-beaa-caa4f1a7a9cb",
	"5770d14c-94be-458e-ac82-88d61d675776",
	'te_c',
	"af13e9b7-f940-4a62-b6da-d8fb321a8a39",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("408133c8-5dec-447e-923e-aa999d6f6ea7",
	"5770d14c-94be-458e-ac82-88d61d675776",
	'te_parms',
	"954dc6bb-6e2a-47a5-aa3b-886723803133",
	0,
	'',
	"3e847c58-f3c7-4ee9-beaa-caa4f1a7a9cb",
	'');
INSERT INTO S_SPARM
	VALUES ("eb09b929-4bd7-4be2-b13a-03659f84e648",
	"5770d14c-94be-458e-ac82-88d61d675776",
	'scope',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"408133c8-5dec-447e-923e-aa999d6f6ea7",
	'');
INSERT INTO S_SPARM
	VALUES ("e1a60be7-e036-4734-b5df-df122b86c738",
	"5770d14c-94be-458e-ac82-88d61d675776",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"eb09b929-4bd7-4be2-b13a-03659f84e648",
	'');
INSERT INTO S_SPARM
	VALUES ("2547b929-c782-48ac-8bba-61c7faccb57d",
	"5770d14c-94be-458e-ac82-88d61d675776",
	'subtypeKL',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"e1a60be7-e036-4734-b5df-df122b86c738",
	'');
INSERT INTO S_SPARM
	VALUES ("27e5f73c-b8b3-4fae-ac7f-af1743c6ac71",
	"5770d14c-94be-458e-ac82-88d61d675776",
	'te_dt',
	"5b20f7fb-179b-4254-a8de-922a50a1225d",
	0,
	'',
	"2547b929-c782-48ac-8bba-61c7faccb57d",
	'');
INSERT INTO PE_PE
	VALUES ("5770d14c-94be-458e-ac82-88d61d675776",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("46c35c8f-c324-40d3-a41b-c87b8b0f258b",
	"00000000-0000-0000-0000-000000000000",
	'FactoryTE_PARM',
	'',
	'//
//
//============================================================================
// New and link up extended parameter.
//============================================================================
s_dims = param.s_dims;
te_dt = param.te_dt;
prefix = param.prefix;
name = param.name;
description = param.description;
by_ref = param.by_ref;
create object instance te_parm of TE_PARM;
te_parm.Order = 0;
te_parm.ParamBuffer = "";
te_parm.OALParamBuffer = "";
te_parm.Name = T::r(s:name);
te_parm.Descrip = description;
te_parm.By_Ref = by_ref;
te_parm.GeneratedName = prefix + name;
relate te_parm to te_dt across R2049;
// Set up the array dimensions for the parameter.
te_parm.dimensions = cardinality s_dims;
array_spec = "";
select one te_dim related by te_parm->TE_DIM[R2056] where ( false );
dim_index = 0;
while ( dim_index < te_parm.dimensions )
  for each s_dim in s_dims
    if ( s_dim.dimensionCount == dim_index )
      r = ::FactoryTE_DIM( s_dim:s_dim, predecessor_te_dim:te_dim );
      te_dim = r;
      if ( dim_index == 0 )
        relate te_parm to te_dim across R2056;
      end if;
      array_spec = ( array_spec + "[" ) + ( T::s(i:te_dim.elementCount) + "]" );
    end if;
  end for;
  dim_index = dim_index + 1;
  te_parm.By_Ref = 0;
end while;
te_parm.array_spec = array_spec;
// In the C model compiler, treat strings as arrays.
if ( 4 == te_dt.Core_Typ )
  // string
  select any te_string from instances of TE_STRING;
  te_parm.dimensions = te_parm.dimensions + 1;
  te_parm.array_spec = ( te_parm.array_spec + "[" ) + ( te_string.max_string_length + "]" );
  // In C (and other languages) arrays are never values but references.
  te_parm.By_Ref = 0;
end if;
return te_parm;
',
	"c1ec5f30-73a6-4381-a1e9-87b18c00ec88",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("43f44366-ee3f-4151-bc37-6d43334bd245",
	"46c35c8f-c324-40d3-a41b-c87b8b0f258b",
	's_dims',
	"3a7c5808-2c8c-4c84-865f-70beb289afcd",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("3a7c5808-2c8c-4c84-865f-70beb289afcd",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Dimensions>',
	'',
	'',
	'../Domain/Domain.xtuml');
INSERT INTO S_SPARM
	VALUES ("f053060c-645c-46e5-b4d1-36335f5c7c61",
	"46c35c8f-c324-40d3-a41b-c87b8b0f258b",
	'te_dt',
	"5b20f7fb-179b-4254-a8de-922a50a1225d",
	0,
	'',
	"43f44366-ee3f-4151-bc37-6d43334bd245",
	'');
INSERT INTO S_SPARM
	VALUES ("87063283-495a-4696-8192-62c0db1cf08f",
	"46c35c8f-c324-40d3-a41b-c87b8b0f258b",
	'prefix',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"f053060c-645c-46e5-b4d1-36335f5c7c61",
	'');
INSERT INTO S_SPARM
	VALUES ("5101aba2-2a50-4277-a04e-3275ecdab3c0",
	"46c35c8f-c324-40d3-a41b-c87b8b0f258b",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"87063283-495a-4696-8192-62c0db1cf08f",
	'');
INSERT INTO S_SPARM
	VALUES ("89800ffd-0f51-4721-8e90-c23f445a0ba3",
	"46c35c8f-c324-40d3-a41b-c87b8b0f258b",
	'description',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"5101aba2-2a50-4277-a04e-3275ecdab3c0",
	'');
INSERT INTO S_SPARM
	VALUES ("f8231179-91d9-44df-8485-e409efc0e8bc",
	"46c35c8f-c324-40d3-a41b-c87b8b0f258b",
	'by_ref',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"89800ffd-0f51-4721-8e90-c23f445a0ba3",
	'');
INSERT INTO PE_PE
	VALUES ("46c35c8f-c324-40d3-a41b-c87b8b0f258b",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_DT_PROXY
	VALUES ("c1ec5f30-73a6-4381-a1e9-87b18c00ec88",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Parameter>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO S_SYNC
	VALUES ("f6369795-3df0-4a43-b69a-dc769c124403",
	"00000000-0000-0000-0000-000000000000",
	'TE_PARM_duplicate',
	'',
	'//
//============================================================================
// Duplicate (copy) an instance of TE_PARM.
//============================================================================
te_parm = param.te_parm;
create object instance duplicate_te_parm of TE_PARM;
duplicate_te_parm.Order = te_parm.Order;
duplicate_te_parm.ParamBuffer = te_parm.ParamBuffer;
duplicate_te_parm.OALParamBuffer = te_parm.OALParamBuffer;
duplicate_te_parm.Name = te_parm.Name;
duplicate_te_parm.Descrip = te_parm.Descrip;
duplicate_te_parm.By_Ref = te_parm.By_Ref;
duplicate_te_parm.GeneratedName = te_parm.GeneratedName;
select one te_dt related by te_parm->TE_DT[R2049];
relate duplicate_te_parm to te_dt across R2049;
duplicate_te_parm.dimensions = te_parm.dimensions;
select one te_dim related by te_parm->TE_DIM[R2056];
if ( not_empty te_dim )
  relate duplicate_te_parm to te_dim across R2056;
else
  end if;
duplicate_te_parm.array_spec = te_parm.array_spec;
return duplicate_te_parm;
',
	"c1ec5f30-73a6-4381-a1e9-87b18c00ec88",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("9f909383-2593-4cbc-bf31-f4100311532a",
	"f6369795-3df0-4a43-b69a-dc769c124403",
	'te_parm',
	"c1ec5f30-73a6-4381-a1e9-87b18c00ec88",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("f6369795-3df0-4a43-b69a-dc769c124403",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("54ce3a2e-1017-44a5-b225-1cb678e7fb1e",
	"00000000-0000-0000-0000-000000000000",
	'FactoryTE_LNK',
	'',
	'//
//============================================================================
// New and return instance of TE_LNK.
//============================================================================
act_lnk = param.act_lnk;
select one o_obj related by act_lnk->O_OBJ[R678];
select one te_class related by o_obj->TE_CLASS[R2019];
if ( not_empty te_class )
  create object instance te_lnk of TE_LNK;
  relate te_lnk to act_lnk across R2042;
  te_lnk.rel_phrase = act_lnk.Rel_Phrase;
    select one r_rel related by act_lnk->R_REL[R681];
  te_lnk.rel_number = r_rel.Numb;
  relate te_lnk to te_class across R2076;
  te_lnk.OAL = ( ( "->" + te_class.Key_Lett ) + ( "[R" + T::s(i:te_lnk.rel_number) ) );
  if ( "" != te_lnk.rel_phrase )
    te_lnk.OAL = ( te_lnk.OAL + "." ) + te_lnk.rel_phrase;
  end if;
  te_lnk.OAL = te_lnk.OAL + "]";
  te_lnk.iterator = "i" + te_lnk.linkage;
  te_lnk.first = false;
  te_lnk.last = false;
  rel_phrase = T::underscore(s:te_lnk.rel_phrase);
  select any te_oir related by r_rel->R_OIR[R201]->TE_OIR[R2035] where ( ( selected.Obj_ID == o_obj.Obj_ID ) and ( selected.rel_phrase == rel_phrase ) );
  if ( empty te_oir )
    select any te_oir related by r_rel->R_OIR[R201]->TE_OIR[R2035] where ( selected.Obj_ID == o_obj.Obj_ID );
  end if;
  te_lnk.linkage = te_oir.data_member;
  te_lnk.Mult = te_oir.Mult;
  te_lnk.assoc_type = te_oir.assoc_type;
  // Deal with associative reflexives.
  if ( "assr" == te_oir.assoc_type )
    r = ::is_reflexive( r_rel:r_rel );
    reflexive = r;
    if ( reflexive )
      select one r_aone related by r_rel->R_ASSOC[R206]->R_AONE[R209];
      select one r_aoth related by r_rel->R_ASSOC[R206]->R_AOTH[R210];
      if ( te_lnk.rel_phrase == r_aone.Txt_Phrs )
        te_lnk.Mult = r_aone.Mult;
      elif ( te_lnk.rel_phrase == r_aoth.Txt_Phrs )
        te_lnk.Mult = r_aoth.Mult;
      else
        T::print(s:"ERROR:  Unrecognized reflexive association:  RT::s(i:r_rel.Numb).");
        T::exit(i:13);
      end if;
      te_lnk.linkage = ( te_oir.data_member + "_" ) + rel_phrase;
    end if;
  end if;
end if;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("51856cdc-8146-4138-8bce-ee09a127ce05",
	"54ce3a2e-1017-44a5-b225-1cb678e7fb1e",
	'act_lnk',
	"44344236-6d4d-42b5-b14f-246447643355",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("44344236-6d4d-42b5-b14f-246447643355",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Chain Link>',
	'',
	'',
	'../Selection/Selection.xtuml');
INSERT INTO PE_PE
	VALUES ("54ce3a2e-1017-44a5-b225-1cb678e7fb1e",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("526a830a-40e6-4dbf-a1d4-4ef76e23a5f9",
	"00000000-0000-0000-0000-000000000000",
	'associator_TE_LNK',
	'',
	'//
//============================================================================
// Create and insert a new TE_LNK between these two (for associator).
//============================================================================
left_te_lnk = param.left_te_lnk;
right_te_lnk = param.right_te_lnk;
create object instance te_lnk of TE_LNK;
te_lnk.rel_phrase = "";
// Insert the new link in between the left and right TE_LNKs.
relate te_lnk to right_te_lnk across R2075.''succeeds'';
select one r_rel related by right_te_lnk->ACT_LNK[R2042]->R_REL[R681];
te_lnk.rel_number = right_te_lnk.rel_number;
select one te_class related by r_rel->R_ASSOC[R206]->R_ASSR[R211]->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201]->TE_CLASS[R2019];
relate te_lnk to te_class across R2076;
// Leave OAL blank, because real OAL is not showing this link.
te_lnk.OAL = "";
select any te_oir related by r_rel->R_OIR[R201]->R_RGO[R203]->R_OIR[R203]->TE_OIR[R2035];
te_lnk.linkage = te_oir.data_member;
te_lnk.Mult = te_oir.Mult;
te_lnk.assoc_type = te_oir.assoc_type;
// Reflexive associatives put the relationship phrase onto the AONE/AOTH data members.
if ( "" != right_te_lnk.rel_phrase )
  te_lnk.linkage = ( te_lnk.linkage + "_" ) + T::underscore(s:right_te_lnk.rel_phrase);
end if;
if ( not_empty left_te_lnk )
  relate left_te_lnk to te_lnk across R2075.''succeeds'';
  te_lnk.left = left_te_lnk.linkage;
  te_lnk.first = false;
else
  te_lnk.left = te_lnk.linkage;
  te_lnk.first = true;
end if;
te_lnk.last = false;
te_lnk.iterator = "i" + te_lnk.linkage;
te_lnk.Mult = right_te_lnk.Mult;
right_te_lnk.Mult = 0;
right_te_lnk.left = te_lnk.linkage;
return te_lnk;
',
	"7fafab07-49e2-4355-8187-c89c6b120460",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("94d134c3-5ee1-44a7-b1c3-ea02667bcbd0",
	"526a830a-40e6-4dbf-a1d4-4ef76e23a5f9",
	'left_te_lnk',
	"7fafab07-49e2-4355-8187-c89c6b120460",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("7fafab07-49e2-4355-8187-c89c6b120460",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Chain Link>',
	'',
	'',
	'../Translation OAL/Translation OAL.xtuml');
INSERT INTO S_SPARM
	VALUES ("d4a96da9-23de-4d19-84e0-2e2e62178223",
	"526a830a-40e6-4dbf-a1d4-4ef76e23a5f9",
	'right_te_lnk',
	"7fafab07-49e2-4355-8187-c89c6b120460",
	0,
	'',
	"94d134c3-5ee1-44a7-b1c3-ea02667bcbd0",
	'');
INSERT INTO PE_PE
	VALUES ("526a830a-40e6-4dbf-a1d4-4ef76e23a5f9",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("23a75ae6-3fd0-44d3-abe7-a1d836f55c3b",
	"00000000-0000-0000-0000-000000000000",
	'detect_and_insert_associator_TE_LNK',
	'',
	'//
//============================================================================
// Detect and insert an associator TE_LNK if needed and adjust the te_lnk
// attributes according to the flavor of associative traversal.
// Accept a pair of te_lnk instances or a start_o_obj and one next_te_lnk.
//============================================================================
te_lnk = param.te_lnk;
next_te_lnk = param.next_te_lnk;
act_lnk = param.act_lnk;
next_act_lnk = param.next_act_lnk;
start_o_obj = param.start_o_obj;
if ( not_empty te_lnk )
  select one start_o_obj related by act_lnk->O_OBJ[R678];
end if;
if ( "aone" == next_te_lnk.assoc_type )
  select one r_aoth related by next_act_lnk->R_REL[R681]->R_ASSOC[R206]->R_AOTH[R210];
  if ( start_o_obj.Obj_ID == r_aoth.Obj_ID )
    // aoth -> aone
    r = ::associator_TE_LNK( left_te_lnk:te_lnk, right_te_lnk:next_te_lnk );
    te_lnk = r;
  else
    select one r_assr related by next_act_lnk->R_REL[R681]->R_ASSOC[R206]->R_ASSR[R211];
    if ( start_o_obj.Obj_ID == r_assr.Obj_ID )
      // assr -> aone
      next_te_lnk.Mult = 0;
    end if;
  end if;
elif ( "aoth" == next_te_lnk.assoc_type )
  select one r_aone related by next_act_lnk->R_REL[R681]->R_ASSOC[R206]->R_AONE[R209];
  if ( start_o_obj.Obj_ID == r_aone.Obj_ID )
    // aone -> aoth
    r = ::associator_TE_LNK( left_te_lnk:te_lnk, right_te_lnk:next_te_lnk );
    te_lnk = r;
  else
    select one r_assr related by next_act_lnk->R_REL[R681]->R_ASSOC[R206]->R_ASSR[R211];
    if ( start_o_obj.Obj_ID == r_assr.Obj_ID )
      // assr -> aoth
      next_te_lnk.Mult = 0;
    end if;
  end if;
elif ( "assr" == next_te_lnk.assoc_type )
  // For an associator, the multiplicity is that of the far side.
  select one r_aone related by next_act_lnk->R_REL[R681]->R_ASSOC[R206]->R_AONE[R209];
  select one r_aoth related by next_act_lnk->R_REL[R681]->R_ASSOC[R206]->R_AOTH[R210];
  if ( r_aone.Obj_ID == r_aoth.Obj_ID )
    // reflexive associative going from aone/aoth to assr
    if ( r_aone.Txt_Phrs == next_te_lnk.rel_phrase )
      next_te_lnk.Mult = r_aone.Mult;
    elif ( r_aoth.Txt_Phrs == next_te_lnk.rel_phrase )
      next_te_lnk.Mult = r_aoth.Mult;
    else
      T::print(s:"Invalid associative reflexive traversal from T::s(i:start_o_obj.Name)/T::s(i:start_o_obj.Key_Lett) to T::s(i:next_te_lnk.te_classGeneratedName).");
      T::exit(i:100);
    end if;
  elif ( start_o_obj.Obj_ID == r_aone.Obj_ID )
    // aone -> assr
    next_te_lnk.Mult = r_aoth.Mult;
  elif ( start_o_obj.Obj_ID == r_aoth.Obj_ID )
    // aoth -> assr
    next_te_lnk.Mult = r_aone.Mult;
  else
    T::print(s:"Invalid associative reflexive traversal from T::s(i:start_o_obj.Name)/T::s(i:start_o_obj.Key_Lett) to T::s(i:next_te_lnk.te_classGeneratedName).");
    T::exit(i:100);
  end if;
end if;
return te_lnk;
',
	"7fafab07-49e2-4355-8187-c89c6b120460",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("c8be093b-c9a4-4c2e-9bce-f06afe9862b5",
	"23a75ae6-3fd0-44d3-abe7-a1d836f55c3b",
	'te_lnk',
	"7fafab07-49e2-4355-8187-c89c6b120460",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("7ab42952-8528-49bb-b39c-4137ad6cb17c",
	"23a75ae6-3fd0-44d3-abe7-a1d836f55c3b",
	'next_te_lnk',
	"7fafab07-49e2-4355-8187-c89c6b120460",
	0,
	'',
	"c8be093b-c9a4-4c2e-9bce-f06afe9862b5",
	'');
INSERT INTO S_SPARM
	VALUES ("c670ce8c-6a95-46f8-ab90-c9e504a74b34",
	"23a75ae6-3fd0-44d3-abe7-a1d836f55c3b",
	'act_lnk',
	"44344236-6d4d-42b5-b14f-246447643355",
	0,
	'',
	"7ab42952-8528-49bb-b39c-4137ad6cb17c",
	'');
INSERT INTO S_SPARM
	VALUES ("a316cc5e-3fcb-4286-b2c5-36fc12be84c5",
	"23a75ae6-3fd0-44d3-abe7-a1d836f55c3b",
	'next_act_lnk',
	"44344236-6d4d-42b5-b14f-246447643355",
	0,
	'',
	"c670ce8c-6a95-46f8-ab90-c9e504a74b34",
	'');
INSERT INTO S_SPARM
	VALUES ("fa6ab7c3-b50c-47e8-b13c-c0c64bc2d275",
	"23a75ae6-3fd0-44d3-abe7-a1d836f55c3b",
	'start_o_obj',
	"d6b21eeb-39da-43bf-b503-c7bbc9ddf242",
	0,
	'',
	"a316cc5e-3fcb-4286-b2c5-36fc12be84c5",
	'');
INSERT INTO PE_PE
	VALUES ("23a75ae6-3fd0-44d3-abe7-a1d836f55c3b",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("0a406a39-28de-45cd-81ba-ef1ff08e5694",
	"00000000-0000-0000-0000-000000000000",
	'TE_C_mark_nested_system',
	'',
	'//
// Recursive call to drill down and get all of the nested components and
// component references.
te_cs = param.te_cs;
for each te_c in te_cs
  te_c.included_in_build = true;
  select many nested_te_cs related by te_c->C_C[R2054]->PE_PE[R8003]->C_C[R8001]->TE_C[R2054];
  ::TE_C_mark_nested_system( te_cs:nested_te_cs );
  select many nested_te_cs related by te_c->C_C[R2054]->PE_PE[R8003]->CL_IC[R8001]->C_C[R4201]->TE_C[R2054];
  ::TE_C_mark_nested_system( te_cs:nested_te_cs );
  // TODO - SKB: What about components that are nested under package(s) inside this component?  The above 2
  // traversals assume the nested component or component reference is right under the component we''re processing.
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("64102662-9f3f-43bb-a7c7-62d51a90a530",
	"0a406a39-28de-45cd-81ba-ef1ff08e5694",
	'te_cs',
	"524464d1-f305-4a50-8ac5-89e6a4df72f0",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("524464d1-f305-4a50-8ac5-89e6a4df72f0",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Extended Component>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("0a406a39-28de-45cd-81ba-ef1ff08e5694",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("8e4cfd64-fe46-4a10-a655-c2c73878125d",
	"00000000-0000-0000-0000-000000000000",
	'TE_C_getContainingComponent',
	'',
	'//
// Recursively search upwards through the package hierarchy to find the
// containing (parent/owning) component.
ep_pkg = param.ep_pkg;
select any te_c from instances of TE_C where ( false );
// Return empty te_c for a top-level package with no containing package or component.
select one s_sys related by ep_pkg->S_SYS[R1401];
if ( empty s_sys )
  select one te_c related by ep_pkg->PE_PE[R8001]->C_C[R8003]->TE_C[R2054];
  if ( empty te_c )
    select one parent_ep_pkg related by ep_pkg->PE_PE[R8001]->EP_PKG[R8000];
    if ( not_empty parent_ep_pkg )
      r = ::TE_C_getContainingComponent( ep_pkg:parent_ep_pkg );
      te_c = r;
    end if;
  end if;
end if;
return te_c;
',
	"af13e9b7-f940-4a62-b6da-d8fb321a8a39",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("3e49b9bd-722b-474b-be22-8bd091884d91",
	"8e4cfd64-fe46-4a10-a655-c2c73878125d",
	'ep_pkg',
	"bc235622-5914-4c46-87f7-e7209f83a876",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("bc235622-5914-4c46-87f7-e7209f83a876",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Package>',
	'',
	'',
	'../Instance Reference Data Types/Instance Reference Data Types.xtuml');
INSERT INTO PE_PE
	VALUES ("8e4cfd64-fe46-4a10-a655-c2c73878125d",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("59fc5c33-3e1e-4666-b618-961cc9084865",
	"00000000-0000-0000-0000-000000000000",
	'EP_PKG_getContainingPackage',
	'',
	'//
// Recursively search upwards through the component hierarcy to find the
// containing (parent/owning) package.
c_c = param.c_c;
select one ep_pkg related by c_c->PE_PE[R8001]->EP_PKG[R8000];
if ( empty ep_pkg )
  select one c_c related by c_c->PE_PE[R8001]->C_C[R8003];
  r = ::EP_PKG_getContainingPackage( c_c:c_c );
  ep_pkg = r;
end if;
return ep_pkg;
',
	"bc235622-5914-4c46-87f7-e7209f83a876",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("2cb0532b-46b8-47a4-899b-57eb8da5cd66",
	"59fc5c33-3e1e-4666-b618-961cc9084865",
	'c_c',
	"3a196930-4610-45a6-baf8-3062a2ef9851",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("3a196930-4610-45a6-baf8-3062a2ef9851",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Component>',
	'',
	'',
	'../Instance Reference Data Types/Instance Reference Data Types.xtuml');
INSERT INTO PE_PE
	VALUES ("59fc5c33-3e1e-4666-b618-961cc9084865",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("48662b42-5788-40a5-9b19-b4a6172fc636",
	"00000000-0000-0000-0000-000000000000",
	'TE_C_sort',
	'',
	'//
// Sort a list of TE_Cs.
te_cs = param.te_cs;
// Declare an empty instance reference.
select any head_te_c related by te_cs->TE_C[R2017.''succeeds''] where ( false );
for each te_c in te_cs
  r = ::TE_C_insert( head_te_c:head_te_c, te_c:te_c );
  head_te_c = r;
end for;
return head_te_c;
',
	"af13e9b7-f940-4a62-b6da-d8fb321a8a39",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("57c25a47-284f-43c5-8ce1-0dfbb2219e8c",
	"48662b42-5788-40a5-9b19-b4a6172fc636",
	'te_cs',
	"524464d1-f305-4a50-8ac5-89e6a4df72f0",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("48662b42-5788-40a5-9b19-b4a6172fc636",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("98d898a9-b9a8-420a-a00b-87b4bc2d5e30",
	"00000000-0000-0000-0000-000000000000",
	'TE_C_insert',
	'',
	'head_te_c = param.head_te_c;
te_c = param.te_c;
result = te_c;
if ( empty head_te_c )
  // Just starting.  Return te_c as head.
elif ( te_c.Name <= head_te_c.Name )
  // insert before
  relate te_c to head_te_c across R2017.''succeeds'';
else
  // find bigger
  result = head_te_c;
  prev_te_c = head_te_c;
  select one cursor_te_c related by head_te_c->TE_C[R2017.''succeeds''];
  while ( not_empty cursor_te_c )
    if ( te_c.Name <= cursor_te_c.Name )
      break;
    else
      prev_te_c = cursor_te_c;
      select one cursor_te_c related by cursor_te_c->TE_C[R2017.''succeeds''];
    end if;
  end while;
  relate prev_te_c to te_c across R2017.''succeeds'';
  if ( not_empty cursor_te_c )
    relate te_c to cursor_te_c across R2017.''succeeds'';
  end if;
end if;
return result;
',
	"af13e9b7-f940-4a62-b6da-d8fb321a8a39",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("0fdd2df0-306c-4991-8bc5-14bb9c9716d1",
	"98d898a9-b9a8-420a-a00b-87b4bc2d5e30",
	'head_te_c',
	"af13e9b7-f940-4a62-b6da-d8fb321a8a39",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("d4878421-f5d7-403d-a87d-a9f41bd7ba23",
	"98d898a9-b9a8-420a-a00b-87b4bc2d5e30",
	'te_c',
	"af13e9b7-f940-4a62-b6da-d8fb321a8a39",
	0,
	'',
	"0fdd2df0-306c-4991-8bc5-14bb9c9716d1",
	'');
INSERT INTO PE_PE
	VALUES ("98d898a9-b9a8-420a-a00b-87b4bc2d5e30",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("6b43c81d-d518-4c3d-b272-8088475c7915",
	"00000000-0000-0000-0000-000000000000",
	'class_sort',
	'',
	'//
// Sort a list of TE_CLASSes.
te_classs = param.te_classs;
// Declare an empty instance reference.
select any head_te_class related by te_classs->TE_CLASS[R2092.''succeeds''] where ( false );
for each te_class in te_classs
  end for;
for each te_class in te_classs
  r = ::class_insert( head_te_class:head_te_class, te_class:te_class );
  head_te_class = r;
end for;
return head_te_class;
',
	"f975acb7-4246-4a87-9c5a-75481f096785",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("a336afea-3054-4669-ad1f-01b9346a8b68",
	"6b43c81d-d518-4c3d-b272-8088475c7915",
	'te_classs',
	"54de650e-cdb2-4d65-ad98-5eb87386d7e7",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("54de650e-cdb2-4d65-ad98-5eb87386d7e7",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Extended Class>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("6b43c81d-d518-4c3d-b272-8088475c7915",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("d5b8df7a-d99e-4d60-ae8d-7414f3a735cc",
	"00000000-0000-0000-0000-000000000000",
	'class_insert',
	'',
	'head_te_class = param.head_te_class;
te_class = param.te_class;
result = te_class;
if ( empty head_te_class )
  // Just starting.  Return te_class as head.
else
  lkey = T::s(i:te_class.Numb) + te_class.GeneratedName;
  rkey = T::s(i:head_te_class.Numb) + head_te_class.GeneratedName;
  if ( lkey <= rkey )
    // insert before
    relate te_class to head_te_class across R2092.''succeeds'';
  else
    // find bigger
    result = head_te_class;
    prev_te_class = head_te_class;
    select one cursor_te_class related by head_te_class->TE_CLASS[R2092.''succeeds''];
    while ( not_empty cursor_te_class )
      rkey = T::s(i:cursor_te_class.Numb) + cursor_te_class.GeneratedName;
      if ( lkey <= rkey )
        break;
      else
        prev_te_class = cursor_te_class;
        select one cursor_te_class related by cursor_te_class->TE_CLASS[R2092.''succeeds''];
      end if;
    end while;
    relate prev_te_class to te_class across R2092.''succeeds'';
    if ( not_empty cursor_te_class )
      relate te_class to cursor_te_class across R2092.''succeeds'';
    end if;
  end if;
end if;
return result;
',
	"f975acb7-4246-4a87-9c5a-75481f096785",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("41449fc5-d131-401d-a943-46d5dd89723f",
	"d5b8df7a-d99e-4d60-ae8d-7414f3a735cc",
	'head_te_class',
	"f975acb7-4246-4a87-9c5a-75481f096785",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("12764a3b-9961-464b-a4aa-6d9f8337ff97",
	"d5b8df7a-d99e-4d60-ae8d-7414f3a735cc",
	'te_class',
	"f975acb7-4246-4a87-9c5a-75481f096785",
	0,
	'',
	"41449fc5-d131-401d-a943-46d5dd89723f",
	'');
INSERT INTO PE_PE
	VALUES ("d5b8df7a-d99e-4d60-ae8d-7414f3a735cc",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("3ea8d5a8-7078-40ed-a07e-b0b35b94ee84",
	"00000000-0000-0000-0000-000000000000",
	'mact_sort',
	'',
	'//
// Sort a list of TE_MACTs.
te_macts = param.te_macts;
// Declare an empty instance reference.
select any head_te_mact related by te_macts->TE_MACT[R2083.''succeeds''] where ( false );
for each te_mact in te_macts
  end for;
for each te_mact in te_macts
  r = ::mact_insert( head_te_mact:head_te_mact, te_mact:te_mact );
  head_te_mact = r;
end for;
counter = 0;
te_mact = head_te_mact;
while ( not_empty te_mact )
  te_mact.Order = counter;
  counter = counter + 1;
  select one te_mact related by te_mact->TE_MACT[R2083.''succeeds''];
end while;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("13976cac-1884-46df-b5ee-38940aeab4af",
	"3ea8d5a8-7078-40ed-a07e-b0b35b94ee84",
	'te_macts',
	"f368fddc-d16b-426c-81ab-525461c2ac04",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("f368fddc-d16b-426c-81ab-525461c2ac04",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Extended Message Action>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("3ea8d5a8-7078-40ed-a07e-b0b35b94ee84",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("9d12258c-4b9d-45c5-8040-b9a1db708ffd",
	"00000000-0000-0000-0000-000000000000",
	'mact_insert',
	'',
	'head_te_mact = param.head_te_mact;
te_mact = param.te_mact;
result = te_mact;
if ( empty head_te_mact )
  // Just starting.  Return te_mact as head.
else
  lkey = te_mact.Name;
  rkey = head_te_mact.Name;
  if ( lkey <= rkey )
    // insert before
    relate te_mact to head_te_mact across R2083.''succeeds'';
  else
    // find bigger
    result = head_te_mact;
    prev_te_mact = head_te_mact;
    select one cursor_te_mact related by head_te_mact->TE_MACT[R2083.''succeeds''];
    while ( not_empty cursor_te_mact )
      rkey = cursor_te_mact.Name;
      if ( lkey <= rkey )
        break;
      else
        prev_te_mact = cursor_te_mact;
        select one cursor_te_mact related by cursor_te_mact->TE_MACT[R2083.''succeeds''];
      end if;
    end while;
    relate prev_te_mact to te_mact across R2083.''succeeds'';
    if ( not_empty cursor_te_mact )
      relate te_mact to cursor_te_mact across R2083.''succeeds'';
    end if;
  end if;
end if;
return result;
',
	"7268e543-f48e-4464-ba70-227deff22727",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("f0dd2dcc-0e43-4929-8dfa-4b2ab70f83af",
	"9d12258c-4b9d-45c5-8040-b9a1db708ffd",
	'head_te_mact',
	"7268e543-f48e-4464-ba70-227deff22727",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("0dc73d39-7181-4b69-bf9d-7182a96fbe28",
	"9d12258c-4b9d-45c5-8040-b9a1db708ffd",
	'te_mact',
	"7268e543-f48e-4464-ba70-227deff22727",
	0,
	'',
	"f0dd2dcc-0e43-4929-8dfa-4b2ab70f83af",
	'');
INSERT INTO PE_PE
	VALUES ("9d12258c-4b9d-45c5-8040-b9a1db708ffd",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("7b2cde17-3bcd-42fd-8e4a-a2db1e06e972",
	"00000000-0000-0000-0000-000000000000",
	'blk_indentwhitespace',
	'',
	'//
// indentation maker
//
indentation = param.indentation;
result = "";
while ( 0 < indentation )
  indentation = indentation - 1;
  result = result + "";
end while;
return result;
',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("ce02ec02-a7f1-47c0-9f52-2546d5c48848",
	"7b2cde17-3bcd-42fd-8e4a-a2db1e06e972",
	'indentation',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("7b2cde17-3bcd-42fd-8e4a-a2db1e06e972",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("56a681eb-2262-459e-9e10-48763f79f597",
	"00000000-0000-0000-0000-000000000000",
	'gen_parameter_list',
	'',
	'//====================================================================
//
// $RCSfile: q.utils.arc,v $
//
// (c) Copyright 1998-2013 Mentor Graphics Corporation  All rights reserved.
//
//====================================================================
//
v_pars = param.v_pars;
prefix_param_delimiter = param.prefix_param_delimiter;
invocation_flavor = param.invocation_flavor;
//
result = "";
if ( not_empty v_pars )
  select any te_string from instances of TE_STRING;
  item_count = 0;
  select many te_pars related by v_pars->TE_PAR[R2063];
  for each te_par in te_pars
    select one te_parm related by te_par->TE_PARM[R2091];
    te_par.Order = te_parm.Order;
    item_count = item_count + 1;
  end for;
  item_number = 0;
  param_delimiter = "";
  if ( prefix_param_delimiter )
    param_delimiter = ",";
  end if;
  while ( item_number < item_count )
    select any te_par related by v_pars->TE_PAR[R2063] where ( selected.Order == item_number );
    select one v_par related by te_par->V_PAR[R2063];
    select one v_val related by v_par->V_VAL[R800];
    select one te_val related by v_val->TE_VAL[R2040];
    result = ( result + param_delimiter ) + te_val.OAL;
    if ( "" == te_val.buffer )
      //::gen_value( v_val:v_val );
    end if;
//T::b(s:T::s(i:param_delimiter)\);
    //
    // Determine if the parameter is of type string.
    // If string, check to see if this parameter is actually a function.
    // If so, declare a variable in this scope to hold the return string.
    // Do so by traversing to the te_blk instance to add the declaration.
    stringbody = false;
    if ( 0 == te_par.By_Ref )
      select one te_dt related by v_val->S_DT[R820]->TE_DT[R2021];
      if ( 4 == te_dt.Core_Typ )
        // Check the four types of returnable action bodies for string.
        select one v_trv related by v_val->V_TRV[R801];
        if ( not_empty v_trv )
          stringbody = true;
        else
          select one v_msv related by v_val->V_MSV[R801];
          if ( not_empty v_msv )
            stringbody = true;
          else
            select one v_brv related by v_val->V_BRV[R801];
            if ( not_empty v_brv )
              stringbody = true;
            else
              select one v_fnv related by v_val->V_FNV[R801];
              if ( not_empty v_fnv )
                stringbody = true;
              end if;
            end if;
          end if;
        end if;
        if ( stringbody )
          te_par.buffer = "v_sretval"; // + T::s(i:info.unique_num);
          select one te_blk related by v_val->ACT_BLK[R826]->TE_BLK[R2016];
          te_blk.declaration = ( ( ( te_blk.declaration + te_dt.ExtName ) + ( "" + te_par.buffer ) ) + ( "[" + te_string.max_string_length ) ) + "];";
//T::b(s:T::s(i:te_string.strcpy)( T::s(i:te_par.buffer), \);
        end if;
      end if;
      //
      //
//T::b(s:T::s(i:te_val.buffer)\);
      if ( stringbody )
//T::b(s:)\);
      end if;
    else
//T::b(s:&(T::s(i:te_val.buffer))\);
    end if;
    param_delimiter = ", ";
    item_number = item_number + 1;
  end while;
end if;
return result;
',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("a3f37cb6-a86b-4642-9c3b-46fe24800d5d",
	"56a681eb-2262-459e-9e10-48763f79f597",
	'v_pars',
	"ae5b840e-5312-4865-ae17-5c9bba997543",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("ae5b840e-5312-4865-ae17-5c9bba997543",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Actual Parameter>',
	'',
	'',
	'../Value/Value.xtuml');
INSERT INTO S_SPARM
	VALUES ("b701654f-0e68-404a-9aab-17de39761098",
	"56a681eb-2262-459e-9e10-48763f79f597",
	'prefix_param_delimiter',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"a3f37cb6-a86b-4642-9c3b-46fe24800d5d",
	'');
INSERT INTO S_SPARM
	VALUES ("078bc0b7-a68f-4008-84b8-cdd040b0d8ba",
	"56a681eb-2262-459e-9e10-48763f79f597",
	'invocation_flavor',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"b701654f-0e68-404a-9aab-17de39761098",
	'');
INSERT INTO PE_PE
	VALUES ("56a681eb-2262-459e-9e10-48763f79f597",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("c096ad7d-eedf-4cc9-81bd-d20d3e71f1fd",
	"00000000-0000-0000-0000-000000000000",
	'is_reflexive',
	'',
	'//
//====================================================================
//
r_rel = param.r_rel;
//
result = false;
select one r_simp related by r_rel->R_SIMP[R206];
if ( not_empty r_simp )
  select many r_parts related by r_simp->R_PART[R207];
  if ( ( cardinality r_parts ) > 1 )
    select any first_r_part related by r_simp->R_PART[R207];
    select any second_r_part related by r_simp->R_PART[R207] where ( selected.OIR_ID != first_r_part.OIR_ID );
    if ( first_r_part.Obj_ID == second_r_part.Obj_ID )
      result = true;
    end if;
  else
    select any r_part related by r_simp->R_PART[R207];
    select one r_form related by r_simp->R_FORM[R208];
    if ( not_empty r_form )
      if ( r_part.Obj_ID == r_form.Obj_ID )
        result = true;
      end if;
    end if;
  end if;
else
  select one r_assoc related by r_rel->R_ASSOC[R206];
  if ( not_empty r_assoc )
    select one r_aone related by r_assoc->R_AONE[R209];
    select one r_aoth related by r_assoc->R_AOTH[R210];
    if ( r_aone.Obj_ID == r_aoth.Obj_ID )
      result = true;
    end if;
  end if;
end if;
return result;
',
	"ba5eda7a-def5-0000-0000-000000000001",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("daeb0783-b364-40dd-9f72-7511c9e5a23f",
	"c096ad7d-eedf-4cc9-81bd-d20d3e71f1fd",
	'r_rel',
	"620e9be8-e289-47ed-9279-69b359c269c5",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("620e9be8-e289-47ed-9279-69b359c269c5",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Association>',
	'',
	'',
	'../Association/Association.xtuml');
INSERT INTO PE_PE
	VALUES ("c096ad7d-eedf-4cc9-81bd-d20d3e71f1fd",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("2cc51add-ff40-4565-96e1-babbc9c3fae7",
	"00000000-0000-0000-0000-000000000000",
	't_oal_smt_event_parameters',
	'',
	'//------------------------------------------------
// Note the use of p_ here.  It is hard-coded and depends upon
// matching the prefix used in initialization population query.
evt_msg_var = param.evt_msg_var;
parameter = param.parameter;
value = param.value;
value_type = param.value_type;
ws = param.ws;
result = "";
select any te_eq from instances of TE_EQ;
if ( "" == evt_msg_var )
  evt_msg_var = te_eq.event_message_variable;
end if;
if ( 4 == value_type )
  // string
  select any te_string from instances of TE_STRING;
  select any te_instance from instances of TE_INSTANCE;
  result = ""; // T::s(i:ws)T::s(i:te_instance.module)T::s(i:te_string.strcpy)( T::s(i:evt_msg_var)->p_T::underscore(s:parameter), T::s(i:value) );;
else
  result = ""; // T::s(i:ws)T::s(i:evt_msg_var)->p_T::s(i:parameter) = T::s(i:value);;
end if;
return result;
',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("077903fc-ccdc-488c-939e-1efe2b1709e6",
	"2cc51add-ff40-4565-96e1-babbc9c3fae7",
	'evt_msg_var',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("8f5d3922-2572-4b60-b589-95f37452bbb3",
	"2cc51add-ff40-4565-96e1-babbc9c3fae7",
	'parameter',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"077903fc-ccdc-488c-939e-1efe2b1709e6",
	'');
INSERT INTO S_SPARM
	VALUES ("bc651f0c-8f90-400e-92f1-a1ae9236b80b",
	"2cc51add-ff40-4565-96e1-babbc9c3fae7",
	'value',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"8f5d3922-2572-4b60-b589-95f37452bbb3",
	'');
INSERT INTO S_SPARM
	VALUES ("52682aa3-0fa0-47f7-a274-81e0f85e7764",
	"2cc51add-ff40-4565-96e1-babbc9c3fae7",
	'value_type',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"bc651f0c-8f90-400e-92f1-a1ae9236b80b",
	'');
INSERT INTO S_SPARM
	VALUES ("20af1681-81fa-493f-9a45-bdb0ce21fd76",
	"2cc51add-ff40-4565-96e1-babbc9c3fae7",
	'ws',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"52682aa3-0fa0-47f7-a274-81e0f85e7764",
	'');
INSERT INTO PE_PE
	VALUES ("2cc51add-ff40-4565-96e1-babbc9c3fae7",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO PE_PE
	VALUES ("e0e8a924-f549-4e50-9ee0-af61843ab967",
	2,
	"efb614c1-5af5-40ee-92c8-706430a99db3",
	"00000000-0000-0000-0000-000000000000",
	7);
INSERT INTO EP_PKG_PROXY
	VALUES ("efb614c1-5af5-40ee-92c8-706430a99db3",
	"00000000-0000-0000-0000-000000000000",
	"d9bc5487-4193-4817-be1c-6c3f3339aebf",
	'ooaofooa',
	'========================================================================

File:          $RCSfile: ooaofooa.xtuml,v $
Version:   $Revision: 1.127 $
Modified:  $Date: 2006/09/26 15:10:20 $

(c) Copyright 2004-2012 by Mentor Graphics Corp. All rights reserved.

========================================================================
This document contains information proprietary and confidential to
Mentor Graphics Corp. and is not for external distribution.
========================================================================

This is the application domain for the Tiger project.

The processing in this model describes the activities
for model capture.



',
	0,
	'../ooaofooa.xtuml');
INSERT INTO S_SYS_PROXY
	VALUES ("d9bc5487-4193-4817-be1c-6c3f3339aebf",
	'com.mentor.nucleus.bp.core',
	1,
	'../../../../com.mentor.nucleus.bp.core.xtuml');

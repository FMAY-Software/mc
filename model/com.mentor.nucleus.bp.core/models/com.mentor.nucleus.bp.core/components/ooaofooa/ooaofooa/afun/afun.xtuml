-- BP 7.1.6 content: Package syschar: 3 persistence-version: 7.1.6

INSERT INTO EP_PKG
	VALUES ("e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	"d9bc5487-4193-4817-be1c-6c3f3339aebf",
	'afun',
	'',
	0);
INSERT INTO GD_MD
	VALUES ("0621fcb5-c026-4d92-93b3-509f2bbbfd38",
	112,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	108,
	0,
	0,
	1,
	1,
	1,
	12,
	1,
	0,
	0,
	0,
	0,
	0,
	'4.0.0',
	'com.mentor.nucleus.bp.core::components::ooaofooa::ooaofooa::afun');
INSERT INTO DIM_DIA
	VALUES ("0621fcb5-c026-4d92-93b3-509f2bbbfd38",
	'',
	1.000000,
	4000.000000,
	3000.000000,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO S_SYNC
	VALUES ("17b26926-9233-4f3b-bf40-b2ba7a6e61f2",
	"00000000-0000-0000-0000-000000000000",
	'a0',
	'',
	'::parm_sort();
::rel_pseudoformalize();
::sys_singletons();

// These are markings that are for the model-based MC.
select any stringpointer_s_dt from instances of S_DT where ( selected.Name == "stringpointer" );
if ( not_empty stringpointer_s_dt )
  select many o_attrs from instances of O_ATTR where ( selected.Name == "Action_Semantics_internal" );
  for each o_attr in o_attrs
    select one s_dt related by o_attr->S_DT[R114];
    unrelate o_attr from s_dt across R114;
    // o_attr.DT_ID = 00
    relate o_attr to stringpointer_s_dt across R114;
    // o_attr.DT_ID = s_dt.DT_ID
  end for;
  ::MapDataTypeAsPointer( component_name:"*", dt_name:"stringpointer", pointer_type:"c_t", include_file:"" );
end if;

select any s_sys from instances of S_SYS;
if ( "sys" == s_sys.Name )
  ::TagDynamicMemoryAllocationOn( units_to_allocate:10 );
  ::TagInstanceLoading();
  ::TagMaximumStringLength( max_len:840 );
end if;

::sys_populate();

select any te_sys from instances of TE_SYS;
::sys_analyze( te_sys:te_sys );
::CreateSpecialWhereClauseInstances( te_sys:te_sys );

select many te_cs from instances of TE_C where ( selected.included_in_build );
for each te_c in te_cs
  // Propagate domain information to the system level.
  ::te_c_CollectLimits( te_c:te_c );
  select many te_classs related by te_c->TE_CLASS[R2064] where ( not selected.ExcludeFromGen );
  c = ::class_sort( te_classs:te_classs );
end for;

::val_translate();
::oal_translate();
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("17b26926-9233-4f3b-bf40-b2ba7a6e61f2",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("8be0fde7-a1d6-4270-ac1d-4db76673ded5",
	"00000000-0000-0000-0000-000000000000",
	'sparm_sort',
	'',
	'// CDS temporarily order parameters alphabetically for backwards compatibility
s_sparms = param.s_sparms;
for each s_sparm in s_sparms
  select one prev_s_sparm related by s_sparm->S_SPARM[R54.''precedes''];
  if ( not_empty prev_s_sparm )
    unrelate s_sparm from prev_s_sparm across R54.''precedes'';
  end if;
end for;
// Declare an empty instance reference.
select any head_s_sparm related by s_sparms->S_SPARM[R54.''precedes''] where ( false );
for each s_sparm in s_sparms
  r = ::sparm_insert( head_s_sparm:head_s_sparm, s_sparm:s_sparm );
  head_s_sparm = r;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("a7c8e66a-74ef-4afe-94a7-7b608b529535",
	"8be0fde7-a1d6-4270-ac1d-4db76673ded5",
	's_sparms',
	"a397ce5f-c02a-4167-b722-9876a55f62c0",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("a397ce5f-c02a-4167-b722-9876a55f62c0",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Function Parameter>',
	'',
	'',
	'../Domain/Domain.xtuml');
INSERT INTO PE_PE
	VALUES ("8be0fde7-a1d6-4270-ac1d-4db76673ded5",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("ad8b8dd5-6f60-4cc5-8a48-3bc934cfb9cc",
	"00000000-0000-0000-0000-000000000000",
	'sparm_insert',
	'',
	'head_s_sparm = param.head_s_sparm;
s_sparm = param.s_sparm;
result = s_sparm;
if ( empty head_s_sparm )
  // Just starting.  Return s_sparm as head.
elif ( s_sparm.Name <= head_s_sparm.Name )
  // insert before
  relate s_sparm to head_s_sparm across R54.''succeeds'';
else
  // find bigger
  result = head_s_sparm;
  prev_s_sparm = head_s_sparm;
  select one cursor_s_sparm related by head_s_sparm->S_SPARM[R54.''succeeds''];
  while ( not_empty cursor_s_sparm )
    if ( s_sparm.Name <= cursor_s_sparm.Name )
      break;
    else
      prev_s_sparm = cursor_s_sparm;
      select one cursor_s_sparm related by cursor_s_sparm->S_SPARM[R54.''succeeds''];
    end if;
  end while;
  relate prev_s_sparm to s_sparm across R54.''succeeds'';
  if ( not_empty cursor_s_sparm )
    relate s_sparm to cursor_s_sparm across R54.''succeeds'';
  end if;
end if;
return result;
',
	"f822fb34-452f-42a9-8480-07154f3890a4",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("b9ff0042-7d1d-4aa6-a34d-f5bf5881b604",
	"ad8b8dd5-6f60-4cc5-8a48-3bc934cfb9cc",
	'head_s_sparm',
	"f822fb34-452f-42a9-8480-07154f3890a4",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("f822fb34-452f-42a9-8480-07154f3890a4",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Function Parameter>',
	'',
	'',
	'../Domain/Domain.xtuml');
INSERT INTO S_SPARM
	VALUES ("c3b69202-662b-44ad-a09c-68be7522819d",
	"ad8b8dd5-6f60-4cc5-8a48-3bc934cfb9cc",
	's_sparm',
	"f822fb34-452f-42a9-8480-07154f3890a4",
	0,
	'',
	"b9ff0042-7d1d-4aa6-a34d-f5bf5881b604",
	'');
INSERT INTO PE_PE
	VALUES ("ad8b8dd5-6f60-4cc5-8a48-3bc934cfb9cc",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("7c3f097f-1481-4cfd-bde1-88b3a40fdd78",
	"00000000-0000-0000-0000-000000000000",
	'bparm_sort',
	'',
	'//
//
s_bparms = param.s_bparms;
for each s_bparm in s_bparms
  select one prev_s_bparm related by s_bparm->S_BPARM[R55.''precedes''];
  if ( not_empty prev_s_bparm )
    unrelate s_bparm from prev_s_bparm across R55.''precedes'';
  end if;
end for;
// Declare an empty instance reference.
select any head_s_bparm related by s_bparms->S_BPARM[R55.''precedes''] where ( false );
for each s_bparm in s_bparms
  r = ::bparm_insert( head_s_bparm:head_s_bparm, s_bparm:s_bparm );
  head_s_bparm = r;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("97c1cdef-8698-466d-adfd-7b464d95bab8",
	"7c3f097f-1481-4cfd-bde1-88b3a40fdd78",
	's_bparms',
	"15271e51-8d77-4dc6-bc1d-a9cb226962e3",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("15271e51-8d77-4dc6-bc1d-a9cb226962e3",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Bridge Parameter>',
	'',
	'',
	'../Domain/Domain.xtuml');
INSERT INTO PE_PE
	VALUES ("7c3f097f-1481-4cfd-bde1-88b3a40fdd78",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("3fb814b5-388d-48eb-8ed3-11a579265294",
	"00000000-0000-0000-0000-000000000000",
	'bparm_insert',
	'',
	'head_s_bparm = param.head_s_bparm;
s_bparm = param.s_bparm;
result = s_bparm;
if ( empty head_s_bparm )
  // Just starting.  Return s_bparm as head.
elif ( s_bparm.Name <= head_s_bparm.Name )
  // insert before
  relate s_bparm to head_s_bparm across R55.''succeeds'';
else
  // find bigger
  result = head_s_bparm;
  prev_s_bparm = head_s_bparm;
  select one cursor_s_bparm related by head_s_bparm->S_BPARM[R55.''succeeds''];
  while ( not_empty cursor_s_bparm )
    if ( s_bparm.Name <= cursor_s_bparm.Name )
      break;
    else
      prev_s_bparm = cursor_s_bparm;
      select one cursor_s_bparm related by cursor_s_bparm->S_BPARM[R55.''succeeds''];
    end if;
  end while;
  relate prev_s_bparm to s_bparm across R55.''succeeds'';
  if ( not_empty cursor_s_bparm )
    relate s_bparm to cursor_s_bparm across R55.''succeeds'';
  end if;
end if;
return result;
',
	"6ba9a48e-9b83-47fe-a1ac-915dbf9d3ef3",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("36b9e21d-7b70-4a8c-831a-b4997425b026",
	"3fb814b5-388d-48eb-8ed3-11a579265294",
	'head_s_bparm',
	"6ba9a48e-9b83-47fe-a1ac-915dbf9d3ef3",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("6ba9a48e-9b83-47fe-a1ac-915dbf9d3ef3",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Bridge Parameter>',
	'',
	'',
	'../Domain/Domain.xtuml');
INSERT INTO S_SPARM
	VALUES ("ad75b9f6-b102-4857-ae5d-dc8b415be175",
	"3fb814b5-388d-48eb-8ed3-11a579265294",
	's_bparm',
	"6ba9a48e-9b83-47fe-a1ac-915dbf9d3ef3",
	0,
	'',
	"36b9e21d-7b70-4a8c-831a-b4997425b026",
	'');
INSERT INTO PE_PE
	VALUES ("3fb814b5-388d-48eb-8ed3-11a579265294",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b5890ad9-2154-4526-8908-02987f527192",
	"00000000-0000-0000-0000-000000000000",
	'tparm_sort',
	'',
	'//
//
o_tparms = param.o_tparms;
for each o_tparm in o_tparms
  select one prev_o_tparm related by o_tparm->O_TPARM[R124.''precedes''];
  if ( not_empty prev_o_tparm )
    unrelate o_tparm from prev_o_tparm across R124.''precedes'';
  end if;
end for;
// Declare an empty instance reference.
select any head_o_tparm related by o_tparms->O_TPARM[R124.''precedes''] where ( false );
for each o_tparm in o_tparms
  r = ::tparm_insert( head_o_tparm:head_o_tparm, o_tparm:o_tparm );
  head_o_tparm = r;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("e0dedc16-597e-4d88-b0eb-c77434684476",
	"b5890ad9-2154-4526-8908-02987f527192",
	'o_tparms',
	"8223e432-cc81-4a56-a7e3-7dbfcea931f2",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("8223e432-cc81-4a56-a7e3-7dbfcea931f2",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Operation Parameter>',
	'',
	'',
	'../Subsystem/Subsystem.xtuml');
INSERT INTO PE_PE
	VALUES ("b5890ad9-2154-4526-8908-02987f527192",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("4413b9fe-920e-4f31-8a28-95a2d74ab8e3",
	"00000000-0000-0000-0000-000000000000",
	'tparm_insert',
	'',
	'head_o_tparm = param.head_o_tparm;
o_tparm = param.o_tparm;
result = o_tparm;
if ( empty head_o_tparm )
  // Just starting.  Return o_tparm as head.
elif ( o_tparm.Name <= head_o_tparm.Name )
  // insert before
  relate o_tparm to head_o_tparm across R124.''succeeds'';
else
  // find bigger
  result = head_o_tparm;
  prev_o_tparm = head_o_tparm;
  select one cursor_o_tparm related by head_o_tparm->O_TPARM[R124.''succeeds''];
  while ( not_empty cursor_o_tparm )
    if ( o_tparm.Name <= cursor_o_tparm.Name )
      break;
    else
      prev_o_tparm = cursor_o_tparm;
      select one cursor_o_tparm related by cursor_o_tparm->O_TPARM[R124.''succeeds''];
    end if;
  end while;
  relate prev_o_tparm to o_tparm across R124.''succeeds'';
  if ( not_empty cursor_o_tparm )
    relate o_tparm to cursor_o_tparm across R124.''succeeds'';
  end if;
end if;
return result;
',
	"3f86efb0-5d9c-4ace-b91a-14a50aa50c48",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("3b564659-76db-4ed6-b245-3184d204c22d",
	"4413b9fe-920e-4f31-8a28-95a2d74ab8e3",
	'head_o_tparm',
	"3f86efb0-5d9c-4ace-b91a-14a50aa50c48",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("3f86efb0-5d9c-4ace-b91a-14a50aa50c48",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Operation Parameter>',
	'',
	'',
	'../Subsystem/Subsystem.xtuml');
INSERT INTO S_SPARM
	VALUES ("55f5be65-36f1-4ae3-8091-080bbdfe6780",
	"4413b9fe-920e-4f31-8a28-95a2d74ab8e3",
	'o_tparm',
	"3f86efb0-5d9c-4ace-b91a-14a50aa50c48",
	0,
	'',
	"3b564659-76db-4ed6-b245-3184d204c22d",
	'');
INSERT INTO PE_PE
	VALUES ("4413b9fe-920e-4f31-8a28-95a2d74ab8e3",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("8ad80eef-92e2-48b1-85a1-c95eb7327617",
	"00000000-0000-0000-0000-000000000000",
	'evtdi_sort',
	'',
	'//
//
sm_evtdis = param.sm_evtdis;
for each sm_evtdi in sm_evtdis
  select one prev_sm_evtdi related by sm_evtdi->SM_EVTDI[R533.''precedes''];
  if ( not_empty prev_sm_evtdi )
    unrelate sm_evtdi from prev_sm_evtdi across R533.''precedes'';
  end if;
end for;
// Declare an empty instance reference.
select any head_sm_evtdi related by sm_evtdis->SM_EVTDI[R533.''precedes''] where ( false );
for each sm_evtdi in sm_evtdis
  r = ::evtdi_insert( head_sm_evtdi:head_sm_evtdi, sm_evtdi:sm_evtdi );
  head_sm_evtdi = r;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("fc1a6294-1459-4713-b239-c30df2216ea2",
	"8ad80eef-92e2-48b1-85a1-c95eb7327617",
	'sm_evtdis',
	"8d48c15e-5425-419d-a407-d6d4338150d4",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("8d48c15e-5425-419d-a407-d6d4338150d4",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<State Machine Event Data Item>',
	'',
	'',
	'../State Machine/State Machine.xtuml');
INSERT INTO PE_PE
	VALUES ("8ad80eef-92e2-48b1-85a1-c95eb7327617",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("444a18aa-607b-426c-99a2-0ccde95f92ab",
	"00000000-0000-0000-0000-000000000000",
	'evtdi_insert',
	'',
	'head_sm_evtdi = param.head_sm_evtdi;
sm_evtdi = param.sm_evtdi;
result = sm_evtdi;
if ( empty head_sm_evtdi )
  // Just starting.  Return sm_evtdi as head.
elif ( sm_evtdi.Name <= head_sm_evtdi.Name )
  // insert before
  relate sm_evtdi to head_sm_evtdi across R533.''succeeds'';
else
  // find bigger
  result = head_sm_evtdi;
  prev_sm_evtdi = head_sm_evtdi;
  select one cursor_sm_evtdi related by head_sm_evtdi->SM_EVTDI[R533.''succeeds''];
  while ( not_empty cursor_sm_evtdi )
    if ( sm_evtdi.Name <= cursor_sm_evtdi.Name )
      break;
    else
      prev_sm_evtdi = cursor_sm_evtdi;
      select one cursor_sm_evtdi related by cursor_sm_evtdi->SM_EVTDI[R533.''succeeds''];
    end if;
  end while;
  relate prev_sm_evtdi to sm_evtdi across R533.''succeeds'';
  if ( not_empty cursor_sm_evtdi )
    relate sm_evtdi to cursor_sm_evtdi across R533.''succeeds'';
  end if;
end if;
return result;
',
	"aa498bc5-0f18-424e-9588-09bbffb0b5ec",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("3dd1f934-ac89-4afb-9294-90c9e943f3fe",
	"444a18aa-607b-426c-99a2-0ccde95f92ab",
	'head_sm_evtdi',
	"aa498bc5-0f18-424e-9588-09bbffb0b5ec",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("aa498bc5-0f18-424e-9588-09bbffb0b5ec",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<State Machine Event Data Item>',
	'',
	'',
	'../State Machine/State Machine.xtuml');
INSERT INTO S_SPARM
	VALUES ("3f561770-2d48-4658-b088-efbc209dc948",
	"444a18aa-607b-426c-99a2-0ccde95f92ab",
	'sm_evtdi',
	"aa498bc5-0f18-424e-9588-09bbffb0b5ec",
	0,
	'',
	"3dd1f934-ac89-4afb-9294-90c9e943f3fe",
	'');
INSERT INTO PE_PE
	VALUES ("444a18aa-607b-426c-99a2-0ccde95f92ab",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("c09c3742-ac9a-446b-b809-2d820726904e",
	"00000000-0000-0000-0000-000000000000",
	'pp_sort',
	'',
	'//
//
c_pps = param.c_pps;
for each c_pp in c_pps
  select one prev_c_pp related by c_pp->C_PP[R4021.''precedes''];
  if ( not_empty prev_c_pp )
    unrelate c_pp from prev_c_pp across R4021.''precedes'';
  end if;
end for;
// Declare an empty instance reference.
select any head_c_pp related by c_pps->C_PP[R4021.''precedes''] where ( false );
for each c_pp in c_pps
  r = ::pp_insert( head_c_pp:head_c_pp, c_pp:c_pp );
  head_c_pp = r;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("188927a3-44ed-4558-bdce-2522cfbb7637",
	"c09c3742-ac9a-446b-b809-2d820726904e",
	'c_pps',
	"47b05aeb-144f-4981-85ca-cec108b82bb7",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("47b05aeb-144f-4981-85ca-cec108b82bb7",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Property Parameter>',
	'',
	'',
	'../Component/Component.xtuml');
INSERT INTO PE_PE
	VALUES ("c09c3742-ac9a-446b-b809-2d820726904e",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("af17b89c-63e1-4971-b8fd-352c62816a3d",
	"00000000-0000-0000-0000-000000000000",
	'pp_insert',
	'',
	'head_c_pp = param.head_c_pp;
c_pp = param.c_pp;
result = c_pp;
if ( empty head_c_pp )
  // Just starting.  Return c_pp as head.
elif ( c_pp.Name <= head_c_pp.Name )
  // insert before
  relate c_pp to head_c_pp across R4021.''succeeds'';
else
  // find bigger
  result = head_c_pp;
  prev_c_pp = head_c_pp;
  select one cursor_c_pp related by head_c_pp->C_PP[R4021.''succeeds''];
  while ( not_empty cursor_c_pp )
    if ( c_pp.Name <= cursor_c_pp.Name )
      break;
    else
      prev_c_pp = cursor_c_pp;
      select one cursor_c_pp related by cursor_c_pp->C_PP[R4021.''succeeds''];
    end if;
  end while;
  relate prev_c_pp to c_pp across R4021.''succeeds'';
  if ( not_empty cursor_c_pp )
    relate c_pp to cursor_c_pp across R4021.''succeeds'';
  end if;
end if;
return result;
',
	"b38e0639-ac8f-4bfb-b8a4-0a2ee533862b",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("6333a42a-1a99-4766-98da-bd0b5eaf87a4",
	"af17b89c-63e1-4971-b8fd-352c62816a3d",
	'head_c_pp',
	"b38e0639-ac8f-4bfb-b8a4-0a2ee533862b",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("b38e0639-ac8f-4bfb-b8a4-0a2ee533862b",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Property Parameter>',
	'',
	'',
	'../Component/Component.xtuml');
INSERT INTO S_SPARM
	VALUES ("c8334083-1c55-4ca0-9619-35aeb1521846",
	"af17b89c-63e1-4971-b8fd-352c62816a3d",
	'c_pp',
	"b38e0639-ac8f-4bfb-b8a4-0a2ee533862b",
	0,
	'',
	"6333a42a-1a99-4766-98da-bd0b5eaf87a4",
	'');
INSERT INTO PE_PE
	VALUES ("af17b89c-63e1-4971-b8fd-352c62816a3d",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("47f076d8-8af0-4637-b716-9c3ebfc18544",
	"00000000-0000-0000-0000-000000000000",
	'parm_sort',
	'',
	'//
// CDS temporary for sorting model data parameters
if ( true )
  select many s_syncs from instances of S_SYNC;
  for each s_sync in s_syncs
    select many s_sparms related by s_sync->S_SPARM[R24];
    ::sparm_sort( s_sparms:s_sparms );
  end for;
  select many s_brgs from instances of S_BRG;
  for each s_brg in s_brgs
    select many s_bparms related by s_brg->S_BPARM[R21];
    ::bparm_sort( s_bparms:s_bparms );
  end for;
  select many o_tfrs from instances of O_TFR;
  for each o_tfr in o_tfrs
    select many o_tparms related by o_tfr->O_TPARM[R117];
    ::tparm_sort( o_tparms:o_tparms );
  end for;
  select many sm_evts from instances of SM_EVT;
  for each sm_evt in sm_evts
    select many sm_evtdis related by sm_evt->SM_EVTDI[R532];
    ::evtdi_sort( sm_evtdis:sm_evtdis );
  end for;
  select many c_eps from instances of C_EP;
  for each c_ep in c_eps
    select many c_pps related by c_ep->C_PP[R4006];
    ::pp_sort( c_pps:c_pps );
  end for;
end if;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("47f076d8-8af0-4637-b716-9c3ebfc18544",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("e621c5a1-ecc0-449f-98c5-8535e3ad6e2e",
	"00000000-0000-0000-0000-000000000000",
	'rel_pseudoformalize',
	'',
	'//============================================================================
// $RCSfile: q.assoc.pseudoformalize.arc,v $
//
// Description:
// This query/transformation archetype file contains the functionality
// that will allow the model compiler to generate code for unformalized 
// associations (associations that have not been formalized).
//
// Notice:
// (C) Copyright 1998-2013 Mentor Graphics Corporation
//     All rights reserved.
//
// This document contains confidential and proprietary information and
// property of Mentor Graphics Corp.  No part of this document may be
// reproduced without the express written permission of Mentor Graphics Corp.
//============================================================================
//
// Find the associations that are not formalized.  They are characterized
// by the existence of 2 instances of R_PART linked to one R_SIMP.
// Migrate the R_PART/R_RTO pair to R_FORM/R_RGO.
// It does not matter which participant we choose unless this is a many
// association.  Grab the many side of a 1-M or any random R_PART and
// migrate it and its parent R_RTO to R_FORM and R_RGO respectively.
select many r_simps from instances of R_SIMP;
for each r_simp in r_simps
  select many r_parts related by r_simp->R_PART[R207];
  if ( ( cardinality r_parts ) > 1 )
    select any r_part related by r_simp->R_PART[R207] where ( selected.Mult == 1 );
    if ( empty r_part )
      select any r_part related by r_simp->R_PART[R207];
    end if;
    select one r_rto related by r_part->R_RTO[R204];
    select one r_oir related by r_rto->R_OIR[R203];
    //
    create object instance r_rgo of R_RGO;
    create object instance r_form of R_FORM;
    //
    // Copy the R_PART to the new R_FORM.
    r_form.Mult = r_part.Mult;
    r_form.Cond = r_part.Cond;
    r_form.Txt_Phrs = r_part.Txt_Phrs;
    //
    unrelate r_part from r_rto across R204;
    unrelate r_part from r_simp across R207;
    delete object instance r_part;
    //
    unrelate r_rto from r_oir across R203;
    delete object instance r_rto;
    //
    relate r_rgo to r_oir across R203;
    relate r_form to r_rgo across R205;
    relate r_form to r_simp across R208;
  end if;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("e621c5a1-ecc0-449f-98c5-8535e3ad6e2e",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("198c4624-80a7-4a13-9447-ee1224dea95a",
	"00000000-0000-0000-0000-000000000000",
	'container_factory',
	'',
	'//
te_container = param.te_container;
te_container.flavor = "";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("eb148e98-f56a-43e0-be93-a648f3eb7a5d",
	"198c4624-80a7-4a13-9447-ee1224dea95a",
	'te_container',
	"bed7aed0-a8ba-4e93-acaa-c7c0ef17e639",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("bed7aed0-a8ba-4e93-acaa-c7c0ef17e639",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<container>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("198c4624-80a7-4a13-9447-ee1224dea95a",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("0c8c674b-b119-47f3-8ac6-c4af324eacb1",
	"00000000-0000-0000-0000-000000000000",
	'copyright_factory',
	'',
	'//
//
te_copyright = param.te_copyright;
te_copyright.body = "your copyright statement can go here (from te_copyright.body)";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("60204a32-ed9a-4fd9-aead-5bb6a4274b47",
	"0c8c674b-b119-47f3-8ac6-c4af324eacb1",
	'te_copyright',
	"66047ebf-b4d3-4c3f-ac61-a72efcb39e53",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("66047ebf-b4d3-4c3f-ac61-a72efcb39e53",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<copyright>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("0c8c674b-b119-47f3-8ac6-c4af324eacb1",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("41313cfa-158f-4ec6-aa8c-9e96ae0ecbf8",
	"00000000-0000-0000-0000-000000000000",
	'dlist_factory',
	'',
	'//
//
te_dlist = param.te_dlist;
select any te_prefix from instances of TE_PREFIX;
te_dlist.remove_node = te_prefix.result + "SetRemoveDlistNode";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("a91b1a82-f5a9-43c1-b6e5-dced94f19f81",
	"41313cfa-158f-4ec6-aa8c-9e96ae0ecbf8",
	'te_dlist',
	"ae4a14e9-ebe7-41e2-97d0-0b6e1b15ceea",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("ae4a14e9-ebe7-41e2-97d0-0b6e1b15ceea",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<dlist>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("41313cfa-158f-4ec6-aa8c-9e96ae0ecbf8",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("f6dc1fba-ae3c-4e84-9c68-760d21a37329",
	"00000000-0000-0000-0000-000000000000",
	'dma_factory',
	'',
	'//
//
te_dma = param.te_dma;
select any te_prefix from instances of TE_PREFIX;
te_dma.file = "sys_memory";
te_dma.allocate = te_prefix.result + "malloc";
te_dma.release = te_prefix.result + "free";
te_dma.debugging_heap = false;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("729ca23b-b3b2-4bf7-b0fe-321cca515b5e",
	"f6dc1fba-ae3c-4e84-9c68-760d21a37329",
	'te_dma',
	"95c40567-3d38-4e09-ab51-e0a2883d1bae",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("95c40567-3d38-4e09-ab51-e0a2883d1bae",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<dynamic memory allocation>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("f6dc1fba-ae3c-4e84-9c68-760d21a37329",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a8785226-e7e1-463b-9dd7-6deb50e86aec",
	"00000000-0000-0000-0000-000000000000",
	'eq_factory',
	'',
	'//
//
te_eq = param.te_eq;
select any te_prefix from instances of TE_PREFIX;
te_eq.ignored = "EVENT_IS_IGNORED";
te_eq.cant_happen = "EVENT_CANT_HAPPEN";
te_eq.system_events_union = te_prefix.result + "systemxtUMLevents";
te_eq.system_event_pool = te_prefix.result + "xtUML_event_pool";
te_eq.constant_type = te_prefix.result + "xtUMLEventConstant_t";
te_eq.base_event_type = te_prefix.result + "xtUMLEvent_t";
te_eq.base_variable = "mc_event_base";
te_eq.max_events = te_prefix.define_u + "SYS_MAX_XTUML_EVENTS";
te_eq.max_self_events = te_prefix.define_u + "SYS_MAX_SELF_EVENTS";
te_eq.max_nonself_events = te_prefix.define_u + "SYS_MAX_NONSELF_EVENTS";
te_eq.new = te_prefix.result + "NewxtUMLEvent";
te_eq.allocate = te_prefix.result + "AllocatextUMLEvent";
te_eq.delete = te_prefix.result + "DeletextUMLEvent";
te_eq.modify = te_prefix.result + "ModifyxtUMLEvent";
te_eq.self = te_prefix.result + "SendSelfEvent";
te_eq.non_self = te_prefix.result + "SendEvent";
te_eq.search_and_destroy = te_prefix.result + "EventSearchAndDestroy";
te_eq.run_flag = te_prefix.result + "run_flag";
te_eq.event_message_variable = "e";
te_eq.scope = "";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("59a228d5-60ef-478c-8e8c-a016fa61320b",
	"a8785226-e7e1-463b-9dd7-6deb50e86aec",
	'te_eq',
	"d6d92349-6671-4f67-b702-a8dcef6f4bab",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("d6d92349-6671-4f67-b702-a8dcef6f4bab",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<event queue>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("a8785226-e7e1-463b-9dd7-6deb50e86aec",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("ffb2ef9c-41f7-416d-9748-91107c2baf9b",
	"00000000-0000-0000-0000-000000000000",
	'extent_factory',
	'',
	'//
//
te_extent = param.te_extent;
select any te_prefix from instances of TE_PREFIX;
select any te_set from instances of TE_SET;
select any te_typemap from instances of TE_TYPEMAP;
select any te_instance from instances of TE_INSTANCE;
te_extent.sets_type = te_set.base_class;
te_extent.type = te_prefix.result + "Extent_t";
te_extent.active = "active";
te_extent.inactive = "inactive";
te_extent.size_type = te_typemap.object_size_name;
te_extent.istate_type = te_typemap.state_number_name;
te_extent.istate_name = "initial_state";
te_extent.container_type = te_set.element_type + "*";
te_extent.container_name = "container";
te_extent.pool_type = te_instance.handle;
te_extent.pool_name = "pool";
te_extent.population_type = te_typemap.instance_index_name;
te_extent.population_name = "population";
te_extent.rstorsize_type = te_typemap.object_size_name;
te_extent.rstorsize_name = "size_no_rel";
te_extent.linkfunc_name = "link_function";
te_extent.size_name = "size";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("418f2390-aecd-455c-bc05-e664612f8b1e",
	"ffb2ef9c-41f7-416d-9748-91107c2baf9b",
	'te_extent',
	"1f3bdad1-ec0f-48e9-8084-9a44d3c52a99",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("1f3bdad1-ec0f-48e9-8084-9a44d3c52a99",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<extent>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("ffb2ef9c-41f7-416d-9748-91107c2baf9b",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b52eed47-6e59-4bc1-a159-2b9e7243889a",
	"00000000-0000-0000-0000-000000000000",
	'file_factory',
	'',
	'//
//
te_file = param.te_file;
select any te_prefix from instances of TE_PREFIX;
te_file.hdr_file_ext = "h";
te_file.src_file_ext = "c";
te_file.sys_main = te_prefix.file + "sys_main";
te_file.factory = te_prefix.file + "sys_xtuml";
te_file.events = te_prefix.file + "sys_events";
te_file.obj_file_ext = "o";
te_file.nvs = te_prefix.file + "sys_nvs";
te_file.sets = te_prefix.file + "sys_sets";
te_file.types = te_prefix.file + "sys_types";
te_file.thread = te_prefix.file + "sys_thread";
te_file.trace = te_prefix.file + "sys_trace";
te_file.tim = te_prefix.file + "TIM_bridge";
te_file.callout = te_prefix.file + "sys_user_co";
te_file.ilb = te_prefix.file + "sys_ilb";
te_file.persist = te_prefix.file + "sys_persist";
te_file.xtumlload = te_prefix.file + "sys_xtumlload";
te_file.interfaces = te_prefix.file + "sysc_interfaces";
te_file.registers = te_prefix.file + "RegDefs";
te_file.domain_color_path = ".";
te_file.domain_source_path = "_ch";
te_file.domain_include_path = "_ch";
te_file.system_source_path = "_ch";
te_file.system_include_path = "_ch";
te_file.system_color_path = ".";
te_file.system_mark = "system.mark";
te_file.datatype_mark = "datatype.mark";
te_file.event_mark = "event.mark";
te_file.class_mark = "class.mark";
te_file.domain_mark = "domain.mark";
te_file.system_functions_mark = "sys_functions.arc";
te_file.bridge_mark = "bridge.mark";
te_file.nvs_bridge = te_prefix.file + "NVS_bridge";
te_file.arc_path = "mc3020/arc";
te_file.root_path = ".";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("c3a484e3-6d54-40ba-a2b4-0275741de67d",
	"b52eed47-6e59-4bc1-a159-2b9e7243889a",
	'te_file',
	"0036820d-a4f4-4951-aaba-f90c9abe57f1",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("0036820d-a4f4-4951-aaba-f90c9abe57f1",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<file>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("b52eed47-6e59-4bc1-a159-2b9e7243889a",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("625fdd9f-2c71-4df6-8267-716c9882326c",
	"00000000-0000-0000-0000-000000000000",
	'instance_factory',
	'',
	'//
//
te_instance = param.te_instance;
select any te_prefix from instances of TE_PREFIX;
te_instance.scope = "";
te_instance.create = te_prefix.result + "CreateInstance";
te_instance.create_persistent = te_prefix.result + "CreatePersistent";
te_instance.delete = te_prefix.result + "DeleteInstance";
te_instance.delete_persistent = te_prefix.result + "DeletePersistent";
te_instance.self = "self";
te_instance.global_self = te_prefix.result + "GetSelf";
te_instance.base = te_prefix.result + "InstanceBase_t";
te_instance.handle = te_prefix.result + "iHandle_t";
te_instance.factory_init = te_prefix.result + "ClassFactoryInit";
te_instance.get_dci = te_prefix.result + "GetDCI";
te_instance.get_event_dispatcher = te_prefix.result + "GetEventDispatcher";
te_instance.get_thread_assignment = te_prefix.result + "GetThreadAssignment";
te_instance.base_class = te_prefix.result + "Object_s";
te_instance.max_extent = te_prefix.define_u + "SYS_MAX_OBJECT_EXTENT";
te_instance.max_association_extent = te_prefix.define_u + "SYS_MAX_ASSOCIATION_EXTENT";
te_instance.max_transient_extent = te_prefix.define_u + "SYS_MAX_TRANSIENT_EXTENT";
te_instance.current_state = "current_state";
te_instance.module = "";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("b14fc7fa-e395-4512-98c3-169dd10627dc",
	"625fdd9f-2c71-4df6-8267-716c9882326c",
	'te_instance',
	"f0202e24-f724-4165-9b1f-c61a34457bc8",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("f0202e24-f724-4165-9b1f-c61a34457bc8",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<instance>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("625fdd9f-2c71-4df6-8267-716c9882326c",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("6d9e20a2-a006-4548-acfb-8b788fe92f89",
	"00000000-0000-0000-0000-000000000000",
	'ilb_factory',
	'',
	'//
//
te_ilb = param.te_ilb;
select any te_prefix from instances of TE_PREFIX;
te_ilb.file = "sys_ilb";
te_ilb.interleave_bridge = "InterleaveBridge";
te_ilb.define_name = te_prefix.define_u + "SYS_MAX_INTERLEAVED_BRIDGES";
te_ilb.data_define_name = te_prefix.define_u + "SYS_MAX_INTERLEAVED_BRIDGE_DATA";
te_ilb.interleave_bridge_done = "InterleaveBridgeDone";
te_ilb.get_data = "GetILBData";
te_ilb.dispatch = "DispatchInterleaveBridge";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("ce05f6a1-5004-43dd-b37b-20b171086e1a",
	"6d9e20a2-a006-4548-acfb-8b788fe92f89",
	'te_ilb',
	"9607434a-e180-4f6f-bfad-1014845a2102",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("9607434a-e180-4f6f-bfad-1014845a2102",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<interleaved bridge>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("6d9e20a2-a006-4548-acfb-8b788fe92f89",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("9a0544d6-d498-4297-8567-57888a8f56fe",
	"00000000-0000-0000-0000-000000000000",
	'persist_factory',
	'',
	'//
//
te_persist = param.te_persist;
select any te_prefix from instances of TE_PREFIX;
select any te_typemap from instances of TE_TYPEMAP;
te_persist.class_union = "";
te_persist.instance_cache_depth = te_prefix.define_u + "PERSIST_INST_CACHE_DEPTH";
te_persist.check_mark = "check_mark_post";
te_persist.post_link = "";
te_persist.link_type_name = te_prefix.type + "link_t";
te_persist.persist_file = "sys_persist";
te_persist.factory_init = te_prefix.result + "PersistFactoryInit";
te_persist.commit = te_prefix.result + "PersistenceCommit";
te_persist.restore = te_prefix.result + "PersistenceRestore";
te_persist.remove = te_prefix.result + "PersistDelete";
te_persist.link_cache_depth = te_prefix.define_u + "PERSIST_LINK_CACHE_DEPTH";
// Return the name of the extended attribute variable for use by
// the persistent restore operation.  This attribute represents the
// instance index of the class extent at time of persistent stowage
// together with the class number (across domains) of the class.
// Also return the types for this attribute variable.
te_persist.domainnum_name = "domainnum";
te_persist.domainnum_type = te_typemap.domain_number_name;
te_persist.classnum_name = "classnum";
te_persist.classnum_type = te_typemap.object_number_name;
te_persist.index_name = "index";
te_persist.index_type = te_typemap.instance_index_name;
te_persist.instid_type = "InstanceIdentifier_t";
te_persist.instid_name = "instance_identifier";
te_persist.dirty_type = "s1_t";
te_persist.dirty_name = "persist_dirty";
te_persist.dirty_dirty = 1;
te_persist.dirty_clean = 0;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("1c871a56-4dd0-4312-9385-5b2eb727a932",
	"9a0544d6-d498-4297-8567-57888a8f56fe",
	'te_persist',
	"64c42b53-ed69-45a1-b7de-39fa11bfa5de",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("64c42b53-ed69-45a1-b7de-39fa11bfa5de",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<persistence>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("9a0544d6-d498-4297-8567-57888a8f56fe",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("707c30b7-58f5-4a8f-85af-a1cae797f2b8",
	"00000000-0000-0000-0000-000000000000",
	'prefix_factory',
	'',
	'//
//
te_prefix = param.te_prefix;
te_prefix.symbol = "Escher_";
te_prefix.type = "Escher_";
te_prefix.define_u = "ESCHER_";
te_prefix.define_c = "Escher_";
te_prefix.symbolsw = "";
te_prefix.typesw = "";
te_prefix.result = "Escher_";
te_prefix.define_csw = "";
te_prefix.define_usw = "";
te_prefix.file = "";
te_prefix.provided_port = "pport_";
te_prefix.required_port = "rport_";
te_prefix.channel = "channel_";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("9e9a2858-c1a0-49e6-a334-37818950c5b0",
	"707c30b7-58f5-4a8f-85af-a1cae797f2b8",
	'te_prefix',
	"3afdbefc-08c0-46d7-8e35-39767bc796a8",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("3afdbefc-08c0-46d7-8e35-39767bc796a8",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<prefix>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("707c30b7-58f5-4a8f-85af-a1cae797f2b8",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("bb1fb079-95c3-43ff-b0c8-d842a733df86",
	"00000000-0000-0000-0000-000000000000",
	'relinfo_factory',
	'',
	'//
//
te_relinfo = param.te_relinfo;
te_relinfo.multiplicity = 0;
te_relinfo.rel_phrase = "";
te_relinfo.is_formalizer = false;
te_relinfo.is_supertype = false;
te_relinfo.generate_subtype = false;
te_relinfo.gen_declaration = false;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("4768d9d0-b83d-46a8-8130-5a23885c8e66",
	"bb1fb079-95c3-43ff-b0c8-d842a733df86",
	'te_relinfo',
	"4ac9e914-7a2d-42a4-afbb-979afa290813",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("4ac9e914-7a2d-42a4-afbb-979afa290813",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<relationship information>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("bb1fb079-95c3-43ff-b0c8-d842a733df86",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("ff036ff2-0f7e-4fbd-bca2-a7ba10763cf5",
	"00000000-0000-0000-0000-000000000000",
	'relstore_factory',
	'',
	'//
//
te_relstore = param.te_relstore;
te_relstore.data_init = "";
te_relstore.link_calls = "";
te_relstore.link_index = 0;
te_relstore.data_fini = "";
te_relstore.self_name = "self";
te_relstore.data_declare = "";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("faf5109b-bd9b-4cc6-b4df-b36d4dbf02e4",
	"ff036ff2-0f7e-4fbd-bca2-a7ba10763cf5",
	'te_relstore',
	"e0eff310-4301-4d0e-892a-5e44db181c35",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("e0eff310-4301-4d0e-892a-5e44db181c35",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<relationship storage>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("ff036ff2-0f7e-4fbd-bca2-a7ba10763cf5",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("3ba0d8d5-6dfb-4bf0-b4e2-29fcbaddcc05",
	"00000000-0000-0000-0000-000000000000",
	'set_factory',
	'',
	'//
//
te_set = param.te_set;
select any te_prefix from instances of TE_PREFIX;
te_set.module = "";
te_set.copy = te_prefix.result + "CopySet";
te_set.clear = te_prefix.result + "ClearSet";
te_set.insert_element = te_prefix.result + "SetInsertElement";
te_set.element_count = te_prefix.result + "SetCardinality";
te_set.iterator_class_name = te_prefix.result + "Iterator_s";
te_set.number_of_containoids = te_prefix.define_usw + "SYS_MAX_CONTAINERS";
te_set.factory = te_prefix.result + "SetFactoryInit";
te_set.insert_block = te_prefix.result + "SetInsertBlock";
te_set.remove_instance = te_prefix.result + "SetRemoveInstance";
te_set.contains = te_prefix.result + "SetContains";
te_set.equality = te_prefix.result + "SetEquality";
te_set.init = te_prefix.result + "InitSet";
te_set.insert_instance = te_prefix.result + "SetInsertInstance";
te_set.emptiness = te_prefix.result + "SetIsEmpty";
te_set.get_any = te_prefix.result + "SetGetAny";
te_set.remove_element = te_prefix.result + "SetRemoveElement";
te_set.iterator_reset = te_prefix.result + "IteratorReset";
te_set.iterator_next = te_prefix.result + "IteratorNext";
te_set.base_class = te_prefix.result + "ObjectSet_s";
te_set.element_type = te_prefix.result + "SetElement_s";
te_set.scope = "";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("f054689c-878f-4164-97b1-7099e451a119",
	"3ba0d8d5-6dfb-4bf0-b4e2-29fcbaddcc05",
	'te_set',
	"acfc1b52-78f3-4f68-9025-f05d65609d43",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("acfc1b52-78f3-4f68-9025-f05d65609d43",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<set>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("3ba0d8d5-6dfb-4bf0-b4e2-29fcbaddcc05",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("aeade582-54e1-4082-84b9-95892a8d205f",
	"00000000-0000-0000-0000-000000000000",
	'slist_factory',
	'',
	'//
//
te_slist = param.te_slist;
select any te_prefix from instances of TE_PREFIX;
te_slist.remove_node = te_prefix.result + "SetRemoveNode";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("3dae9226-8317-43db-bdb8-5960005f3bf6",
	"aeade582-54e1-4082-84b9-95892a8d205f",
	'te_slist',
	"976fc510-71b7-4ace-b099-c840dff5f3de",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("976fc510-71b7-4ace-b099-c840dff5f3de",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<slist>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("aeade582-54e1-4082-84b9-95892a8d205f",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("c575b323-8ee7-4e8f-8090-842da4dd5121",
	"00000000-0000-0000-0000-000000000000",
	'string_factory',
	'',
	'//
//
te_string = param.te_string;
select any te_prefix from instances of TE_PREFIX;
te_string.memset = te_prefix.result + "memset";
te_string.memmove = te_prefix.result + "memmove";
te_string.strcpy = te_prefix.result + "strcpy";
te_string.stradd = te_prefix.result + "stradd";
te_string.strlen = te_prefix.result + "strlen";
te_string.itoa = te_prefix.result + "itoa";
te_string.atoi = te_prefix.result + "atoi";
te_string.strcmp = te_prefix.result + "strcmp";
te_string.strget = te_prefix.result + "strget";
te_string.max_string_length = te_prefix.define_u + "SYS_MAX_STRING_LEN";
te_string.debug_buffer_depth = te_prefix.define_u + "DEBUG_BUFFER_DEPTH";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("89633d04-6a23-4429-9b5c-f1742dde837b",
	"c575b323-8ee7-4e8f-8090-842da4dd5121",
	'te_string',
	"950366c4-a10b-4518-8cdb-3dc0f89902cc",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("950366c4-a10b-4518-8cdb-3dc0f89902cc",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<string>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("c575b323-8ee7-4e8f-8090-842da4dd5121",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("eec7a0df-6361-4559-a705-922641540ea8",
	"00000000-0000-0000-0000-000000000000",
	'thread_factory',
	'',
	'//
//
te_thread = param.te_thread;
select any te_prefix from instances of TE_PREFIX;
te_thread.file = "sys_thread";
te_thread.mutex_lock = te_prefix.result + "mutex_lock";
te_thread.mutex_unlock = te_prefix.result + "mutex_unlock";
te_thread.nonbusy_wait = te_prefix.result + "nonbusy_wait";
te_thread.nonbusy_wake = te_prefix.result + "nonbusy_wake";
te_thread.shutdown = te_prefix.result + "thread_shutdown";
te_thread.create = te_prefix.result + "thread_create";
te_thread.enabled = false;
te_thread.flavor = "POSIX";
te_thread.serialize = false;
te_thread.number_of_threads = 1;
te_thread.extra_initialization = "";
te_thread.AUTOSAR_enabled = te_prefix.define_usw + "AUTOSAR_ENABLED";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("f7d482e9-3573-4674-832b-3d23388f8817",
	"eec7a0df-6361-4559-a705-922641540ea8",
	'te_thread',
	"11e51b45-1939-4fba-8271-981f25fb85e0",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("11e51b45-1939-4fba-8271-981f25fb85e0",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<thread>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("eec7a0df-6361-4559-a705-922641540ea8",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("627fbf1b-d164-4c1c-8db5-df4bf1d693f2",
	"00000000-0000-0000-0000-000000000000",
	'tim_factory',
	'',
	'//
//
te_tim = param.te_tim;
select any te_prefix from instances of TE_PREFIX;
te_tim.max_timers = te_prefix.define_u + "SYS_MAX_XTUML_TIMERS";
te_tim.keyed_timer_support = false;
te_tim.recurring_timer_support = true;
te_tim.internal_type = "ETimer_t";
te_tim.timer_event_search_and_destroy = false;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("b2a4dff2-cfda-496e-b157-549d03d96301",
	"627fbf1b-d164-4c1c-8db5-df4bf1d693f2",
	'te_tim',
	"64135dee-0504-4c8d-b94c-4103b7459fc0",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("64135dee-0504-4c8d-b94c-4103b7459fc0",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<timer>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("627fbf1b-d164-4c1c-8db5-df4bf1d693f2",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b3f5d27c-650b-4af9-9e8b-37520ef8377d",
	"00000000-0000-0000-0000-000000000000",
	'typemap_factory',
	'',
	'//
//
te_typemap = param.te_typemap;
select any te_prefix from instances of TE_PREFIX;
te_typemap.instance_index_name = te_prefix.result + "InstanceIndex_t";
te_typemap.instance_index_type = "u2_t";
te_typemap.object_size_name = te_prefix.type + "ClassSize_t";
te_typemap.object_size_type = "u2_t";
te_typemap.object_number_name = te_prefix.type + "ClassNumber_t";
te_typemap.object_number_type = "u2_t";
te_typemap.state_number_name = te_prefix.type + "StateNumber_t";
te_typemap.state_number_type = "u1_t";
te_typemap.domain_number_name = te_prefix.type + "DomainNumber_t";
te_typemap.domain_number_type = "u1_t";
te_typemap.event_number_name = te_prefix.type + "EventNumber_t";
te_typemap.event_number_type = "u1_t";
te_typemap.event_priority_name = te_prefix.type + "EventPriority_t";
te_typemap.event_priority_type = "u1_t";
te_typemap.event_flags_name = te_prefix.type + "EventFlags_t";
te_typemap.event_flags_type = "u1_t";
te_typemap.poly_return_name = te_prefix.type + "PolyEventRC_t";
te_typemap.poly_return_type = "u1_t";
te_typemap.SEM_cell_type = "u1_t";
te_typemap.SEM_cell_name = te_prefix.type + "SEMcell_t";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("b6f83465-a2e5-434c-ba79-be4822afe4f2",
	"b3f5d27c-650b-4af9-9e8b-37520ef8377d",
	'te_typemap',
	"d98a6bae-7ee6-42d2-a8a1-2f809cba7b82",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("d98a6bae-7ee6-42d2-a8a1-2f809cba7b82",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<type map>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("b3f5d27c-650b-4af9-9e8b-37520ef8377d",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("7d45b89e-5a5e-48d2-bc86-5ef518c49716",
	"00000000-0000-0000-0000-000000000000",
	'callout_factory',
	'',
	'//
//
te_callout = param.te_callout;
select any te_prefix from instances of TE_PREFIX;
te_callout.initialization = te_prefix.symbolsw + "UserInitializationCallout";
te_callout.pre_xtUML_initialization = te_prefix.symbolsw + "UserPreOoaInitializationCallout";
te_callout.post_xtUML_initialization = te_prefix.symbolsw + "UserPostOoaInitializationCallout";
te_callout.background_processing = te_prefix.symbolsw + "UserBackgroundProcessingCallout";
te_callout.pre_shutdown = te_prefix.symbolsw + "UserPreShutdownCallout";
te_callout.event_no_instance = te_prefix.symbolsw + "UserEventNoInstanceCallout";
te_callout.event_free_list_empty = te_prefix.symbolsw + "UserEventFreeListEmptyCallout";
te_callout.object_pool_empty = te_prefix.symbolsw + "UserObjectPoolEmptyCallout";
te_callout.node_list_empty = te_prefix.symbolsw + "UserNodeListEmptyCallout";
te_callout.interleaved_bridge_overflow = te_prefix.symbolsw + "UserInterleavedBridgeOverflowCallout";
te_callout.self_event_queue_empty = te_prefix.symbolsw + "UserSelfEventQueueEmptyCallout";
te_callout.non_self_event_queue_empty = te_prefix.symbolsw + "UserNonSelfEventQueueEmptyCallout";
te_callout.persistence_error = te_prefix.symbolsw + "UserPersistenceErrorCallout";
te_callout.file = "sys_user_co";
te_callout.post_shutdown = te_prefix.symbolsw + "UserPostShutdownCallout";
te_callout.event_cant_happen = te_prefix.symbolsw + "UserEventCantHappenCallout";
te_callout.empty_handle_detected = te_prefix.symbolsw + "UserEmptyHandleDetectedCallout";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("1ebc0290-d7ba-40ba-8eca-1872fef9924c",
	"7d45b89e-5a5e-48d2-bc86-5ef518c49716",
	'te_callout',
	"93f43d4c-fd60-4b31-97f4-e74103f19dc9",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("93f43d4c-fd60-4b31-97f4-e74103f19dc9",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<user callout>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("7d45b89e-5a5e-48d2-bc86-5ef518c49716",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("e24bc245-8400-4427-9b19-2c4f1c02c60c",
	"00000000-0000-0000-0000-000000000000",
	'trace_factory',
	'',
	'//
//
te_trace = param.te_trace;
select any te_prefix from instances of TE_PREFIX;
te_trace.component_msg_start = te_prefix.define_usw + "COMP_MSG_START_TRACE";
te_trace.component_msg_end = te_prefix.define_usw + "COMP_MSG_END_TRACE";
te_trace.state_txn_start = te_prefix.define_usw + "STATE_TXN_START_TRACE";
te_trace.oal_trace = te_prefix.define_usw + "OAL_ACTION_TRACE";
te_trace.state_txn_end = te_prefix.define_usw + "STATE_TXN_END_TRACE";
te_trace.state_txn_event_ignored = te_prefix.define_usw + "STATE_TXN_IG_TRACE";
te_trace.state_txn_cant_happen = te_prefix.define_usw + "STATE_TXN_CH_TRACE";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("0b0bd739-a657-44bd-af20-c13165192f84",
	"e24bc245-8400-4427-9b19-2c4f1c02c60c",
	'te_trace',
	"1aa80d4d-ce32-4473-9aa3-f54ad1ca398e",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("1aa80d4d-ce32-4473-9aa3-f54ad1ca398e",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<trace>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("e24bc245-8400-4427-9b19-2c4f1c02c60c",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("1262dae0-e163-4651-a3a4-c6e6dbba77a2",
	"00000000-0000-0000-0000-000000000000",
	'target_factory',
	'',
	'//
te_target = param.te_target;
te_target.language = "C";
te_target.c2cplusplus_linkage_begin = "#ifdef\t__cplusplus\nextern\t&quot;C&quot;\t{\n#endif";
te_target.c2cplusplus_linkage_end = "#ifdef\t__cplusplus\n}\n#endif";
te_target.main = "main";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("aa0f3bb4-4129-4965-8c23-3fa71e9876f5",
	"1262dae0-e163-4651-a3a4-c6e6dbba77a2",
	'te_target',
	"87352925-0272-4445-84b6-d8c3f983377f",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("87352925-0272-4445-84b6-d8c3f983377f",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<target>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("1262dae0-e163-4651-a3a4-c6e6dbba77a2",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("53ee2e57-47e1-41c6-b381-140dab9f94ce",
	"00000000-0000-0000-0000-000000000000",
	'sys_singletons',
	'',
	'//
create object instance te_prefix of TE_PREFIX;
::prefix_factory( te_prefix:te_prefix );
create object instance te_typemap of TE_TYPEMAP;
::typemap_factory( te_typemap:te_typemap );
create object instance te_container of TE_CONTAINER;
::container_factory( te_container:te_container );
create object instance te_copyright of TE_COPYRIGHT;
::copyright_factory( te_copyright:te_copyright );
create object instance te_dlist of TE_DLIST;
::dlist_factory( te_dlist:te_dlist );
create object instance te_dma of TE_DMA;
::dma_factory( te_dma:te_dma );
create object instance te_eq of TE_EQ;
::eq_factory( te_eq:te_eq );
create object instance te_file of TE_FILE;
::file_factory( te_file:te_file );
create object instance te_instance of TE_INSTANCE;
::instance_factory( te_instance:te_instance );
create object instance te_ilb of TE_ILB;
::ilb_factory( te_ilb:te_ilb );
create object instance te_persist of TE_PERSIST;
::persist_factory( te_persist:te_persist );
create object instance te_relinfo of TE_RELINFO;
::relinfo_factory( te_relinfo:te_relinfo );
create object instance te_relstore of TE_RELSTORE;
::relstore_factory( te_relstore:te_relstore );
create object instance te_set of TE_SET;
::set_factory( te_set:te_set );
create object instance te_slist of TE_SLIST;
::slist_factory( te_slist:te_slist );
create object instance te_string of TE_STRING;
::string_factory( te_string:te_string );
create object instance te_thread of TE_THREAD;
::thread_factory( te_thread:te_thread );
create object instance te_tim of TE_TIM;
::tim_factory( te_tim:te_tim );
create object instance te_callout of TE_CALLOUT;
::callout_factory( te_callout:te_callout );
create object instance te_trace of TE_TRACE;
::trace_factory( te_trace:te_trace );
create object instance te_extent of TE_EXTENT;
::extent_factory( te_extent:te_extent );
create object instance te_target of TE_TARGET;
::target_factory( te_target:te_target );
//
create object instance te_assign of TE_ASSIGN;
create object instance te_create_instance of TE_CREATE_INSTANCE;
create object instance te_for of TE_FOR;
create object instance te_if of TE_IF;
create object instance te_while of TE_WHILE;
create object instance te_elif of TE_ELIF;
create object instance te_delete_instance of TE_DELETE_INSTANCE;
create object instance te_create_event of TE_CREATE_EVENT;
create object instance te_relate of TE_RELATE;
create object instance te_relate_using of TE_RELATE_USING;
create object instance te_unrelate of TE_UNRELATE;
create object instance te_unrelate_using of TE_UNRELATE_USING;
create object instance te_select of TE_SELECT;
create object instance te_select_where of TE_SELECT_WHERE;
create object instance te_generate_precreated_event of TE_GENERATE_PRECREATED_EVENT;
create object instance te_event_parameters of TE_EVENT_PARAMETERS;
create object instance te_generate of TE_GENERATE;
create object instance te_generate_creator_event of TE_GENERATE_CREATOR_EVENT;
create object instance te_generate_to_class of TE_GENERATE_TO_CLASS;
create object instance te_sgn of TE_SGN;
create object instance te_iop of TE_IOP;
create object instance te_operation of TE_OPERATION;
create object instance te_bridge of TE_BRIDGE;
create object instance te_function of TE_FUNCTION;
create object instance te_return of TE_RETURN;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("53ee2e57-47e1-41c6-b381-140dab9f94ce",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("3c350f0c-5e01-429c-b4ff-1222afd3f466",
	"00000000-0000-0000-0000-000000000000",
	'GetBaseTypeForUDT',
	'',
	'//============================================================================
// $RCSfile: q.datatype.arc,v $
//
// Notice:
// (C) Copyright 1998-2013 Mentor Graphics Corporation
//     All rights reserved.
//
// This document contains confidential and proprietary information and
// property of Mentor Graphics Corp.  No part of this document may be
// reproduced without the express written permission of Mentor Graphics Corp.
//============================================================================
//
//
//============================================================================
// Recursively locate the datatype at the base of the UDT type definition 
// chain. Traverses up through UDTs based on UDTs until we find the underlying
// S_DT instance (which may actually be EDT, SDT, IRDT or CDT).
//============================================================================
s_udt = param.s_udt;
select one s_dt related by s_udt->S_DT[R18];
select one s_udt related by s_dt->S_UDT[R17];
if ( not_empty s_udt )
  r = ::GetBaseTypeForUDT( s_udt:s_udt );
  s_dt = r;
end if;
return s_dt;
',
	"3f421b34-9cdd-4a99-947a-7224e3b97776",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("4f508d09-0d8a-4cd1-8161-5964eaae3ee2",
	"3c350f0c-5e01-429c-b4ff-1222afd3f466",
	's_udt',
	"fbb3cc5a-c0d2-405d-a9fd-46fcd925a160",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("fbb3cc5a-c0d2-405d-a9fd-46fcd925a160",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<User Data Type>',
	'',
	'',
	'../Domain/Domain.xtuml');
INSERT INTO PE_PE
	VALUES ("3c350f0c-5e01-429c-b4ff-1222afd3f466",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_DT_PROXY
	VALUES ("3f421b34-9cdd-4a99-947a-7224e3b97776",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Data Type>',
	'',
	'',
	'../Instance Reference Data Types/Instance Reference Data Types.xtuml');
INSERT INTO S_SYNC
	VALUES ("0f7f3c2c-071c-4986-969d-46b144e167b5",
	"00000000-0000-0000-0000-000000000000",
	'GetAttributeCodeGenType',
	'',
	'//
//============================================================================
//   Get the S_DT and S_CDT object references for a given attribute
//   (O_ATTR) instance.
//============================================================================
o_attr = param.o_attr;
//
select one s_dt related by o_attr->S_DT[R114];
select one s_udt related by s_dt->S_UDT[R17];
if ( not_empty s_udt )
  r = ::GetBaseTypeForUDT( s_udt:s_udt );
  s_dt = r;
end if;
select one te_dt related by s_dt->TE_DT[R2021];
select one s_cdt related by s_dt->S_CDT[R17];
//
if ( empty s_cdt )
  select one s_edt related by s_dt->S_EDT[R17];
  if ( empty s_edt )
    select one s_sdt related by s_dt->S_SDT[R17];
    if ( empty s_sdt )
      select one s_irdt related by s_dt->S_IRDT[R17];
      if ( empty s_irdt )
        T::print(s:"Error in attribute T::s(i:o_attr.Name)");
        T::print(s:"with data type T::s(i:s_dt.Name)");
        T::exit(i:100);
      end if;
    end if;
  else
    // Enum, use integer type.
    // CDS Some day we should pass along the enumeration type.
    select any s_cdt from instances of S_CDT where ( selected.Core_Typ == 2 );
  end if;
end if;
//
if ( not_empty s_cdt )
  if ( 7 == s_cdt.Core_Typ )
    // s_cdt.Core_Typ is "same_as<Base_Attribute>"
    select one base_o_attr related by o_attr->O_RATTR[R106]->O_BATTR[R113]->O_ATTR[R106];
    if ( empty base_o_attr )
      select one o_obj related by o_attr->O_OBJ[R102];
      T::print(s:"\nCould not find O_BATTR for object T::s(i:o_obj.Name) (T::s(i:o_obj.Key_Lett)) attribute T::s(i:o_attr.Name) !");
      T::print(s:"\nDid you combine a referential and then rename the combined attribute?");
      T::exit(i:101);
    end if;
    // Note: the following is a recursive call to this function
    r = ::GetAttributeCodeGenType( o_attr:base_o_attr );
    te_dt = r;
  end if;
end if;
return te_dt;
',
	"5b20f7fb-179b-4254-a8de-922a50a1225d",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("f739cf4b-eeda-4d9d-bc0b-616139b25115",
	"0f7f3c2c-071c-4986-969d-46b144e167b5",
	'o_attr',
	"f597d699-ee8c-4635-9196-5082b710160d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("f597d699-ee8c-4635-9196-5082b710160d",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Attribute>',
	'',
	'',
	'../Instance Reference Data Types/Instance Reference Data Types.xtuml');
INSERT INTO PE_PE
	VALUES ("0f7f3c2c-071c-4986-969d-46b144e167b5",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_DT_PROXY
	VALUES ("5b20f7fb-179b-4254-a8de-922a50a1225d",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Data Type>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO S_SYNC
	VALUES ("d9566656-e3cd-46e1-9c44-0acfee782e19",
	"00000000-0000-0000-0000-000000000000",
	'MapUserSpecifiedDataTypePrecision',
	'',
	'//
//============================================================================
// Map a user defined data types precision into its corresponding instance
// of Data Type (S_DT).
// Note:  Might prefer POSIX type support here, but doubt we can count
// on most embedded targets thinking this way.  Thus brute force the types.
//============================================================================
te_dt = param.te_dt;
mapping = param.mapping;
error = false;
type = mapping;
if ( ( type == "uchar_t" ) or ( ( type == "u_char" ) or ( type == "unsignedchar" ) ) )
  te_dt.ExtName = "unsigned char";
elif ( ( type == "char_t" ) or ( type == "char" ) )
  te_dt.ExtName = "char";
elif ( type == "signedchar" )
  te_dt.ExtName = "signed char";
elif ( ( type == "ushort_t" ) or ( ( type == "u_short" ) or ( type == "unsignedshort" ) ) )
  te_dt.ExtName = "unsigned short";
elif ( ( type == "short_t" ) or ( type == "short" ) )
  te_dt.ExtName = "short";
elif ( type == "signedshort" )
  te_dt.ExtName = "signed short";
elif ( ( type == "uint_t" ) or ( ( type == "u_int" ) or ( type == "unsignedint" ) ) )
  te_dt.ExtName = "unsigned int";
elif ( type == "s1_t" )
  te_dt.ExtName = "s1_t";
elif ( type == "u1_t" )
  te_dt.ExtName = "u1_t";
elif ( type == "s2_t" )
  te_dt.ExtName = "s2_t";
elif ( type == "u2_t" )
  te_dt.ExtName = "u2_t";
elif ( type == "s4_t" )
  te_dt.ExtName = "s4_t";
elif ( type == "u4_t" )
  te_dt.ExtName = "u4_t";
elif ( type == "i_t" )
  te_dt.ExtName = "i_t";
elif ( ( type == "int_t" ) or ( type == "int" ) )
  te_dt.ExtName = "int";
elif ( type == "signedint" )
  te_dt.ExtName = "signed int";
elif ( ( type == "ulong_t" ) or ( ( type == "u_long" ) or ( type == "unsignedlong" ) ) )
  te_dt.ExtName = "unsigned long";
elif ( ( type == "long_t" ) or ( type == "long" ) )
  te_dt.ExtName = "long";
elif ( type == "signedlong" )
  te_dt.ExtName = "signed long";
elif ( ( type == "u_longlong_t" ) or ( ( type == "u_longlong_t" ) or ( type == "unsignedlonglong" ) ) )
  te_dt.ExtName = "unsigned long long";
elif ( ( type == "longlong_t" ) or ( ( type == "longlong" ) or ( type == "signedlonglong" ) ) )
  te_dt.ExtName = "long long";
  //
elif ( type == "float" )
  te_dt.ExtName = "float";
elif ( type == "r4_t" )
  te_dt.ExtName = "r4_t";
elif ( type == "double" )
  te_dt.ExtName = "double";
elif ( type == "r8_t" )
  te_dt.ExtName = "r8_t";
  //
elif ( type == "size_t" )
  te_dt.ExtName = "size_t";
elif ( type == "ssize_t" )
  te_dt.ExtName = "ssize_t";
elif ( type == "time_t" )
  te_dt.ExtName = "time_t";
elif ( type == "clock_t" )
  te_dt.ExtName = "clock_t";
elif ( type == "volatile_clock_t" )
  te_dt.ExtName = "volatile unsigned long";
  //
else
  error = true;
end if;
return error;
',
	"ba5eda7a-def5-0000-0000-000000000001",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("00f3fbd2-53fa-4620-bd8f-5f01ccb3a51c",
	"d9566656-e3cd-46e1-9c44-0acfee782e19",
	'te_dt',
	"5b20f7fb-179b-4254-a8de-922a50a1225d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("def39e5b-a389-4c98-8553-e5069f1e596a",
	"d9566656-e3cd-46e1-9c44-0acfee782e19",
	'mapping',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00f3fbd2-53fa-4620-bd8f-5f01ccb3a51c",
	'');
INSERT INTO PE_PE
	VALUES ("d9566656-e3cd-46e1-9c44-0acfee782e19",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("c188e543-61c7-4ce6-a746-de74d5a7372e",
	"00000000-0000-0000-0000-000000000000",
	'UserSuppliedDataTypeIncludes',
	'',
	'//
// Return the structure type for persistent links.
select any te_file from instances of TE_FILE;
sys_types_file_name = ( te_file.types + "." ) + te_file.hdr_file_ext;
select many special_te_dts from instances of TE_DT where ( ( selected.Include_File != "" ) and ( selected.Include_File != sys_types_file_name ) );
s = "";
for each special_te_dt in special_te_dts
  s = ( s + "#include " ) + ( special_te_dt.Include_File + "\n" );
end for;
return s;
',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("c188e543-61c7-4ce6-a746-de74d5a7372e",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a293b67b-bc6c-452e-b2f8-04036fbc9454",
	"00000000-0000-0000-0000-000000000000",
	'te_parm_RenderParameters',
	'',
	'//============================================================================
// $RCSfile: q.parameters.arc,v $
//
// Description:
// Here we deal with parameters.  The declaration, definition and invocation
// renderings are built.
//
// Notice:
// (C) Copyright 1998-2013 Mentor Graphics Corporation
//     All rights reserved.
//
// This document contains confidential and proprietary information and
// property of Mentor Graphics Corp.  No part of this document may be
// reproduced without the express written permission of Mentor Graphics Corp.
//============================================================================
//
//
te_parms = param.te_parms;
te_aba = param.te_aba;
// Consider that we may have additional parameters (like for passing "self").
defn = "";
decl = "";
if ( empty te_parms )
  decl = " void";
end if;
invo = "";
stru = "";
parameter_trace = "";
string_format = "";
assn = "";
assnbase = "";
param_delimiter = " ";
format_delimiter = "";
Order = 0;
// Be sure we have the first parameter.
for each te_parm in te_parms
  break;
end for;
while ( not_empty te_parm )
  select one prev_te_parm related by te_parm->TE_PARM[R2041.''precedes''];
  if ( empty prev_te_parm )
    break;
  else
    te_parm = prev_te_parm;
  end if;
end while;
while ( not_empty te_parm )
  te_parm.Order = Order;
  Order = Order + 1;
  select one te_dt related by te_parm->TE_DT[R2049];
  te_dt.Included = true;
  defn = defn + param_delimiter;
  decl = decl + param_delimiter;
  param_qual = "";
  if ( 0 != te_parm.By_Ref )
    param_qual = param_qual + " *";
  else
    // CDS const correctness goes here
    // Arrays in C are always by ref, so add const to scalars only.
    if ( ( "" == te_parm.array_spec ) and ( ( 1 <= te_dt.Core_Typ ) and ( te_dt.Core_Typ <= 3 ) ) )
      defn = defn + "const ";
      decl = decl + "const ";
    end if;
  end if;
  defn = ( ( defn + te_dt.ExtName ) + ( param_qual + " " ) ) + ( te_parm.GeneratedName + te_parm.array_spec );
  decl = ( ( decl + te_dt.ExtName ) + ( param_qual + te_parm.array_spec ) );
  invo = ( invo + param_delimiter ) + te_parm.GeneratedName;
  stru = ( ( stru + te_dt.ExtName ) + ( param_qual + " " ) ) + ( ( te_parm.GeneratedName + te_parm.array_spec ) + ";\n" );
  if ( ( "" != te_dt.string_format ) and ( "" == te_parm.array_spec ) )
    // Do not trace structures or arrays.
    dereference = "";
    if ( 0 != te_parm.By_Ref )
      dereference = "*";
    end if;
    parameter_trace = ( parameter_trace + ", " ) + ( dereference + te_parm.GeneratedName );
    string_format = ( string_format + format_delimiter ) + te_dt.string_format;
  else
    string_format = ( string_format + format_delimiter ) + "[]";
  end if;
  r = ::t_oal_smt_event_parameters( evt_msg_var:"", parameter:te_parm.Name, value:te_parm.GeneratedName, value_type:te_dt.Core_Typ, ws:"  " );
  assn = assn + r;
  if ( "A00portindex" != te_parm.Name )
    assnbase = assnbase + r;
  end if;
  param_delimiter = ", ";
  format_delimiter = ",";
  select one te_parm related by te_parm->TE_PARM[R2041.''succeeds''];
end while;
if ( "" != defn )
  defn = defn + " ";
end if;
te_aba.ParameterDefinition = defn;
te_aba.ParameterDeclaration = decl + " ";
te_aba.ParameterInvocation = invo;
te_aba.ParameterStructure = stru;
te_aba.ParameterTrace = parameter_trace;
te_aba.ParameterFormat = string_format;
te_aba.ParameterAssignment = assn;
te_aba.ParameterAssignmentBase = assnbase;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("6f30aaa5-621f-489c-86e0-3e90c1b895d6",
	"a293b67b-bc6c-452e-b2f8-04036fbc9454",
	'te_parms',
	"954dc6bb-6e2a-47a5-aa3b-886723803133",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("954dc6bb-6e2a-47a5-aa3b-886723803133",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Extended Parameter>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO S_SPARM
	VALUES ("e50d5aa3-cf30-44fb-9bed-02fbe0d668d4",
	"a293b67b-bc6c-452e-b2f8-04036fbc9454",
	'te_aba',
	"5fb4bb14-9533-4d0c-bec8-44e5e22fbbfd",
	0,
	'',
	"6f30aaa5-621f-489c-86e0-3e90c1b895d6",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("5fb4bb14-9533-4d0c-bec8-44e5e22fbbfd",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Action Block Anchor>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("a293b67b-bc6c-452e-b2f8-04036fbc9454",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("34b725c2-7fa6-4c8a-8e8f-abbdc6e9e972",
	"00000000-0000-0000-0000-000000000000",
	'sys_populate',
	'',
	'//============================================================================
// $RCSfile: q.mc_metamodel.populate.arc,v $
//
// Description:
// This query/transformation archetype file queries the customer model
// and populates the model compiler extensions to the meta-model.
// Instances of the extended classes are created, related and initialized.
//
// Create architectural system-level artifacts first.
// Create leaf-node artifacts (like TE_DT, TE_VAL and TE_PAR) which may need
// to be updated as information is gathered.
// Create component-level artifacts.
// Briefly create and link components, data types.  Select them afterwards.
// Create and link middled-level classes.
// Drill down into component and create object, attributes and the rest.
//
// Notice:
// (C) Copyright 1998-2013 Mentor Graphics Corporation
//     All rights reserved.
//
// This document contains confidential and proprietary information and
// property of Mentor Graphics Corp.  No part of this document may be
// reproduced without the express written permission of Mentor Graphics Corp.
//============================================================================
//
//
// Create the system interfaces (sys, dom, ee).
//
// Select singletons into scope.
select any te_file from instances of TE_FILE;
select any te_eq from instances of TE_EQ;
select any te_extent from instances of TE_EXTENT;
select any te_instance from instances of TE_INSTANCE;
select any te_prefix from instances of TE_PREFIX;
select any te_set from instances of TE_SET;
select any te_string from instances of TE_STRING;
select any te_target from instances of TE_TARGET;
select any te_thread from instances of TE_THREAD;
select any te_tim from instances of TE_TIM;
select any te_typemap from instances of TE_TYPEMAP;
select any empty_cp_cp from instances of CP_CP where ( false );
select many empty_ep_pkgs from instances of EP_PKG where ( false );
select any empty_te_c from instances of TE_C where ( false );
select any empty_te_dim from instances of TE_DIM where ( false );
select any empty_o_obj from instances of O_OBJ where ( false );
select any empty_te_attr from instances of TE_ATTR where ( false );
select any empty_te_mact from instances of TE_MACT where ( false );
select many empty_te_dts from instances of TE_DT where ( false );
select many empty_te_parms from instances of TE_PARM where ( false );
// CDS - Note that in a multiple-system build, we will get lucky, and the
// s_sys from the local project will be selected first.
select any s_sys from instances of S_SYS;
if ( empty s_sys )
  create object instance s_sys of S_SYS;
  s_sys.Name = "sys";
end if;
// Create the system translation extension and relate it.
select any te_sys from instances of TE_SYS;
if ( empty te_sys )
  create object instance te_sys of TE_SYS;
  te_sys.SystemID = 1;
end if;
relate s_sys to te_sys across R2018;
te_sys.Name = T::r(s:s_sys.Name);
if ( "" == te_sys.Name )
  te_sys.Name = "sys";
end if;
te_sys.MaxStringLen = 32;
te_sys.PersistInstanceCacheDepth = 128;
te_sys.PersistLinkCacheDepth = 128;
te_sys.AUTOSAR = false;
te_sys.AllPortsPoly = false;
//
//Updating te_sys with system marks
select any tm_systag from instances of TM_SYSTAG;
if ( not_empty tm_systag )
  te_sys.MaxStringLen = tm_systag.MaxStringLen;
  te_sys.MaxRelExtent = tm_systag.MaxRelExtent;
  te_sys.MaxSelectExtent = tm_systag.MaxSelectExtent;
  te_sys.MaxSelfEvents = tm_systag.MaxSelfEvents;
  te_sys.MaxNonSelfEvents = tm_systag.MaxNonSelfEvents;
  te_sys.MaxTimers = tm_systag.MaxTimers;
  te_sys.MaxInterleavedBridges = tm_systag.MaxInterleavedBridges;
  te_sys.MaxInterleavedBridgeDataSize = tm_systag.MaxInterleavedBridgeDataSize;
  te_sys.CollectionsFlavor = tm_systag.CollectionsFlavor;
  te_sys.PersistInstanceCacheDepth = tm_systag.PersistInstanceCacheDepth;
  te_sys.PersistLinkCacheDepth = tm_systag.PersistLinkCacheDepth;
  te_sys.UnitsToDynamicallyAllocate = tm_systag.UnitsToDynamicallyAllocate;
  te_sys.VFB = tm_systag.VFB;
  te_sys.InstanceLoading = tm_systag.InstanceLoading;
  te_sys.SystemCPortsType = tm_systag.SystemCPortsType;
  te_sys.AllPortsPoly = tm_systag.AllPortsPoly;
else
  te_sys.SystemCPortsType = "sc_interface";
end if;
//
//Update the tasking threads based on marking.
select any tm_thread from instances of TM_THREAD;
if ( not_empty tm_thread )
  te_thread.extra_initialization = tm_thread.extra_initialization;
  te_thread.number_of_threads = tm_thread.number_of_threads;
  te_thread.enabled = tm_thread.enabled;
  te_thread.serialize = tm_thread.serialize;
  te_thread.flavor = tm_thread.flavor;
  if ( "AUTOSAR" == te_thread.flavor )
    te_sys.AUTOSAR = true;
  end if;
end if;
//
select any te_disp from instances of TE_DISP;
if ( empty te_disp )
  create object instance te_disp of TE_DISP;
  te_disp.Dispatcher_ID = 1;
  relate te_disp to te_sys across R2003;
end if;
te_disp.Descrip = "dispatcher";
te_disp.Name = "main";
select any te_queue from instances of TE_QUEUE;
select any nonself_te_queue from instances of TE_QUEUE;
if ( empty te_queue )
  create object instance te_queue of TE_QUEUE;
  te_queue.Queue_ID = 1;
  relate te_queue to te_disp across R2004;
  create object instance nonself_te_queue of TE_QUEUE;
  nonself_te_queue.Queue_ID = 2;
  relate nonself_te_queue to te_disp across R2004;
end if;
// Self Queue
te_queue.Descrip = "Self Queue";
te_queue.RenderCode = false;
te_queue.MaxDepth = 0;
te_queue.Type = 1;
// NonSelf Queue
nonself_te_queue.Descrip = "NonSelf Queue";
nonself_te_queue.RenderCode = false;
nonself_te_queue.MaxDepth = 0;
nonself_te_queue.Type = 2;
//
// Create the (domain) class info array instance.
// CDS - This may end up being part of a component rather than a system.
create object instance te_cia of TE_CIA;
te_cia.class_info_name = "domain_class_info";
te_cia.class_info_type = te_extent.type;
te_cia.active_count = "active_count";
te_cia.class_count = "domain_class_count";
te_cia.count_type = te_typemap.object_number_name;
//
//
// Create the Extended Component instance(s) and link them up.
select many c_cs from instances of C_C;
for each c_c in c_cs
  create object instance te_c of TE_C;
  relate te_c to c_c across R2054;
  relate te_c to te_sys across R2065;
  te_c.Name = T::r(s:c_c.Name);
  te_c.Descrip = c_c.Descrip;
  te_c.included_in_build = true;
    select any tm_c from instances of TM_C where ( selected.Name == c_c.Name );
  if ( not_empty tm_c )
    if ( ( tm_c.isRealized ) or ( c_c.isRealized ) )
      // Component is realized, so skip translation of internals.
      te_c.isRealized = true;
    end if;
  end if;
  te_c.internal_behavior = false;
  te_c.module_file = te_c.Name;
  te_c.port_file = te_c.Name;
  te_c.classes_file = te_c.Name + "_classes";
  te_c.CodeComments = true;
  // Create and relate the domain class info to carry details about
  // class extents for this component.
  create object instance te_dci of TE_DCI;
  relate te_dci to te_c across R2090;
  te_dci.class_numbers = te_c.Name + "_CLASS_NUMBERS";
  te_dci.persist_union = te_c.Name + "_CLASS_U";
  te_dci.task_list = te_c.Name + "_task_numbers";
  te_dci.task_numbers = te_c.Name + "_TASK_NUMBERS";
  te_dci.max = te_c.Name + "_MAX_CLASS_NUMBERS";
  te_dci.max_models = te_c.Name + "_STATE_MODELS";
  te_dci.init = te_c.Name + "_CLASS_INFO_INIT";
  te_dci.array_name = te_c.Name + "_class_info";
  // Create the Component Instance instances.
  select many cl_ics related by c_c->CL_IC[R4201];
  for each cl_ic in cl_ics
    create object instance te_ci of TE_CI;
    te_ci.Name = te_c.Name;
    if ( "" == cl_ic.ClassifierName )
      te_ci.ClassifierName = "i" + te_c.Name;
    else
      te_ci.ClassifierName = T::r(s:cl_ic.ClassifierName);
    end if;
    relate te_ci to te_c across R2008;
    relate te_ci to cl_ic across R2009;
  end for;
  // Create the Extended Ports.
  select many c_pos related by c_c->C_PO[R4010];
  for each c_po in c_pos
    select any c_i related by c_po->C_IR[R4016]->C_I[R4012];
    if ( not_empty c_i )
      create object instance te_po of TE_PO;
      relate te_po to c_po across R2044;
      relate te_po to te_c across R2005;
      relate te_po to c_i across R2007;
      te_po.InterfaceName = T::r(s:c_i.Name);
      select any c_r related by c_po->C_IR[R4016]->C_R[R4009];
      if ( not_empty c_r )
        te_po.Provision = false;
      else
        te_po.Provision = true;
      end if;
      te_po.polymorphic = false;
      te_po.sibling = 0;
      te_po.Name = c_po.Name;
      te_po.GeneratedName = T::r(s:te_po.Name);
      // Create the Interface Instance instances.
      select many c_irs related by c_po->C_IR[R4016];
      for each c_ir in c_irs
        create object instance te_iir of TE_IIR;
                        relate te_iir to c_ir across R2046;
        relate te_iir to te_po across R2080;
        te_iir.component_name = c_c.Name;
        te_iir.port_name = te_po.Name;
        te_iir.interface_name = te_po.InterfaceName;
        te_iir.polymorphic = false;
        select many cl_iirs related by c_ir->CL_IIR[R4701];
        for each cl_iir in cl_iirs
          create object instance te_iir of TE_IIR;
                              relate te_iir to cl_iir across R2013;
          relate te_iir to te_po across R2080;
          te_iir.port_name = te_po.Name;
          te_iir.interface_name = te_po.InterfaceName;
          te_iir.polymorphic = false;
        end for;
      end for;
    end if;
  end for;
  // Identify polymorhic ports.
  // Polymorphic ports exist more than once in the same orientation on a component.
  port_counter = 0;
  select many te_pos related by te_c->TE_PO[R2005];
  for each te_po in te_pos
    te_po.Order = port_counter;
    port_counter = port_counter + 1;
    select many poly_te_pos related by te_po->TE_C[R2005]->TE_PO[R2005] where ( ( ( selected.c_iId == te_po.c_iId ) and ( selected.Provision == te_po.Provision ) ) and ( selected.ID != te_po.ID ) );
    if ( not_empty poly_te_pos )
      // If we have seen this port already, it will be marked as polymorphic.
      // So, no need to iterate marking as not the first sibling.
      if ( not te_po.polymorphic )
        sibling_counter = 1;
        for each poly_te_po in poly_te_pos
          poly_te_po.polymorphic = true;
          poly_te_po.sibling = sibling_counter;
          sibling_counter = sibling_counter + 1;
        end for;
      end if;
      te_po.polymorphic = true;
      // Now mark the related interface reference instances as polymorphic.
      select many te_iirs related by te_po->TE_IIR[R2080];
      for each te_iir in te_iirs
        te_iir.polymorphic = true;
      end for;
    end if;
  end for;
end for;
// Here we force all the ports and interface references to be polymorphic.  
// We do this step via a second loop here so that we could set up the 
// sibling values earlier before all the ports potentially get forced to polymorphic.
// This loop also configures the satisfaction shortcut we create between local and
// foreign interface references.
select many te_pos from instances of TE_PO;
for each te_po in te_pos
  // CDS - review/remove
  if ( te_sys.AllPortsPoly )
    te_po.polymorphic = true;
  end if;
  select many te_iirs related by te_po->TE_IIR[R2080];
  for each te_iir in te_iirs
    // CDS - review/remove
    if ( te_sys.AllPortsPoly )
      te_iir.polymorphic = true;
    end if;
    // Select across the satisfaction to get the related TE_IIR.
    if ( te_po.Provision )
      // provision side first
      // CDS There may be more than one here.
      select any foreign_te_iir related by te_iir->CL_IIR[R2013]->CL_IP[R4703]->CL_IPINS[R4705]->C_SF[R4705]->CL_IR[R4706]->CL_IIR[R4703]->TE_IIR[R2013];
      if ( empty foreign_te_iir )
        // We are dealing with TE_IIRs that may be on non-imported interface references (connected to C_Cs).
        select any foreign_te_iir related by te_iir->C_IR[R2046]->C_P[R4009]->C_SF[R4002]->C_R[R4002]->C_IR[R4009]->TE_IIR[R2046];
        if ( empty foreign_te_iir )
          select any foreign_te_iir related by te_iir->CL_IIR[R2013]->CL_IP[R4703]->CL_IPINS[R4705]->C_SF[R4705]->C_R[R4002]->C_IR[R4009]->TE_IIR[R2046];
          if ( empty foreign_te_iir )
            select any foreign_te_iir related by te_iir->C_IR[R2046]->C_P[R4009]->C_SF[R4002]->CL_IR[R4706]->CL_IIR[R4703]->TE_IIR[R2013];
          end if;
        end if;
      end if;
      if ( not_empty foreign_te_iir )
        relate te_iir to foreign_te_iir across R2081.''provides or is delegated'';
      end if;
    else
      // requirement side first
      select one foreign_te_iir related by te_iir->CL_IIR[R2013]->CL_IR[R4703]->C_SF[R4706]->CL_IPINS[R4705]->CL_IP[R4705]->CL_IIR[R4703]->TE_IIR[R2013];
      if ( empty foreign_te_iir )
        select any foreign_te_iir related by te_iir->C_IR[R2046]->C_R[R4009]->C_SF[R4002]->C_P[R4002]->C_IR[R4009]->TE_IIR[R2046];
        if ( empty foreign_te_iir )
          select one foreign_te_iir related by te_iir->CL_IIR[R2013]->CL_IR[R4703]->C_SF[R4706]->C_P[R4002]->C_IR[R4009]->TE_IIR[R2046];
          if ( empty foreign_te_iir )
            select any foreign_te_iir related by te_iir->C_IR[R2046]->C_R[R4009]->C_SF[R4002]->CL_IPINS[R4705]->CL_IP[R4705]->CL_IIR[R4703]->TE_IIR[R2013];
          end if;
        end if;
      end if;
      if ( not_empty foreign_te_iir )
        relate te_iir to foreign_te_iir across R2081.''requires or delegates'';
      end if;
    end if;
  end for;
end for;
//
// By default, select all components to be translated.  However, if
// a package has been marked, translate only the components contained
// in the package (or referenced from it).
ep_pkgs = empty_ep_pkgs;
cp_cp = empty_cp_cp;
package_to_build = "";
select any tm_build from instances of TM_BUILD;
markedsystems = 0;
if ( not_empty tm_build )
  select many ep_pkgs from instances of EP_PKG where ( selected.Name == tm_build.package_to_build );
  markedsystems = cardinality ep_pkgs;
  if ( empty ep_pkgs )
    T::print(s:"ERROR:  Marked configuration package T::s(i:tm_build.package_to_build) was not found in model.  Exiting.");
    T::exit(i:11);
  end if;
  package_to_build = tm_build.package_to_build;
end if;
if ( markedsystems > 1 )
  T::print(s:"WARNING:  More than one package is marked as a system build... choose only one.");
end if;
if ( "" != package_to_build )
  T::print(s:"Marked configuration package T::s(i:package_to_build) found.");
  select many te_cs from instances of TE_C;
  // Clear the build flag for all components and then mark only those
  // requested by the marking.
  for each te_c in te_cs
    te_c.included_in_build = false;
  end for;
  select many te_cs related by ep_pkgs->PE_PE[R8000]->C_C[R8001]->TE_C[R2054];
  select many nested_te_cs related by ep_pkgs->PE_PE[R8000]->EP_PKG[R8001]->PE_PE[R8000]->C_C[R8001]->TE_C[R2054];
  te_cs = te_cs;
  select many referenced_te_cs related by ep_pkgs->PE_PE[R8000]->CL_IC[R8001]->C_C[R4201]->TE_C[R2054];
  te_cs = te_cs;
  select many nested_referenced_te_cs related by ep_pkgs->PE_PE[R8000]->EP_PKG[R8001]->PE_PE[R8000]->CL_IC[R8001]->C_C[R4201]->TE_C[R2054];
  te_cs = te_cs;
  ::TE_C_mark_nested_system( te_cs:te_cs );
  // Uncomment the line below to use package name instead of project for the top-level files.
  //.assign te_sys.Name = "$r{package_to_build}"
else
  // Here we use the default name for the system derived from the project name.
end if;
te_file.types = ( te_sys.Name + "_" ) + te_file.types;
te_file.sys_main = ( te_sys.Name + "_" ) + te_file.sys_main;
//
// Create and link the Extended model compiler instances.
// Do not fully initialize, yet.  Create and link and mark.
// These artifacts contain important naming that must propagate.
//
// Create the Generated Data Type instances and link them in.
select many s_dts from instances of S_DT;
for each s_dt in s_dts
  create object instance te_dt of TE_DT;
  relate te_dt to s_dt across R2021;
  te_dt.Name = s_dt.Name;
  te_dt.Core_Typ = -1;
  te_dt.string_format = "";
    // Link the ownership if contained in a component.
  te_c = empty_te_c;
  select one ep_pkg related by s_dt->PE_PE[R8001]->EP_PKG[R8000];
  if ( not_empty ep_pkg )
    r = ::TE_C_getContainingComponent( ep_pkg:ep_pkg );
    te_c = r;
  end if;
  if ( empty te_c )
    // Default the owner to be the system.
    te_dt.Owning_Dom_Name = te_sys.Name;
  else
    te_dt.Owning_Dom_Name = te_c.Name;
    relate te_dt to te_c across R2086;
  end if;
end for;
select any converted_bool_te_dt from instances of TE_DT where ( selected.Name == "integer" );
//
select many o_objs from instances of O_OBJ;
for each o_obj in o_objs
  te_c = empty_te_c;
  select one ep_pkg related by o_obj->PE_PE[R8001]->EP_PKG[R8000];
  r = ::TE_C_getContainingComponent( ep_pkg:ep_pkg );
  te_c = r;
  if ( not_empty te_c )
    if ( ( te_c.included_in_build ) and ( not te_c.isRealized ) )
      te_c.internal_behavior = true;
      // Create the Generated Class instance and link it to the real one.
      r1 = ::FactoryTE_CLASS( o_obj:o_obj, te_c:te_c );
      te_class = r1;
    end if;
  end if;
end for;
//
select many s_syncs from instances of S_SYNC;
for each s_sync in s_syncs
  te_c = empty_te_c;
  select one ep_pkg related by s_sync->PE_PE[R8001]->EP_PKG[R8000];
  r = ::TE_C_getContainingComponent( ep_pkg:ep_pkg );
  te_c = r;
  if ( not_empty te_c )
    if ( ( te_c.included_in_build ) and ( not te_c.isRealized ) )
      te_c.internal_behavior = true;
      // Create the Extended Function instance and link it to the real one.
      create object instance te_sync of TE_SYNC;
      relate s_sync to te_sync across R2023;
      relate te_sync to te_c across R2084;
      te_sync.Name = s_sync.Name;
      te_sync.GeneratedName = ( te_c.Name + "_" ) + te_sync.Name;
    end if;
  end if;
end for;
//
select many s_ees from instances of S_EE;
for each s_ee in s_ees
  select one ep_pkg related by s_ee->PE_PE[R8001]->EP_PKG[R8000];
  r = ::TE_C_getContainingComponent( ep_pkg:ep_pkg );
  te_c = r;
  if ( empty te_c )
    // Here we have an EE in a package outside of a component.
    create object instance te_ee of TE_EE;
    relate te_ee to s_ee across R2020;
    // Be sure we are not related to any te_c across R2085
      else
    if ( ( te_c.included_in_build ) and ( not te_c.isRealized ) )
      te_c.internal_behavior = true;
      // Create the Extended EE instance and link it to the real one.
      create object instance te_ee of TE_EE;
      relate te_ee to s_ee across R2020;
      relate te_ee to te_c across R2085;
    end if;
  end if;
end for;
//
//
// Create the low-level leaf items.
//
// Initialize information for a core data type:  the ANSI C typedef
// that the data type is known by in the generated code in both a
// normal object declaration and an event declaration and the initial
// value of the data element.
select many s_cdts from instances of S_CDT;
for each s_cdt in s_cdts
  select one te_dt related by s_cdt->S_DT[R17]->TE_DT[R2021];
  te_dt.Core_Typ = s_cdt.Core_Typ;
  te_dt.Include_File = te_file.types + ( "." + te_file.hdr_file_ext );
  if ( 0 == te_dt.Core_Typ )
    // void
    te_dt.ExtName = "void";
    te_dt.Initial_Value = "0";
    te_dt.string_format = "";
  elif ( 1 == te_dt.Core_Typ )
    // boolean
    if ( te_sys.AUTOSAR )
      te_dt.ExtName = "dt_xtUMLBoolean";
    else
      te_dt.ExtName = "bool";
    end if;
    te_dt.Initial_Value = "false";
    te_dt.string_format = "%d";
  elif ( 2 == te_dt.Core_Typ )
    // integer
    if ( te_sys.AUTOSAR )
      te_dt.ExtName = "dt_xtUMLInteger";
    else
      te_dt.ExtName = "i_t";
    end if;
    te_dt.Initial_Value = "0";
    te_dt.string_format = "%d";
  elif ( 3 == te_dt.Core_Typ )
    // real
    // float or double:  Default to smaller type for embedded.
    // This can be expanded with the TagDatatypePrecision marking.
    if ( te_sys.AUTOSAR )
      te_dt.ExtName = "dt_xtUMLReal";
    else
      te_dt.ExtName = "r_t";
    end if;
    te_dt.Initial_Value = "0.0";
    te_dt.string_format = "%f";
  elif ( 4 == te_dt.Core_Typ )
    // string
    te_dt.ExtName = "c_t";
    te_dt.Initial_Value = "CTOR";
    te_dt.string_format = "%s";
  elif ( 5 == te_dt.Core_Typ )
    // unique_id
    te_dt.ExtName = te_prefix.type + "UniqueID_t";
    te_dt.Initial_Value = "0";
    te_dt.string_format = "%p";
    //
  elif ( 6 == te_dt.Core_Typ )
    // current_state
    te_dt.ExtName = "";
    te_dt.Initial_Value = "";
    te_dt.string_format = "%d";
  elif ( 7 == te_dt.Core_Typ )
    // same as base<Attribute>
    te_dt.ExtName = "";
    te_dt.Initial_Value = "";
    te_dt.string_format = "%p";
  elif ( 8 == te_dt.Core_Typ )
    // inst_ref<Object>
    te_dt.ExtName = "void *";
    te_dt.Initial_Value = "";
    te_dt.string_format = "%p";
  elif ( 9 == te_dt.Core_Typ )
    // inst_ref_set<Object>
    te_dt.ExtName = te_set.base_class + " *";
    te_dt.Initial_Value = "";
    te_dt.string_format = "%p";
  elif ( 10 == te_dt.Core_Typ )
    // inst<Event>
    te_dt.ExtName = te_eq.base_event_type + " *";
    te_dt.Initial_Value = "0";
    te_dt.string_format = "%p";
    //
  elif ( 11 == te_dt.Core_Typ )
    // inst<Mapping>
    te_dt.ExtName = "";
    te_dt.Initial_Value = "";
    te_dt.string_format = "%d";
  elif ( 12 == te_dt.Core_Typ )
    // inst_ref<Mapping>
    te_dt.ExtName = "i_t";
    te_dt.Initial_Value = "0";
    te_dt.string_format = "%d";
  else
    // undefined
    te_dt.ExtName = "";
    te_dt.Initial_Value = "";
    te_dt.string_format = "%x";
  end if;
end for;
//
// Initialize information for user data types.
select many s_udts from instances of S_UDT;
for each s_udt in s_udts
  r = ::GetBaseTypeForUDT( s_udt:s_udt );
  base_s_dt = r;
  select one core_te_dt related by base_s_dt->TE_DT[R2021];
  // Given a user data type (S_UDT) and a core data type (S_CDT), set
  // the C typedef that the user data type is known by in the generated
  // code.  Also set the initial value of the attribute.
  // Note:  An initial value of "CTOR" means to run the constructor.
  select one s_dt related by s_udt->S_DT[R17];
  select one te_dt related by s_dt->TE_DT[R2021];
  te_dt.Is_Enum = false;
  te_dt.Core_Typ = core_te_dt.Core_Typ;
  te_dt.Include_File = core_te_dt.Include_File;
  te_dt.ExtName = core_te_dt.ExtName;
  te_dt.string_format = core_te_dt.string_format;
  if ( "" != s_dt.DefaultValue )
    te_dt.Initial_Value = s_dt.DefaultValue;
  else
    te_dt.Initial_Value = core_te_dt.Initial_Value;
  end if;
  //
  // CTOR is a special string used to invoke the constructor of a data
  // attribute on the initialization list of the object constructor.
  if ( s_dt.Name == "date" )
    te_dt.ExtName = te_prefix.type + "Date_t";
    te_dt.Initial_Value = "CTOR";
  elif ( s_dt.Name == "timestamp" )
    te_dt.ExtName = te_prefix.type + "TimeStamp_t";
    te_dt.Initial_Value = "CTOR";
  elif ( s_dt.Name == "inst_ref<Timer>" )
    if ( te_tim.keyed_timer_support )
      te_dt.ExtName = te_prefix.type + "Timer_t";
    else
      te_dt.ExtName = te_prefix.type + "Timer_t *";
    end if;
    te_dt.Initial_Value = "0";
  elif ( s_dt.Name == "inst_ref<StateMachine>" )
    te_dt.ExtName = "<T::s(i:te_prefix.type)Object Type *>";
    te_dt.Initial_Value = "0";
  elif ( s_dt.Name == "arbitrary_id" )
    te_dt.ExtName = te_prefix.type + "UniqueID_t";
    te_dt.Initial_Value = "0";
  end if;
end for;
//
// Initialize information for enumeration data types.
select many s_edts from instances of S_EDT;
for each s_edt in s_edts
  select one s_dt related by s_edt->S_DT[R17];
  select one te_dt related by s_dt->TE_DT[R2021];
  // NOTE: We should allow the size of an enum to be colored.
  // For now use small type.
  if ( te_sys.AUTOSAR )
    te_dt.ExtName = "en_" + te_dt.Name;
  elif ( "C" == te_target.language )
    te_dt.ExtName = ( te_sys.Name + "_" ) + ( te_dt.Name + "_t" );
  else
    te_dt.ExtName = te_dt.Name + "_t";
  end if;
  // CDS We should some day pass along the EDT.
  te_dt.Core_Typ = 2;
  te_dt.Is_Enum = true;
  te_dt.Initial_Value = ( te_dt.Owning_Dom_Name + "_" ) + ( te_dt.Name + "__UNINITIALIZED__e" );
  te_dt.Value = "-1";
  te_dt.string_format = "%d";
  if ( te_dt.Owning_Dom_Name == "sys" )
    te_dt.Include_File = ( te_file.types + "." ) + te_file.hdr_file_ext;
  end if;
  //
  // Create the Generated Enumerators and link them to the real ones.
  select many s_enums related by s_edt->S_ENUM[R27];
  for each s_enum in s_enums
    create object instance te_enum of TE_ENUM;
    relate s_enum to te_enum across R2027;
    te_enum.Name = s_enum.Name;
    te_enum.GeneratedName = ( ( te_dt.Owning_Dom_Name + "_" ) + ( te_dt.Name + "_" ) ) + ( T::r(s:te_enum.Name) + "_e" );
    value = T::parsekeyword(s:s_enum.Descrip,key:"value");
    if ( "" == value )
      value = T::parsekeyword(s:s_enum.Descrip,key:"Value");
      if ( "" == value )
        value = T::parsekeyword(s:s_enum.Descrip,key:"VALUE");
      end if;
    end if;
    te_enum.Value = value;
  end for;
end for;
//
// Initialize structured data types.
select many s_sdts from instances of S_SDT;
for each s_sdt in s_sdts
  select one te_dt related by s_sdt->S_DT[R17]->TE_DT[R2021];
  te_dt.ExtName = ( te_dt.Owning_Dom_Name + "_sdt_" ) + te_dt.Name;
  te_dt.string_format = "";
  select many s_mbrs related by s_sdt->S_MBR[R44];
  for each s_mbr in s_mbrs
    create object instance te_mbr of TE_MBR;
    relate s_mbr to te_mbr across R2047;
    select one mbr_te_dt related by s_mbr->S_DT[R45]->TE_DT[R2021];
    relate te_mbr to mbr_te_dt across R2068;
  end for;
  for each s_mbr in s_mbrs
    select one te_mbr related by s_mbr->TE_MBR[R2047];
    select one previous_te_mbr related by s_mbr->S_MBR[R46.''precedes'']->TE_MBR[R2047];
    if ( not_empty previous_te_mbr )
      relate te_mbr to previous_te_mbr across R2067.''precedes'';
    else
          end if;
    te_mbr.Name = s_mbr.Name;
    te_mbr.GeneratedName = T::r(s:s_mbr.Name);
    select many s_dims related by s_mbr->S_DIM[R53];
    array_spec = "";
    te_mbr.dimensions = cardinality s_dims;
    te_dim = empty_te_dim;
    dim_index = 0;
    while ( dim_index < te_mbr.dimensions )
      select any s_dim related by s_mbr->S_DIM[R53] where ( selected.dimensionCount == dim_index );
      r = ::FactoryTE_DIM( s_dim:s_dim, predecessor_te_dim:te_dim );
      te_dim = r;
      if ( dim_index == 0 )
        relate te_dim to te_mbr across R2059;
      end if;
      array_spec = ( array_spec + "[" ) + ( T::s(i:te_dim.elementCount) + "]" );
      dim_index = dim_index + 1;
    end while;
    te_mbr.array_spec = array_spec;
    // In the C model compiler, treat strings as arrays.
    select one mbr_te_dt related by s_mbr->S_DT[R45]->TE_DT[R2021];
    if ( 4 == mbr_te_dt.Core_Typ )
      // string
      te_mbr.dimensions = te_mbr.dimensions + 1;
      te_mbr.array_spec = ( te_mbr.array_spec + "[" ) + ( te_string.max_string_length + "]" );
    end if;
  end for;
end for;
//
// Initialize instance reference data types.
select many s_irdts from instances of S_IRDT;
for each s_irdt in s_irdts
  select one te_dt related by s_irdt->S_DT[R17]->TE_DT[R2021];
  select one te_class related by s_irdt->O_OBJ[R123]->TE_CLASS[R2019];
  if ( s_irdt.isSet )
    te_dt.ExtName = te_set.base_class + " *";
    te_dt.Core_Typ = 21;
  else
    te_dt.Core_Typ = 20;
    if ( not_empty te_class )
      te_dt.ExtName = te_class.GeneratedName + " *";
    end if;
  end if;
end for;
//
// Update the precision of the integer and real types based on marking.
select many tm_precisions from instances of TM_PRECISION;
for each tm_precision in tm_precisions
  te_dts = empty_te_dts;
  if ( ( "*" == tm_precision.Domain ) or ( "" == tm_precision.Domain ) )
    select many te_dts from instances of TE_DT where ( selected.Name == tm_precision.DT_name );
  else
    select any te_c from instances of TE_C where ( selected.Name == tm_precision.Domain );
    // TODO SKB - we do not handle any deep nesting here.  Just datatypes right under the component and under a package under the component
    select many te_dts related by te_c->C_C[R2054]->PE_PE[R8003]->EP_PKG[R8001]->PE_PE[R8000]->S_DT[R8001]->TE_DT[R2021] where ( selected.Name == tm_precision.DT_name );
  end if;
  for each te_dt in te_dts
    // Only allow precision specification of core types integer
    // and real and user defined types (UDTs) that are enums
    // (including S_EDT).
    // S_CDT.Core_Typ == 2 is integer, S_CDT.Core_Typ == 3 is real
    select one s_dt related by te_dt->S_DT[R2021];
    select one s_edt related by s_dt->S_EDT[R17];
    select one s_cdt related by s_dt->S_CDT[R17];
    if ( empty s_cdt )
      select one s_udt related by s_dt->S_UDT[R17];
      if ( not_empty s_udt )
        r = ::GetBaseTypeForUDT( s_udt:s_udt );
        base_s_dt = r;
        select one s_cdt related by base_s_dt->S_CDT[R17];
      end if;
      if ( empty s_cdt )
        select one s_irdt related by s_dt->S_IRDT[R17];
        if ( empty s_irdt )
          if ( empty s_edt )
            T::print(s:"Warning:  Could not find a core data type (S_CDT) for input type.");
            T::exit(i:101);
          end if;
          // Enumeration Data Type (S_EDT) - give it a core type of integer.
          select any s_cdt from instances of S_CDT where ( selected.Core_Typ == 2 );
        else
          if ( s_irdt.isSet )
            select any s_cdt from instances of S_CDT where ( selected.Core_Typ == 9 );
          else
            select any s_cdt from instances of S_CDT where ( selected.Core_Typ == 8 );
          end if;
        end if;
      end if;
    end if;
    if ( ( s_cdt.Core_Typ == 2 ) or ( s_cdt.Core_Typ == 3 ) )
      r = ::MapUserSpecifiedDataTypePrecision( te_dt:te_dt, mapping:tm_precision.xName );
      status_error = r;
      if ( status_error )
        te_dt.ExtName = tm_precision.xName;
      end if;
      if ( ( "" != tm_precision.initial_value ) and ( empty s_edt ) )
        te_dt.Initial_Value = tm_precision.initial_value;
      end if;
    end if;
  end for;
end for;
//
// Map data types to pointers based on marking.
select many tm_pointers from instances of TM_POINTER;
for each tm_pointer in tm_pointers
  te_dts = empty_te_dts;
  if ( ( "*" == tm_pointer.Domain ) or ( "" == tm_pointer.Domain ) )
    select many te_dts from instances of TE_DT where ( selected.Name == tm_pointer.DT_name );
  else
    select any te_c from instances of TE_C where ( selected.Name == tm_pointer.Domain );
    // TODO SKB - we do not handle any deep nesting here.  Just datatypes right under the component and under a package under the component
    select many te_dts related by te_c->C_C[R2054]->PE_PE[R8003]->EP_PKG[R8001]->PE_PE[R8000]->S_DT[R8001]->TE_DT[R2021] where ( selected.Name == tm_pointer.DT_name );
  end if;
  for each te_dt in te_dts
    te_dt.ExtName = tm_pointer.pointer_type + " *";
    te_dt.Initial_Value = "0";
    te_dt.Include_File = tm_pointer.include_file;
    te_dt.Is_Enum = false;
    if ( 4 == te_dt.Core_Typ )
      // Change core type so that dimensions are not added to the pointer.
      te_dt.Core_Typ = -4;
    end if;
  end for;
end for;
//
// Mark enumerator discrete values (from marking).
select many tm_enumvals from instances of TM_ENUMVAL;
for each tm_enumval in tm_enumvals
  te_dts = empty_te_dts;
  if ( ( "*" == tm_enumval.Domain ) or ( "" == tm_enumval.Domain ) )
    select many te_dts from instances of TE_DT where ( selected.Name == tm_enumval.enumeration );
  else
    select any te_c from instances of TE_C where ( selected.Name == tm_enumval.Domain );
    // TODO SKB - we do not handle any deep nesting here.  Just datatypes right under the component and under a package under the component
    select many te_dts related by te_c->C_C[R2054]->PE_PE[R8003]->EP_PKG[R8001]->PE_PE[R8000]->S_DT[R8001]->TE_DT[R2021] where ( selected.Name == tm_enumval.enumeration );
  end if;
  for each te_dt in te_dts
    select any te_enum related by te_dt->S_DT[R2021]->S_EDT[R17]->S_ENUM[R27]->TE_ENUM[R2027] where ( selected.Name == tm_enumval.enumerator );
    if ( not_empty te_enum )
      te_enum.Value = tm_enumval.value;
    end if;
  end for;
end for;
//
// Mark enumerator default uninitialized values (from marking).
select many tm_enuminits from instances of TM_ENUMINIT;
for each tm_enuminit in tm_enuminits
  te_dts = empty_te_dts;
  if ( ( "*" == tm_enuminit.Domain ) or ( "" == tm_enuminit.Domain ) )
    select many te_dts from instances of TE_DT where ( selected.Name == tm_enuminit.enumeration );
  else
    select any te_c from instances of TE_C where ( selected.Name == tm_enuminit.Domain );
    // TODO SKB - we do not handle any deep nesting here.  Just datatypes right under the component and under a package under the component
    select many te_dts related by te_c->C_C[R2054]->PE_PE[R8003]->EP_PKG[R8001]->PE_PE[R8000]->S_DT[R8001]->S_EDT[R17]->S_DT[R17]->TE_DT[R2021] where ( selected.Name == tm_enuminit.enumeration );
  end if;
  for each te_dt in te_dts
    te_dt.Value = tm_enuminit.value;
  end for;
end for;
//
// Create the values and connect them to the V_VAL.
select many v_vals from instances of V_VAL;
for each v_val in v_vals
  create object instance te_val of TE_VAL;
  relate v_val to te_val across R2040;
  te_val.array_spec = "";
  te_val.dimensions = 0;
end for;
//
// Create the extended actual parameters and connect them to V_PAR.
select many v_pars from instances of V_PAR;
for each v_par in v_pars
  create object instance te_par of TE_PAR;
  te_par.Name = v_par.Name;
  te_par.By_Ref = 0;
  relate te_par to v_par across R2063;
end for;
//
// Create the Generated Parameters needed for all types of parameters.
// During this process, te_pars created above will be updated with
// By_Ref information.
// The TE_PARM instances must exist before creating the action bodies
// (for functions, operation, messages, etc).
select many s_bparms from instances of S_BPARM;
for each s_bparm in s_bparms
  select many s_dims related by s_bparm->S_DIM[R49];
  select one te_dt related by s_bparm->S_DT[R22]->TE_DT[R2021];
  r = ::FactoryTE_PARM( s_dims:s_dims, te_dt:te_dt, prefix:"p_", name:s_bparm.Name, description:s_bparm.Descrip, by_ref:s_bparm.By_Ref );
  te_parm = r;
  relate s_bparm to te_parm across R2028;
  select many te_pars related by s_bparm->S_BRG[R21]->ACT_BRG[R674]->V_PAR[R628]->TE_PAR[R2063] where ( selected.Name == te_parm.Name );
  for each te_par in te_pars
    te_par.By_Ref = te_parm.By_Ref;
    relate te_par to te_parm across R2091;
  end for;
  select many te_pars related by s_bparm->S_BRG[R21]->V_BRV[R828]->V_PAR[R810]->TE_PAR[R2063] where ( selected.Name == te_parm.Name );
  for each te_par in te_pars
    te_par.By_Ref = te_parm.By_Ref;
    relate te_par to te_parm across R2091;
  end for;
end for;
// Link the event parameters into order.
for each s_bparm in s_bparms
  select one te_parm related by s_bparm->TE_PARM[R2028];
  select one next_te_parm related by s_bparm->S_BPARM[R55.''succeeds'']->TE_PARM[R2028];
  if ( not_empty next_te_parm )
    relate te_parm to next_te_parm across R2041.''succeeds'';
  end if;
end for;
select many o_tparms from instances of O_TPARM;
for each o_tparm in o_tparms
  select many s_dims related by o_tparm->S_DIM[R121];
  select one te_dt related by o_tparm->S_DT[R118]->TE_DT[R2021];
  r = ::FactoryTE_PARM( s_dims:s_dims, te_dt:te_dt, prefix:"p_", name:o_tparm.Name, description:o_tparm.Descrip, by_ref:o_tparm.By_Ref );
  te_parm = r;
  relate o_tparm to te_parm across R2029;
  select many te_pars related by o_tparm->O_TFR[R117]->ACT_TFM[R673]->V_PAR[R627]->TE_PAR[R2063] where ( selected.Name == te_parm.Name );
  for each te_par in te_pars
    te_par.By_Ref = te_parm.By_Ref;
    relate te_par to te_parm across R2091;
  end for;
  select many te_pars related by o_tparm->O_TFR[R117]->V_TRV[R829]->V_PAR[R811]->TE_PAR[R2063] where ( selected.Name == te_parm.Name );
  for each te_par in te_pars
    te_par.By_Ref = te_parm.By_Ref;
    relate te_par to te_parm across R2091;
  end for;
end for;
// Link the event parameters into order.
for each o_tparm in o_tparms
  select one te_parm related by o_tparm->TE_PARM[R2029];
  select one next_te_parm related by o_tparm->O_TPARM[R124.''succeeds'']->TE_PARM[R2029];
  if ( not_empty next_te_parm )
    relate te_parm to next_te_parm across R2041.''succeeds'';
  end if;
end for;
select many s_sparms from instances of S_SPARM;
for each s_sparm in s_sparms
  select many s_dims related by s_sparm->S_DIM[R52];
  select one te_dt related by s_sparm->S_DT[R26]->TE_DT[R2021];
  r = ::FactoryTE_PARM( s_dims:s_dims, te_dt:te_dt, prefix:"p_", name:s_sparm.Name, description:s_sparm.Descrip, by_ref:s_sparm.By_Ref );
  te_parm = r;
  relate s_sparm to te_parm across R2030;
  select many te_pars related by s_sparm->S_SYNC[R24]->ACT_FNC[R675]->V_PAR[R669]->TE_PAR[R2063] where ( selected.Name == te_parm.Name );
  for each te_par in te_pars
    te_par.By_Ref = te_parm.By_Ref;
    relate te_par to te_parm across R2091;
  end for;
  select many te_pars related by s_sparm->S_SYNC[R24]->V_FNV[R827]->V_PAR[R817]->TE_PAR[R2063] where ( selected.Name == te_parm.Name );
  for each te_par in te_pars
    te_par.By_Ref = te_parm.By_Ref;
    relate te_par to te_parm across R2091;
  end for;
end for;
// Link the event parameters into order.
for each s_sparm in s_sparms
  select one te_parm related by s_sparm->TE_PARM[R2030];
  select one next_te_parm related by s_sparm->S_SPARM[R54.''succeeds'']->TE_PARM[R2030];
  if ( not_empty next_te_parm )
    relate te_parm to next_te_parm across R2041.''succeeds'';
  end if;
end for;
select many sm_evtdis from instances of SM_EVTDI;
for each sm_evtdi in sm_evtdis
  select many s_dims related by sm_evtdi->S_DIM[R531];
  select one te_dt related by sm_evtdi->S_DT[R524]->TE_DT[R2021];
  // Event data items are not passable By_Ref at this time.
  r = ::FactoryTE_PARM( s_dims:s_dims, te_dt:te_dt, prefix:"p_", name:sm_evtdi.Name, description:sm_evtdi.Descrip, by_ref:0 );
  te_parm = r;
  relate te_parm to sm_evtdi across R2031;
end for;
// Link the event parameters into order.
for each sm_evtdi in sm_evtdis
  select one te_parm related by sm_evtdi->TE_PARM[R2031];
  select one next_te_parm related by sm_evtdi->SM_EVTDI[R533.''succeeds'']->TE_PARM[R2031];
  if ( not_empty next_te_parm )
    relate te_parm to next_te_parm across R2041.''succeeds'';
  end if;
end for;
select many c_pps from instances of C_PP;
for each c_pp in c_pps
  select many s_dims related by c_pp->S_DIM[R4017];
  select one te_dt related by c_pp->S_DT[R4007]->TE_DT[R2021];
  c_pp_name = c_pp.Name;
  if ( "C++" == te_target.language )
    select one c_as related by c_pp->C_EP[R4006]->C_AS[R4004];
    if ( not_empty c_as )
      c_pp_name = ( c_as.Name + "_" ) + c_pp_name;
    else
      select one c_io related by c_pp->C_EP[R4006]->C_IO[R4004];
      c_pp_name = ( c_io.Name + "_" ) + c_pp_name;
    end if;
  end if;
  r = ::FactoryTE_PARM( s_dims:s_dims, te_dt:te_dt, prefix:"p_", name:c_pp_name, description:c_pp.Descrip, by_ref:c_pp.By_Ref );
  te_parm = r;
  relate c_pp to te_parm across R2048;
  select many spr_reps related by c_pp->C_EP[R4006]->SPR_REP[R4500];
  if ( not_empty spr_reps )
    select many te_pars related by spr_reps->SPR_RS[R4502]->ACT_SGN[R660]->V_PAR[R662]->TE_PAR[R2063] where ( selected.Name == c_pp.Name );
    for each te_par in te_pars
      te_par.By_Ref = te_parm.By_Ref;
      relate te_par to te_parm across R2091;
    end for;
    select many te_pars related by spr_reps->SPR_RO[R4502]->ACT_IOP[R657]->V_PAR[R679]->TE_PAR[R2063] where ( selected.Name == c_pp.Name );
    for each te_par in te_pars
      te_par.By_Ref = te_parm.By_Ref;
      relate te_par to te_parm across R2091;
    end for;
    select many te_pars related by spr_reps->V_MSV[R845]->V_PAR[R842]->TE_PAR[R2063] where ( selected.Name == c_pp.Name );
    for each te_par in te_pars
      te_par.By_Ref = te_parm.By_Ref;
      relate te_par to te_parm across R2091;
    end for;
  end if;
  select many spr_peps related by c_pp->C_EP[R4006]->SPR_PEP[R4501];
  if ( not_empty spr_peps )
    select many te_pars related by spr_peps->SPR_PS[R4503]->ACT_SGN[R663]->V_PAR[R662]->TE_PAR[R2063] where ( selected.Name == c_pp.Name );
    for each te_par in te_pars
      te_par.By_Ref = te_parm.By_Ref;
      relate te_par to te_parm across R2091;
    end for;
    select many te_pars related by spr_peps->SPR_PO[R4503]->ACT_IOP[R680]->V_PAR[R679]->TE_PAR[R2063] where ( selected.Name == c_pp.Name );
    for each te_par in te_pars
      te_par.By_Ref = te_parm.By_Ref;
      relate te_par to te_parm across R2091;
    end for;
    select many te_pars related by spr_peps->V_MSV[R841]->V_PAR[R842]->TE_PAR[R2063] where ( selected.Name == c_pp.Name );
    for each te_par in te_pars
      te_par.By_Ref = te_parm.By_Ref;
      relate te_par to te_parm across R2091;
    end for;
  end if;
end for;
// Link the event parameters into order.
for each c_pp in c_pps
  select one te_parm related by c_pp->TE_PARM[R2048];
  select one next_te_parm related by c_pp->C_PP[R4021.''succeeds'']->TE_PARM[R2048];
  if ( not_empty next_te_parm )
    relate te_parm to next_te_parm across R2041.''succeeds'';
  end if;
end for;
//
//
select any void_te_dt from instances of TE_DT where ( selected.Core_Typ == 0 );
//
// Create the port message actions.  There are four types.  Use
// a common extension class for all of them.
// Populate the extension with all of the names it will need from
// the component, interface, port and message.
select many spr_ros from instances of SPR_RO;
for each spr_ro in spr_ros
  select one spr_rep related by spr_ro->SPR_REP[R4502];
  select one te_po related by spr_rep->C_R[R4500]->C_IR[R4009]->C_PO[R4016]->TE_PO[R2044];
  select one te_c related by te_po->TE_C[R2005];
  select one c_io related by spr_rep->C_EP[R4500]->C_IO[R4004];
  select one te_dt related by c_io->S_DT[R4008]->TE_DT[R2021];
  // If we are using TLM ports, convert booleans to integers
  if ( "SystemC" == te_thread.flavor )
    if ( ( 1 == te_dt.Core_Typ ) and ( te_sys.SystemCPortsType == "TLM" ) )
      te_dt = converted_bool_te_dt;
    end if;
  end if;
  select many te_parms related by spr_rep->C_EP[R4500]->C_PP[R4006]->TE_PARM[R2048];
  r = ::FactoryTE_MACT( te_parms:te_parms, te_dt:te_dt, te_c:te_c, te_po:te_po, message_name:spr_ro.Name, description:c_io.Descrip, subtypeKL:"SPR_RO" );
  te_mact = r;
  te_mact.Direction = c_io.Direction;
  relate te_mact to spr_ro across R2052;
end for;
select many spr_rss from instances of SPR_RS;
for each spr_rs in spr_rss
  select one spr_rep related by spr_rs->SPR_REP[R4502];
  select one te_po related by spr_rep->C_R[R4500]->C_IR[R4009]->C_PO[R4016]->TE_PO[R2044];
  select one te_c related by te_po->TE_C[R2005];
  select one c_as related by spr_rep->C_EP[R4500]->C_AS[R4004];
  select many te_parms related by spr_rep->C_EP[R4500]->C_PP[R4006]->TE_PARM[R2048];
  r = ::FactoryTE_MACT( te_parms:te_parms, te_dt:void_te_dt, te_c:te_c, te_po:te_po, message_name:spr_rs.Name, description:c_as.Descrip, subtypeKL:"SPR_RS" );
  te_mact = r;
  te_mact.Direction = c_as.Direction;
  relate te_mact to spr_rs across R2053;
end for;
select many spr_pos from instances of SPR_PO;
for each spr_po in spr_pos
  select one spr_pep related by spr_po->SPR_PEP[R4503];
  select one te_po related by spr_pep->C_P[R4501]->C_IR[R4009]->C_PO[R4016]->TE_PO[R2044];
  select one te_c related by te_po->TE_C[R2005];
  select one c_io related by spr_pep->C_EP[R4501]->C_IO[R4004];
  select one te_dt related by c_io->S_DT[R4008]->TE_DT[R2021];
  // If we are using TLM ports, convert booleans to integers
  if ( "SystemC" == te_thread.flavor )
    if ( ( 1 == te_dt.Core_Typ ) and ( te_sys.SystemCPortsType == "TLM" ) )
      te_dt = converted_bool_te_dt;
    end if;
  end if;
  select many te_parms related by spr_pep->C_EP[R4501]->C_PP[R4006]->TE_PARM[R2048];
  r = ::FactoryTE_MACT( te_parms:te_parms, te_dt:te_dt, te_c:te_c, te_po:te_po, message_name:spr_po.Name, description:c_io.Descrip, subtypeKL:"SPR_PO" );
  te_mact = r;
  te_mact.Direction = c_io.Direction;
  relate te_mact to spr_po across R2050;
end for;
select many spr_pss from instances of SPR_PS;
for each spr_ps in spr_pss
  select one spr_pep related by spr_ps->SPR_PEP[R4503];
  select one te_po related by spr_pep->C_P[R4501]->C_IR[R4009]->C_PO[R4016]->TE_PO[R2044];
  select one te_c related by te_po->TE_C[R2005];
  select one c_as related by spr_pep->C_EP[R4501]->C_AS[R4004];
  select many te_parms related by spr_pep->C_EP[R4501]->C_PP[R4006]->TE_PARM[R2048];
  r = ::FactoryTE_MACT( te_parms:te_parms, te_dt:void_te_dt, te_c:te_c, te_po:te_po, message_name:spr_ps.Name, description:c_as.Descrip, subtypeKL:"SPR_PS" );
  te_mact = r;
  te_mact.Direction = c_as.Direction;
  relate te_mact to spr_ps across R2051;
end for;
// All the te_pos and te_macts are created now.  Order the te_macts alphabetically inside the ports.
select many te_pos from instances of TE_PO;
for each te_po in te_pos
  select many te_macts related by te_po->TE_MACT[R2006];
  ::mact_sort( te_macts:te_macts );
end for;
//
//
// Create the generated links (associations) and connect them.
select many r_rels from instances of R_REL;
for each r_rel in r_rels
  create object instance te_rel of TE_REL;
  te_rel.Numb = r_rel.Numb;
  if ( te_sys.InstanceLoading )
    te_rel.LinkNeeded = true;
  else
    te_rel.LinkNeeded = false;
  end if;
  te_rel.UnlinkNeeded = false;
  te_rel.Navigated = false;
  te_rel.Order = 0;
  te_rel.storage_needed = false;
  relate r_rel to te_rel across R2034;
end for;
//
// Create the navigations and connect them to the R_OIRs.
select many r_oirs from instances of R_OIR;
for each r_oir in r_oirs
  create object instance te_oir of TE_OIR;
  select one o_obj related by r_oir->O_OBJ[R201];
  select one r_rel related by r_oir->R_REL[R201];
  te_oir.data_member = ( o_obj.Key_Lett + "_R" ) + T::s(i:r_rel.Numb);
  te_oir.assoc_type = "";
  te_oir.Mult = 0;
  te_oir.object_id = "";
  te_oir.NavigatedTo = false;
  relate r_oir to te_oir across R2035;
end for;
select many r_parts related by r_rels->R_SIMP[R206]->R_PART[R207];
for each r_part in r_parts
  select one te_oir related by r_part->R_RTO[R204]->R_OIR[R203]->TE_OIR[R2035];
  te_oir.assoc_type = "part";
  te_oir.rel_phrase = T::underscore(s:r_part.Txt_Phrs);
  te_oir.Mult = r_part.Mult;
  if ( "" != te_oir.rel_phrase )
    te_oir.data_member = ( te_oir.data_member + "_" ) + te_oir.rel_phrase;
  end if;
end for;
select many r_forms from instances of R_FORM;
for each r_form in r_forms
  select one te_oir related by r_form->R_RGO[R205]->R_OIR[R203]->TE_OIR[R2035];
  te_oir.assoc_type = "form";
  te_oir.rel_phrase = T::underscore(s:r_form.Txt_Phrs);
  te_oir.Mult = r_form.Mult;
  if ( "" != te_oir.rel_phrase )
    te_oir.data_member = ( te_oir.data_member + "_" ) + te_oir.rel_phrase;
  end if;
end for;
select many r_aones from instances of R_AONE;
for each r_aone in r_aones
  select one te_oir related by r_aone->R_RTO[R204]->R_OIR[R203]->TE_OIR[R2035];
  te_oir.assoc_type = "aone";
  te_oir.rel_phrase = T::underscore(s:r_aone.Txt_Phrs);
  te_oir.Mult = r_aone.Mult;
  if ( "" != te_oir.rel_phrase )
    te_oir.data_member = ( te_oir.data_member + "_" ) + te_oir.rel_phrase;
  end if;
end for;
select many r_aoths from instances of R_AOTH;
for each r_aoth in r_aoths
  select one te_oir related by r_aoth->R_RTO[R204]->R_OIR[R203]->TE_OIR[R2035];
  te_oir.assoc_type = "aoth";
  te_oir.rel_phrase = T::underscore(s:r_aoth.Txt_Phrs);
  te_oir.Mult = r_aoth.Mult;
  if ( "" != te_oir.rel_phrase )
    te_oir.data_member = ( te_oir.data_member + "_" ) + te_oir.rel_phrase;
  end if;
end for;
select many r_assrs from instances of R_ASSR;
for each r_assr in r_assrs
  select one te_oir related by r_assr->R_RGO[R205]->R_OIR[R203]->TE_OIR[R2035];
  te_oir.assoc_type = "assr";
  te_oir.Mult = r_assr.Mult;
end for;
select many r_subs from instances of R_SUB;
for each r_sub in r_subs
  select one te_oir related by r_sub->R_RGO[R205]->R_OIR[R203]->TE_OIR[R2035];
  select one r_rel related by r_sub->R_SUBSUP[R213]->R_REL[R206];
  te_oir.assoc_type = "subsuper";
  te_oir.object_id = ( "R" + T::s(i:r_rel.Numb) ) + "_object_id";
  te_oir.data_member = ( "R" + T::s(i:r_rel.Numb) ) + "_subtype";
end for;
select many r_supers from instances of R_SUPER;
for each r_super in r_supers
  select one te_oir related by r_super->R_RTO[R204]->R_OIR[R203]->TE_OIR[R2035];
  te_oir.assoc_type = "subsuper";
end for;
//
// Create the blocks and connect them to the ACT_BLKs.
select many act_blks from instances of ACT_BLK;
for each act_blk in act_blks
  create object instance te_blk of TE_BLK;
  relate act_blk to te_blk across R2016;
  te_blk.OAL = "";
  te_blk.declaration = "";
  te_blk.initialization = "";
  te_blk.deallocation = "";
  te_blk.code = "";
  te_blk.depth = 1;
  first_smt = true;
  // Create the statements and connect them to the ACT_SMTs.
  select many act_smts related by act_blk->ACT_SMT[R602];
  for each act_smt in act_smts
    create object instance te_smt of TE_SMT;
    relate act_smt to te_smt across R2038;
    // Connect the statement to its parent block.
    relate te_smt to te_blk across R2078;
    if ( first_smt )
      // CDS WARNING!! This assumes the gen_erate will give us the first statement first!
      relate te_blk to te_smt across R2014;
      first_smt = false;
    else
          end if;
    te_smt.OAL = "";
    te_smt.declaration = "";
    te_smt.initialization = "";
    te_smt.deallocation = "";
    te_smt.buffer = "";
    te_smt.buffer2 = "";
    te_smt.trace = "";
          end for;
  // Link the te_smts into order like the act_smts.
  for each act_smt in act_smts
    select one te_smt related by act_smt->TE_SMT[R2038];
    select one next_act_smt related by act_smt->ACT_SMT[R661.''succeeds''];
    if ( not_empty next_act_smt )
      select one next_te_smt related by next_act_smt->TE_SMT[R2038];
      relate te_smt to next_te_smt across R2012.''succeeds'';
    end if;
  end for;
end for;
//
// Connect up statements and blocks in the extended subsystem.
// We want statements to know:
// 1) containing block
// 2) sub-block
// [for, while, if, elif and else statements have sub-blocks.]
select many act_fors from instances of ACT_FOR;
for each act_for in act_fors
  select one te_smt related by act_for->ACT_SMT[R603]->TE_SMT[R2038];
  select one te_blk related by act_for->ACT_BLK[R605]->TE_BLK[R2016];
  relate te_smt to te_blk across R2015;
  te_smt.subtypeKL = "TE_FOR";
end for;
select many act_whls from instances of ACT_WHL;
for each act_whl in act_whls
  select one te_smt related by act_whl->ACT_SMT[R603]->TE_SMT[R2038];
  select one te_blk related by act_whl->ACT_BLK[R608]->TE_BLK[R2016];
  relate te_smt to te_blk across R2015;
  te_smt.subtypeKL = "TE_WHL";
end for;
select many act_ifs from instances of ACT_IF;
for each act_if in act_ifs
  select one te_smt related by act_if->ACT_SMT[R603]->TE_SMT[R2038];
  select one te_blk related by act_if->ACT_BLK[R607]->TE_BLK[R2016];
  relate te_smt to te_blk across R2015;
  te_smt.subtypeKL = "TE_IF";
end for;
select many act_els from instances of ACT_EL;
for each act_el in act_els
  select one te_smt related by act_el->ACT_SMT[R603]->TE_SMT[R2038];
  select one te_blk related by act_el->ACT_BLK[R658]->TE_BLK[R2016];
  relate te_smt to te_blk across R2015;
  te_smt.subtypeKL = "TE_EL";
end for;
select many act_es from instances of ACT_E;
for each act_e in act_es
  select one te_smt related by act_e->ACT_SMT[R603]->TE_SMT[R2038];
  select one te_blk related by act_e->ACT_BLK[R606]->TE_BLK[R2016];
  relate te_smt to te_blk across R2015;
  te_smt.subtypeKL = "TE_E";
end for;
// Calculate the block depth to be used for indentation.
select many te_blks from instances of TE_BLK;
for each te_blk in te_blks
  select one parent_te_blk related by te_blk->TE_SMT[R2015]->TE_BLK[R2078];
  while ( not_empty parent_te_blk )
    te_blk.depth = te_blk.depth + 1;
    select one parent_te_blk related by parent_te_blk->TE_SMT[R2015]->TE_BLK[R2078];
  end while;
  r = ::blk_indentwhitespace( indentation:te_blk.depth );
  te_blk.indentation = r;
end for;
//
// Create the generated chain links and connect them to the ACT_LNKs.
select many act_lnks from instances of ACT_LNK;
for each act_lnk in act_lnks
  ::FactoryTE_LNK( act_lnk:act_lnk );
end for;
// Link the chain links together in extensions as in meta-model proper.
select many te_lnks from instances of TE_LNK;
for each te_lnk in te_lnks
  select one act_lnk related by te_lnk->ACT_LNK[R2042];
  select one next_act_lnk related by act_lnk->ACT_LNK[R604.''succeeds''];
  if ( not_empty next_act_lnk )
    select one next_te_lnk related by next_act_lnk->TE_LNK[R2042];
    relate te_lnk to next_te_lnk across R2075.''succeeds'';
    // We populate this here.  Populate firsts during statement linkage.
    next_te_lnk.left = te_lnk.linkage;
    // We may have traversed directly from aoth to aone (or vice versa)
    // across an associative association.  If so, insert the associative
    // link between the two ends to enable the traversal.
    r = ::detect_and_insert_associator_TE_LNK( te_lnk:te_lnk, next_te_lnk:next_te_lnk, act_lnk:act_lnk, next_act_lnk:next_act_lnk, start_o_obj:empty_o_obj );
    discard = r;
  else
    // We can detect the end of the chain here.
    // We will detect the beginning during statement linkage.
    if ( not_empty te_lnk )
      te_lnk.last = true;
    end if;
  end if;
end for;
//
// Create the variables and connect them to the V_VAR.
select many v_vars from instances of V_VAR;
for each v_var in v_vars
  create object instance te_var of TE_VAR;
  relate v_var to te_var across R2039;
  if ( T::l(s:v_var.Name) == "self" )
    te_var.OAL = "self";
    te_var.buffer = te_instance.self;
  else
    te_var.OAL = v_var.Name;
    te_var.buffer = T::underscore(s:v_var.Name);
    if ( "C++" == te_target.language )
      // This prepends characters to transients in case the modeler used a C keyword.
      te_var.buffer = "v_" + te_var.buffer;
    end if;
  end if;
  array_spec = "";
  select many s_dims related by v_var->S_DIM[R849];
  te_var.dimensions = cardinality s_dims;
  te_dim = empty_te_dim;
  dim_index = 0;
  while ( dim_index < te_var.dimensions )
    select any s_dim related by v_var->S_DIM[R849] where ( selected.dimensionCount == dim_index );
    r = ::FactoryTE_DIM( s_dim:s_dim, predecessor_te_dim:te_dim );
    te_dim = r;
    if ( dim_index == 0 )
      relate te_dim to te_var across R2057;
    end if;
    array_spec = ( array_spec + "[" ) + ( T::s(i:te_dim.elementCount) + "]" );
    dim_index = dim_index + 1;
  end while;
  te_var.array_spec = array_spec;
  select one te_dt related by v_var->S_DT[R848]->TE_DT[R2021];
  if ( not_empty te_dt )
    // In the C model compiler, treat strings as arrays.
    if ( 4 == te_dt.Core_Typ )
      // string
      te_var.dimensions = te_var.dimensions + 1;
      te_var.array_spec = ( te_var.array_spec + "[" ) + ( te_string.max_string_length + "]" );
    end if;
  else
    T::print(s:"\nERROR:  Did not find a datatype associated with variable " + v_var.Name +".");
    T::print(s:"Check usages of " + v_var.Name + " for parse errors in the action language.");
    T::print(s:"[Parse All Activies and look for errors in the Problems view.]\n");
  end if;
end for;
//
//
//
// Continue initializing the components created and linked above.
// Recurse down into the component-level artifacts.
select many te_cs from instances of TE_C where ( selected.included_in_build );
for each te_c in te_cs
  // Initialize the te_sync instances.
  select many te_syncs related by te_c->TE_SYNC[R2084];
  for each te_sync in te_syncs
    select one s_sync related by te_sync->S_SYNC[R2023];
    te_sync.Included = false;
    te_sync.IsInitFunction = false;
    te_sync.IsSafeForInterrupts = false;
    te_sync.XlateSemantics = true;
    te_sync.deferred_method = te_sync.GeneratedName + "_deferred";
    select any tm_sync from instances of TM_SYNC where ( ( selected.RegisteredDomain == te_c.Name ) and ( selected.Name == te_sync.Name ) );
    if ( not_empty tm_sync )
      te_sync.IsSafeForInterrupts = tm_sync.IsSafeForInterrupts;
      select one rval_dt related by s_sync->S_DT[R25];
      if ( rval_dt.Name != "void" )
        T::print(s:"ERROR:  Function " + te_sync.Name + " in T::s(i:te_c.Name)");
        T::print(s:"is trying to return data.  Functions marked as safe for");
        T::print(s:"interrupt invocation cannot return data.  They must be");
        T::print(s:"of return type void.");
        T::print(s:"Change the return type of the function or do not mark");
        T::print(s:"it as SafeForInterrupts.");
        T::exit(i:100);
      end if;
    end if;
    if ( te_sync.IsSafeForInterrupts )
      te_sync.intraface_method = te_sync.GeneratedName + "_sync";
    else
      te_sync.intraface_method = te_sync.GeneratedName;
    end if;
    select one te_dt related by s_sync->S_DT[R25]->TE_DT[R2021];
    select many te_parms related by s_sync->S_SPARM[R24]->TE_PARM[R2030];
    r = ::FactoryTE_ABA( te_c:te_c, te_parms:te_parms, scope:te_c.Name, name:te_sync.GeneratedName, subtypeKL:"S_SYNC", te_dt:te_dt );
    te_aba = r;
    relate te_sync to te_aba across R2010;
  end for;
  //
  // Create the Generated External Entity instances and link them in.
  select many te_ees related by te_c->TE_EE[R2085];
  for each te_ee in te_ees
    ::TE_EE_init( te_ee:te_ee, te_c:te_c );
  end for;
  //
  // Initialize the Generated Class instances.
  select many te_classs related by te_c->TE_CLASS[R2064];
  for each te_class in te_classs
    select one o_obj related by te_class->O_OBJ[R2019];
    // Initialize model compiler extension attributes.
    te_class.SelfCreated = false;
    te_class.NonSelfCreated = false;
    te_class.Included = false;
    te_class.IsFixedPopulation = false;
    te_class.PEIsDefinedInData = false;
    te_class.IsReadOnly = false;
    // Default is 10 instances per class.
    te_class.MaxExtentSize = 10;
    te_class.Persistent = false;
    te_class.ExcludeFromGen = false;
    te_class.IsTrace = true;
    te_class.ContainerIndex = 0;
    te_class.Task = 0;
    te_class.class_file = te_class.GeneratedName + "_class";
    te_class.system_class_number = te_class.GeneratedName + "_CLASS_NUMBER";
    te_class.CBsystem_class_number = te_class.GeneratedName + "_CLASS_NUMBER_CB";
    te_class.dispatcher = "";
    te_class.CBdispatcher = "";
    select one sm_ism related by o_obj->SM_ISM[R518];
    if ( not_empty sm_ism )
      te_class.dispatcher = te_class.GeneratedName + "_Dispatch";
    end if;
    select one sm_asm related by o_obj->SM_ASM[R519];
    if ( not_empty sm_asm )
      te_class.CBdispatcher = te_class.GeneratedName + "_CBDispatch";
    end if;
    te_class.persist_link = te_class.GeneratedName + "_LinkCentral";
    //
    // Create the Generated Attribute instances and link them to the real ones.
    delimiter = "";
    prev_te_attr = empty_te_attr;
    // Find first o_attr.
    select any o_attr related by o_obj->O_ATTR[R102];
    while ( not_empty o_attr )
      select one prev_o_attr related by o_attr->O_ATTR[R103.''precedes''];
      if ( empty prev_o_attr )
        break;
      end if;
      o_attr = prev_o_attr;
    end while;
    while ( not_empty o_attr )
      create object instance te_attr of TE_ATTR;
      te_attr.Name = o_attr.Name;
      te_attr.GeneratedName = T::r(s:o_attr.Name);
      te_attr.DefaultValue = o_attr.DefaultValue;
      te_attr.Used = false;
      te_attr.read = false;
      te_attr.written = false;
      te_attr.Included = false;
      te_attr.Order = 0;
      te_attr.ParamBuffer = "";
      te_attr.translate = true;
      relate te_attr to o_attr across R2033;
      relate te_attr to te_class across R2061;
            if ( not_empty prev_te_attr )
        relate prev_te_attr to te_attr across R2087.''succeeds'';
      end if;
      select many s_dims related by o_attr->S_DIM[R120];
      array_spec = "";
      te_attr.dimensions = cardinality s_dims;
      te_dim = empty_te_dim;
      dim_index = 0;
      while ( dim_index < te_attr.dimensions )
        select any s_dim related by o_attr->S_DIM[R120] where ( selected.dimensionCount == dim_index );
        r = ::FactoryTE_DIM( s_dim:s_dim, predecessor_te_dim:te_dim );
        te_dim = r;
        if ( dim_index == 0 )
          relate te_dim to te_attr across R2055;
        end if;
        array_spec = ( array_spec + "[" ) + ( T::s(i:te_dim.elementCount) + "]" );
        dim_index = dim_index + 1;
      end while;
      te_attr.array_spec = array_spec;
      select one te_dt related by o_attr->S_DT[R114]->TE_DT[R2021];
      // Potentially substitute data type for base attribute data type.
      if ( 7 == te_dt.Core_Typ )
        // referential attribute
        r = ::GetAttributeCodeGenType( o_attr:o_attr );
        te_dt = r;
      end if;
      te_attr.GeneratedType = te_dt.ExtName;
      o_attr_Descrip_Persistent = T::parsekeyword(s:o_attr.Descrip,key:"Persistent");
      if ( o_attr_Descrip_Persistent != "false" )
        if ( "%p" == te_dt.string_format )
          te_class.attribute_format = ( te_class.attribute_format + delimiter ) + "%ld";
          te_class.attribute_dump = ( te_class.attribute_dump + ",\n    (long)self->" ) + te_attr.GeneratedName;
        elif ( "%s" == te_dt.string_format )
          // Place an escaped tick mark around the %s in the attribute format string.
          te_class.attribute_format = ( ( te_class.attribute_format + delimiter ) + ( "''''" + te_dt.string_format ) ) + "''''";
          te_class.attribute_dump = ( te_class.attribute_dump + ",\n    self->" ) + te_attr.GeneratedName;
        else
          te_class.attribute_format = ( te_class.attribute_format + delimiter ) + te_dt.string_format;
          te_class.attribute_dump = ( te_class.attribute_dump + ",\n    self->" ) + te_attr.GeneratedName;
        end if;
      end if;
      // In the C model compiler, treat strings as arrays.
      if ( 4 == te_dt.Core_Typ )
        // string
        te_attr.dimensions = te_attr.dimensions + 1;
        te_attr.array_spec = ( te_attr.array_spec + "[" ) + ( te_string.max_string_length + "]" );
      end if;
      //
      // Create the Action Block Anchors associated with each action
      // in the user model.  Initialize and link them.
      // Create and link the Generated versions of each of the action homes.
      select one o_dbattr related by o_attr->O_BATTR[R106]->O_DBATTR[R107];
      if ( not_empty o_dbattr )
        create object instance te_dbattr of TE_DBATTR;
        te_dbattr.Included = false;
        te_dbattr.GeneratedName = ( te_class.GeneratedName + "_MDA_" ) + o_attr.Name;
        relate o_dbattr to te_dbattr across R2026;
        select one te_dt related by o_attr->S_DT[R114]->TE_DT[R2021];
        te_parms = empty_te_parms;
        r = ::FactoryTE_ABA( te_c:te_c, te_parms:te_parms, scope:"", name:te_dbattr.GeneratedName, subtypeKL:"O_DBATTR", te_dt:te_dt );
        te_aba = r;
        relate te_dbattr to te_aba across R2010;
      end if;
      delimiter = ",";
      prev_te_attr = te_attr;
      select one o_attr related by o_attr->O_ATTR[R103.''succeeds''];
    end while;
    //
    // Create the Generated State Machines and connect them to SM_SM.
    select one sm_sm related by o_obj->SM_ISM[R518]->SM_SM[R517];
    if ( not_empty sm_sm )
      ::FactoryTE_SM( is_ism:true, sm_sm:sm_sm, te_class:te_class );
    end if;
    select one sm_sm related by o_obj->SM_ASM[R519]->SM_SM[R517];
    if ( not_empty sm_sm )
      ::FactoryTE_SM( is_ism:false, sm_sm:sm_sm, te_class:te_class );
    end if;
    //
    // Create and relate the generated class operations.
    select many o_tfrs related by o_obj->O_TFR[R115];
    for each o_tfr in o_tfrs
      create object instance te_tfr of TE_TFR;
      te_tfr.Included = false;
      te_tfr.XlateSemantics = true;
      ib = Scope::Instance;
      if ( ib == o_tfr.Instance_Based )
        te_tfr.Instance_Based = 1;
      else
        te_tfr.Instance_Based = 0;
      end if;
      te_tfr.Key_Lett = te_class.Key_Lett;
      te_tfr.Name = o_tfr.Name;
      te_tfr.GeneratedName = ( ( te_c.Name + "_" ) + ( te_tfr.Key_Lett + "_op_" ) ) + te_tfr.Name;
      relate o_tfr to te_tfr across R2024;
      select one te_dt related by o_tfr->S_DT[R116]->TE_DT[R2021];
      select many te_parms related by o_tfr->O_TPARM[R117]->TE_PARM[R2029];
      r = ::FactoryTE_ABA( te_c:te_c, te_parms:te_parms, scope:te_class.GeneratedName, name:te_tfr.GeneratedName, subtypeKL:"O_TFR", te_dt:te_dt );
      te_aba = r;
      relate te_tfr to te_aba across R2010;
    end for;
    //
    // Create the WhereKey instance connected to O_ID.
    select many o_ids related by o_obj->O_ID[R104];
    for each o_id in o_ids
      create object instance te_where of TE_WHERE;
      te_where.WhereKey = false;
      relate te_where to o_id across R2032;
      number = te_where.Oid_ID + 1;
      te_where.select_any_where = ( te_class.GeneratedName + "_AnyWhere" ) + T::s(i:number);
    end for;
  end for;
end for;
//
select many te_ees from instances of TE_EE;
for each te_ee in te_ees
  select one te_c related by te_ee->TE_C[R2085];
  if ( empty te_c )
    ::TE_EE_init( te_ee:te_ee, te_c:empty_te_c );
  end if;
end for;
//
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("34b725c2-7fa6-4c8a-8e8f-abbdc6e9e972",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("037ba218-112c-4c1f-81cb-490f98c39ff7",
	"00000000-0000-0000-0000-000000000000",
	'FactoryTE_CLASS',
	'',
	'//
//
//============================================================================
// New and return instance of TE_CLASS.
//============================================================================
o_obj = param.o_obj;
te_c = param.te_c;
// Create the Generated Class instance and link it to the model one.
create object instance te_class of TE_CLASS;
relate te_class to o_obj across R2019;
relate te_class to te_c across R2064;
// Copy the Numb attribute for sorting purposes.
te_class.Numb = o_obj.Numb;
// Copy other attributes for convenience so we can avoid accessing o_obj.
te_class.Name = o_obj.Name;
te_class.Key_Lett = o_obj.Key_Lett;
te_class.Key_Lett = T::r(s:te_class.Key_Lett);
// Initialize model compiler extension attributes.
te_class.GeneratedName = ( te_c.Name + "_" ) + te_class.Key_Lett;
te_class.CBGeneratedName = te_class.GeneratedName + "_CB";
return te_class;
',
	"f975acb7-4246-4a87-9c5a-75481f096785",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("f5ed5a5d-f701-43bf-a580-a022f406ac0f",
	"037ba218-112c-4c1f-81cb-490f98c39ff7",
	'o_obj',
	"d6b21eeb-39da-43bf-b503-c7bbc9ddf242",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("d6b21eeb-39da-43bf-b503-c7bbc9ddf242",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Model Class>',
	'',
	'',
	'../Instance Reference Data Types/Instance Reference Data Types.xtuml');
INSERT INTO S_SPARM
	VALUES ("18c1fad0-794d-41af-ab50-05cb413b6500",
	"037ba218-112c-4c1f-81cb-490f98c39ff7",
	'te_c',
	"af13e9b7-f940-4a62-b6da-d8fb321a8a39",
	0,
	'',
	"f5ed5a5d-f701-43bf-a580-a022f406ac0f",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("af13e9b7-f940-4a62-b6da-d8fb321a8a39",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Component>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("037ba218-112c-4c1f-81cb-490f98c39ff7",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_DT_PROXY
	VALUES ("f975acb7-4246-4a87-9c5a-75481f096785",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Class>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO S_SYNC
	VALUES ("dba0e101-258a-43ff-af1c-a0cbca6b4e00",
	"00000000-0000-0000-0000-000000000000",
	'FactoryTE_DIM',
	'',
	'//
//
//============================================================================
// New and return instance of TE_DIM.
//============================================================================
s_dim = param.s_dim;
predecessor_te_dim = param.predecessor_te_dim;
create object instance te_dim of TE_DIM;
te_dim.elementCount = s_dim.elementCount;
if ( 0 == te_dim.elementCount )
  // Here we have a VLA (variable length array).
  // Add support here.
end if;
te_dim.dimensionCount = s_dim.dimensionCount;
if ( not_empty predecessor_te_dim )
  relate te_dim to predecessor_te_dim across R2060.''succeeds'';
end if;
return te_dim;
',
	"c0718fda-c6da-4d8b-99f8-c17ffd14b6b0",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("0b967f46-3b3b-4ef6-9019-cc75065a648b",
	"dba0e101-258a-43ff-af1c-a0cbca6b4e00",
	's_dim',
	"15158ac6-71a4-4ce8-8756-ebf92d171d09",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("15158ac6-71a4-4ce8-8756-ebf92d171d09",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Dimensions>',
	'',
	'',
	'../Domain/Domain.xtuml');
INSERT INTO S_SPARM
	VALUES ("d1148ab9-be7c-4a6d-a418-f833c0116d2b",
	"dba0e101-258a-43ff-af1c-a0cbca6b4e00",
	'predecessor_te_dim',
	"c0718fda-c6da-4d8b-99f8-c17ffd14b6b0",
	0,
	'',
	"0b967f46-3b3b-4ef6-9019-cc75065a648b",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("c0718fda-c6da-4d8b-99f8-c17ffd14b6b0",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Dimension>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("dba0e101-258a-43ff-af1c-a0cbca6b4e00",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("610356be-0d5d-4aff-affc-27d3750c7f0e",
	"00000000-0000-0000-0000-000000000000",
	'FactoryTE_SM',
	'',
	'//
//
//============================================================================
// New and link state machine instances.
// Allocate and link state instances (in numerically sorted order).
//============================================================================
is_ism = param.is_ism;
sm_sm = param.sm_sm;
te_class = param.te_class;
select any void_te_dt from instances of TE_DT where ( selected.Core_Typ == 0 );
select many empty_te_parms from instances of TE_PARM where ( false );
select one te_c related by te_class->TE_C[R2064];
create object instance te_sm of TE_SM;
relate te_sm to te_class across R2072;
relate te_sm to sm_sm across R2043;
te_sm.complete = false;
class_based = "_CB";
if ( is_ism )
  class_based = "";
end if;
te_sm.SEMname = ( te_class.GeneratedName + class_based ) + "_StateEventMatrix";
te_sm.state_names_array = ( "state_name_strings" + class_based );
te_sm.action_array = ( te_class.GeneratedName + class_based ) + "_acts";
te_sm.txn_action_array = ( te_class.GeneratedName + class_based ) + "_xacts";
te_sm.action_type = "StateAction_t";
te_sm.events_union = ( te_class.GeneratedName + class_based ) + "_Events_u";
//
// Create the Generated States and connect them to SM_STATE.
select many sm_states related by sm_sm->SM_STATE[R501];
te_sm.num_states = cardinality sm_states;
for each sm_state in sm_states
  create object instance te_state of TE_STATE;
  te_state.Name = sm_state.Name;
  te_state.Numb = sm_state.Numb;
  relate te_state to sm_state across R2037;
  te_state.enumerator = ( te_class.GeneratedName + class_based ) + ( "_STATE_" + T::s(i:te_state.Numb) );
  //
  // Create the Extended Actions (TE_ACT) and connect them to SM_ACT.
  select one sm_act related by sm_state->SM_MOAH[R511]->SM_AH[R513]->SM_ACT[R514];
  create object instance te_act of TE_ACT;
  relate sm_act to te_act across R2022;
  te_act.GeneratedName = ( te_class.GeneratedName + class_based ) + ( "_act" + T::s(i:te_state.Numb) );
  //.select many te_parms related by sm_state->SM_SEME[R503]->SM_SEVT[R503]->SM_EVT[R525]->SM_EVTDI[R532]->TE_PARM[R2031]
  r = ::FactoryTE_ABA( te_c:te_c, te_parms:empty_te_parms, scope:"", name:te_act.GeneratedName, subtypeKL:"SM_ACT", te_dt:void_te_dt );
  te_aba = r;
  relate te_act to te_aba across R2010;
end for;
//
// Sort the states for later state event matrix generation.
select many te_states related by sm_states->TE_STATE[R2037];
//   Sort the instances in the instance set <item_set> in ascending numeric
// order, based on the value of the Numb (integer) attribute value of
// each instance. The Order (integer) attribute value of each instance will
// be set to contain a value relative to Numb, indicating the position
// the instance has in the ordered set.
//   This function is definately *slow*, but will work with any objects
// which contain integer attributes <Numb> and <Order>.
item_set = te_states;
//
// Clear the Order attribute of all set members.
for each item in item_set
  item.Order = 0;
end for;
// simple pseudo bubble sort
item_set_copy = item_set;
for each item in item_set
  for each item_copy in item_set_copy
    if ( item_copy.Numb > item.Numb )
      item_copy.Order = item_copy.Order + 1;
    end if;
  end for;
end for;
for each te_state in te_states
  te_state.number = te_state.Order + 1;
  if ( 0 == te_state.Order )
    te_sm.initial_state = te_state.enumerator;
  end if;
end for;
//
// Create the actions for the transitions.
counter = 1;
// This is the hairiest traversal we do.  We are finding actions
// that actually have action language.
select many sm_acts related by sm_sm->SM_TXN[R505]->SM_TAH[R530]->SM_AH[R513]->SM_ACT[R514]->ACT_TAB[R688]->ACT_ACT[R698]->ACT_BLK[R666]->ACT_SMT[R602]->ACT_BLK[R602]->ACT_ACT[R666]->ACT_TAB[R698]->SM_ACT[R688];
for each sm_act in sm_acts
  // Create the Extended Actions (TE_ACT) and connect them to SM_ACT.
  create object instance te_act of TE_ACT;
  relate sm_act to te_act across R2022;
  te_act.GeneratedName = ( te_class.GeneratedName + class_based ) + ( "_xact" + T::s(i:counter) );
  te_act.number = counter;
  //.select many te_parms related by sm_act->SM_AH[R514]->SM_TAH[R513]->SM_TXN[R530]->SM_NSTXN[R507]->SM_SEME[R504]->SM_SEVT[R503]->SM_EVT[R525]->SM_EVTDI[R532]->TE_PARM[R2031]
  r = ::FactoryTE_ABA( te_c:te_c, te_parms:empty_te_parms, scope:"", name:te_act.GeneratedName, subtypeKL:"SM_ACT", te_dt:void_te_dt );
  te_aba = r;
  relate te_act to te_aba across R2010;
  counter = counter + 1;
end for;
te_sm.txn_action_count = counter - 1;
//
// Create the Generated Events and connect them to SM_EVT.
select many sm_evts related by sm_sm->SM_EVT[R502];
te_sm.num_events = cardinality sm_evts;
for each sm_evt in sm_evts
  create object instance te_evt of TE_EVT;
  relate te_evt to te_sm across R2071;
  te_evt.Name = sm_evt.Mning;
  te_evt.Numb = sm_evt.Numb;
  te_evt.Order = 0;
  te_evt.Used = false;
  te_evt.UsedCount = 0;
  te_evt.Priority = 0;
  relate te_evt to sm_evt across R2036;
  suffix = T::s(i:te_evt.Numb);
  select one sm_nlevt related by sm_evt->SM_SEVT[R525]->SM_NLEVT[R526];
  if ( not_empty sm_nlevt )
    // Non local event defined by a polymorphic event
    select one super_sm_evt related by sm_nlevt->SM_PEVT[R527]->SM_EVT[R525];
    select one super_obj related by super_sm_evt->SM_SM[R502]->SM_ISM[R517]->O_OBJ[R518];
    suffix = ( "_" + T::r(s:super_obj.Key_Lett) ) + ( "_PE" + T::s(i:super_sm_evt.Numb) );
  end if;
  te_evt.GeneratedName = ( te_class.GeneratedName + class_based ) + ( "event" + suffix );
  te_evt.Enumerator = T::u(s:te_evt.GeneratedName) + "NUM";
end for;
// Select the local events (only in this state machine), the "true" events
// (land here but also seen as polys) and polymorphic events.  Order the
// events starting with local then true then polys.
select many sm_levts related by sm_sm->SM_EVT[R502]->SM_SEVT[R525]->SM_LEVT[R526];
select many local_te_evts related by sm_levts->SM_SEVT[R526]->SM_EVT[R525]->TE_EVT[R2036];
//   Sort the instances in the instance set <item_set> in ascending numeric
// order, based on the value of the Numb (integer) attribute value of
// each instance. The Order (integer) attribute value of each instance will
// be set to contain a value relative to Numb, indicating the position
// the instance has in the ordered set.
//   This function is definately *slow*, but will work with any objects
// which contain integer attributes <Numb> and <Order>.
item_set1 = local_te_evts;
//
// Clear the Order attribute of all set members.
for each item1 in item_set1
  item1.Order = 0;
end for;
// simple pseudo bubble sort
item_set1_copy = item_set1;
for each item1 in item_set1
  for each item1_copy in item_set1_copy
    if ( item1_copy.Numb > item1.Numb )
      item1_copy.Order = item1_copy.Order + 1;
    end if;
  end for;
end for;
last_event_number = cardinality local_te_evts;
last_event_number = last_event_number - 1;
select many sm_sgevts related by sm_sm->SM_EVT[R502]->SM_SEVT[R525]->SM_SGEVT[R526];
select many signal_te_evts related by sm_sgevts->SM_SEVT[R526]->SM_EVT[R525]->TE_EVT[R2036];
for each te_evt in signal_te_evts
  // Mark signals as used to be sure we get code.
  te_evt.Used = true;
  te_evt.UsedCount = 1;
  last_event_number = last_event_number + 1;
  te_evt.Order = last_event_number;
  // Link each signal te_mact to its associated signal te_evts.
  select one te_mact related by te_evt->SM_EVT[R2036]->SM_SEVT[R525]->SM_SGEVT[R526]->SPR_PS[R528]->TE_MACT[R2051];
  if ( empty te_mact )
    select one te_mact related by te_evt->SM_EVT[R2036]->SM_SEVT[R525]->SM_SGEVT[R526]->SPR_RS[R529]->TE_MACT[R2053];
  end if;
  if ( not_empty te_mact )
    relate te_mact to te_evt across R2082;
  end if;
end for;
select many sm_nlevts related by sm_sm->SM_EVT[R502]->SM_SEVT[R525]->SM_NLEVT[R526];
select many true_te_evts related by sm_nlevts->SM_SEVT[R526]->SM_EVT[R525]->TE_EVT[R2036];
for each te_evt in true_te_evts
  // Mark polys and non-locals as used to be sure we get code.
  te_evt.Used = true;
  te_evt.UsedCount = 1;
  last_event_number = last_event_number + 1;
  te_evt.Order = last_event_number;
end for;
// Finally, order the polymorphic events.
// We need their Order to be greater than local and true events, since
// polys are not state event matrix events.
select many poly_te_evts related by sm_sm->SM_EVT[R502]->SM_PEVT[R525]->SM_EVT[R525]->TE_EVT[R2036];
for each te_evt in poly_te_evts
  // Mark polys and non-locals as used to be sure we get code.
  te_evt.Used = true;
  te_evt.UsedCount = 1;
  last_event_number = last_event_number + 1;
  te_evt.Order = last_event_number;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("22557ef4-cb79-43bd-ad4f-e171ab2384c7",
	"610356be-0d5d-4aff-affc-27d3750c7f0e",
	'is_ism',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("ecdba5b7-c0af-4499-a298-bb8fc55ea338",
	"610356be-0d5d-4aff-affc-27d3750c7f0e",
	'sm_sm',
	"bf37869c-96be-4535-a678-ac4311589cbb",
	0,
	'',
	"22557ef4-cb79-43bd-ad4f-e171ab2384c7",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("bf37869c-96be-4535-a678-ac4311589cbb",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<State Machine>',
	'',
	'',
	'../State Machine/State Machine.xtuml');
INSERT INTO S_SPARM
	VALUES ("ded0f12f-0bcc-4638-b5bb-4e7b230c5f9a",
	"610356be-0d5d-4aff-affc-27d3750c7f0e",
	'te_class',
	"f975acb7-4246-4a87-9c5a-75481f096785",
	0,
	'',
	"ecdba5b7-c0af-4499-a298-bb8fc55ea338",
	'');
INSERT INTO PE_PE
	VALUES ("610356be-0d5d-4aff-affc-27d3750c7f0e",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("f38a8853-0426-447d-8a0f-422aa43f6393",
	"00000000-0000-0000-0000-000000000000",
	'FactoryTE_MACT',
	'',
	'//
//
//============================================================================
// New and link message actions.
//============================================================================
te_parms = param.te_parms;
te_dt = param.te_dt;
te_c = param.te_c;
te_po = param.te_po;
message_name = param.message_name;
description = param.description;
subtypeKL = param.subtypeKL;
select any te_file from instances of TE_FILE;
select any te_sys from instances of TE_SYS;
select any te_target from instances of TE_TARGET;
select any te_thread from instances of TE_THREAD;
create object instance te_mact of TE_MACT;
relate te_mact to te_c across R2002;
relate te_mact to te_po across R2006;
// We cannot just look to see if this port is polymorphic, we have to go to the
// associated interface and see if any port tied to that interface is polymorphic.
// TODO - We would like to move this -up- and handle it when the ports are created,
//   perhaps use 2081 for the satisfaction.
select one c_i related by te_po->C_I[R2007];
select any te_po_poly related by c_i->TE_PO[R2007] where ( ( selected.Provision == te_po.Provision ) and selected.polymorphic );
if ( empty te_po_poly )
  te_mact.polymorphic = false;
else
  te_mact.polymorphic = true;
end if;
te_mact.Descrip = description;
te_mact.subtypeKL = subtypeKL;
te_mact.Provision = te_po.Provision;
te_mact.MessageName = message_name;
te_mact.InterfaceName = te_po.InterfaceName;
te_mact.PortName = te_po.GeneratedName;
te_mact.ComponentName = te_c.Name;
te_mact.GeneratedName = ( ( te_mact.ComponentName + "_" ) + ( te_mact.PortName + "_" ) ) + message_name;
if ( "C++" == te_target.language )
  te_mact.GeneratedName = ( te_mact.InterfaceName + "_" ) + message_name;
end if;
te_mact.GeneratedName = T::r(s:te_mact.GeneratedName);
te_mact.Name = te_mact.GeneratedName;
select any converted_bool_te_dt from instances of TE_DT where ( selected.Name == "integer" );
if ( ( "SystemC" == te_thread.flavor ) and ( te_sys.SystemCPortsType == "TLM" ) )
  for each te_parm in te_parms
    // If we are using TLM ports, convert booleans to integers
    select one param_te_dt related by te_parm->TE_DT[R2049];
    if ( 1 == param_te_dt.Core_Typ )
      relate te_parm to converted_bool_te_dt across R2049;
    end if;
  end for;
end if;
if ( ( te_mact.polymorphic ) and ( "SystemC" == te_thread.flavor ) )
  // If polymorphic, then add a parameter that we can use to distinguish 
  // which port the message came in through.
  select many s_dims from instances of S_DIM where ( false );
  select any portindex_te_dt from instances of TE_DT where ( selected.Name == "integer" );
  r = ::FactoryTE_PARM( s_dims:s_dims, te_dt:portindex_te_dt, prefix:"", name:"A00portindex", description:"architectural port selector", by_ref:0 );
  polymorphic_te_parm = r;
  for each te_parm in te_parms
    if ( 0 == te_parm.Order )
      relate polymorphic_te_parm to te_parm across R2041.''succeeds'';
    end if;
  end for;
  te_parms = te_parms;
end if;
r = ::FactoryTE_ABA( te_c:te_c, te_parms:te_parms, scope:te_mact.ComponentName, name:te_mact.GeneratedName, subtypeKL:"TE_MACT", te_dt:te_dt );
te_aba = r;
relate te_mact to te_aba across R2010;
return te_mact;
',
	"7268e543-f48e-4464-ba70-227deff22727",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("d3c718d2-04ac-4906-aa2f-d5a841b805d5",
	"f38a8853-0426-447d-8a0f-422aa43f6393",
	'te_parms',
	"954dc6bb-6e2a-47a5-aa3b-886723803133",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("de274a2c-4e09-4962-874b-ac64237e61d1",
	"f38a8853-0426-447d-8a0f-422aa43f6393",
	'te_dt',
	"5b20f7fb-179b-4254-a8de-922a50a1225d",
	0,
	'',
	"d3c718d2-04ac-4906-aa2f-d5a841b805d5",
	'');
INSERT INTO S_SPARM
	VALUES ("95a3eebd-829a-451f-bbfe-f81157374f4c",
	"f38a8853-0426-447d-8a0f-422aa43f6393",
	'te_c',
	"af13e9b7-f940-4a62-b6da-d8fb321a8a39",
	0,
	'',
	"de274a2c-4e09-4962-874b-ac64237e61d1",
	'');
INSERT INTO S_SPARM
	VALUES ("c96eb282-b332-4356-8594-c5d6b0c6ae52",
	"f38a8853-0426-447d-8a0f-422aa43f6393",
	'te_po',
	"472879e3-2bbf-4ca8-9fd2-6077af1f409a",
	0,
	'',
	"95a3eebd-829a-451f-bbfe-f81157374f4c",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("472879e3-2bbf-4ca8-9fd2-6077af1f409a",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Port>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO S_SPARM
	VALUES ("e2015390-7c99-4720-bc8b-a0c9df43dcb4",
	"f38a8853-0426-447d-8a0f-422aa43f6393",
	'message_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"c96eb282-b332-4356-8594-c5d6b0c6ae52",
	'');
INSERT INTO S_SPARM
	VALUES ("c2cc6d2e-dbc1-488c-ab11-59c063ac8cc4",
	"f38a8853-0426-447d-8a0f-422aa43f6393",
	'description',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"e2015390-7c99-4720-bc8b-a0c9df43dcb4",
	'');
INSERT INTO S_SPARM
	VALUES ("f6225a00-b936-4272-ad51-dd9e87420d52",
	"f38a8853-0426-447d-8a0f-422aa43f6393",
	'subtypeKL',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"c2cc6d2e-dbc1-488c-ab11-59c063ac8cc4",
	'');
INSERT INTO PE_PE
	VALUES ("f38a8853-0426-447d-8a0f-422aa43f6393",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_DT_PROXY
	VALUES ("7268e543-f48e-4464-ba70-227deff22727",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Message Action>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO S_SYNC
	VALUES ("6262e001-8518-4762-8bbb-30d16b01d24a",
	"00000000-0000-0000-0000-000000000000",
	'TE_EE_init',
	'',
	'//
//============================================================================
// Initialize instance of TE_EE.
//============================================================================
te_ee = param.te_ee;
te_c = param.te_c;
select any te_file from instances of TE_FILE;
select any te_target from instances of TE_TARGET;
component_scope = "";
if ( not_empty te_c )
  component_scope = te_c.Name + "_";
end if;
select one s_ee related by te_ee->S_EE[R2020];
// Default the registered name to be the key letters.
// Bridge wiring will override this default, but the default may
// allow the code to compile.
te_ee.Name = s_ee.Name;
te_ee.Descrip = s_ee.Descrip;
te_ee.Key_Lett = s_ee.Key_Lett;
te_ee.RegisteredName = component_scope + T::r(s:te_ee.Key_Lett);
te_ee.Included = false;
te_ee.Used = false;
te_ee.file = te_ee.RegisteredName + "_bridge";
// Leave alone if marked.
if ( "" == te_ee.Include_File )
  te_ee.Include_File = te_ee.file + ( "." + te_file.hdr_file_ext );
end if;
if ( "TIM" == s_ee.Key_Lett )
  // Time (TIM) EE
  te_ee.RegisteredName = "TIM";
  te_ee.Include_File = te_file.tim + ( "." + te_file.hdr_file_ext );
end if;
bridge_scope = "";
if ( "C" == te_target.language )
  bridge_scope = te_ee.RegisteredName + "_";
end if;
select many s_brgs related by s_ee->S_BRG[R19];
for each s_brg in s_brgs
  create object instance te_brg of TE_BRG;
  relate te_brg to s_brg across R2025;
  relate te_brg to te_ee across R2089;
  te_brg.EEkeyletters = s_ee.Key_Lett;
  te_brg.EEname = s_ee.Name;
  te_brg.Name = s_brg.Name;
  te_brg.GeneratedName = bridge_scope + s_brg.Name;
  select one te_dt related by s_brg->S_DT[R20]->TE_DT[R2021];
  select many te_parms related by s_brg->S_BPARM[R21]->TE_PARM[R2028];
  r = ::FactoryTE_ABA( te_c:te_c, te_parms:te_parms, scope:te_ee.RegisteredName, name:te_brg.GeneratedName, subtypeKL:"S_BRG", te_dt:te_dt );
  te_aba = r;
  relate te_brg to te_aba across R2010;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("8a2610db-4b2b-49b0-b850-773a456a27bc",
	"6262e001-8518-4762-8bbb-30d16b01d24a",
	'te_ee',
	"0be55aee-8704-4315-87a2-36ca7fc72b22",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("0be55aee-8704-4315-87a2-36ca7fc72b22",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended External Entity>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO S_SPARM
	VALUES ("583e3759-ef1c-4818-a4e8-a809c8ef258f",
	"6262e001-8518-4762-8bbb-30d16b01d24a",
	'te_c',
	"af13e9b7-f940-4a62-b6da-d8fb321a8a39",
	0,
	'',
	"8a2610db-4b2b-49b0-b850-773a456a27bc",
	'');
INSERT INTO PE_PE
	VALUES ("6262e001-8518-4762-8bbb-30d16b01d24a",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("6af5b470-b065-4c38-8cdc-fdcd552c435c",
	"00000000-0000-0000-0000-000000000000",
	'FactoryTE_ABA',
	'',
	'//
//============================================================================
// New and return instance of TE_ABA.
//============================================================================
te_c = param.te_c;
te_parms = param.te_parms;
scope = param.scope;
name = param.name;
subtypeKL = param.subtypeKL;
te_dt = param.te_dt;
select any te_target from instances of TE_TARGET;
create object instance te_aba of TE_ABA;
te_aba.SelfEventCount = 0;
te_aba.NonSelfEventCount = 0;
te_aba.subtypeKL = subtypeKL;
if ( not_empty te_c )
  relate te_aba to te_c across R2088;
end if;
duplicates_needed = false;
for each te_parm in te_parms
  select one existing_te_aba related by te_parm->TE_ABA[R2062];
  if ( empty existing_te_aba )
    relate te_parm to te_aba across R2062;
  else
    duplicates_needed = true;
  end if;
end for;
// This duplication is needed because multiple ports can use the same
// interface.  It would be nice to explore a method to avoid duplicating
// the parameter instances.
if ( duplicates_needed )
  select many duplicate_te_parms related by te_aba->TE_PARM[R2062] where ( false );
  // Find first te_parm.
  for each te_parm in te_parms
    break;
  end for;
  while ( not_empty te_parm )
    select one prev_te_parm related by te_parm->TE_PARM[R2041.''precedes''];
    if ( empty prev_te_parm )
      break;
    else
      te_parm = prev_te_parm;
    end if;
  end while;
  select one prev_te_parm related by te_parm->TE_PARM[R2041.''precedes''] where ( false );
  while ( not_empty te_parm )
    r = ::TE_PARM_duplicate( te_parm:te_parm );
    duplicate_te_parm = r;
    duplicate_te_parms = duplicate_te_parms;
    relate duplicate_te_parm to te_aba across R2062;
    if ( not_empty prev_te_parm )
      relate prev_te_parm to duplicate_te_parm across R2041.''succeeds'';
    end if;
    prev_te_parm = duplicate_te_parm;
    select one te_parm related by te_parm->TE_PARM[R2041.''succeeds''];
  end while;
  te_parms = duplicate_te_parms;
end if;
::te_parm_RenderParameters( te_parms:te_parms, te_aba:te_aba );
te_aba.scope = "";
if ( "C++" == te_target.language )
  te_aba.scope = scope + "::";
  if ( not_empty te_c )
    if ( ( "S_BRG" == te_aba.subtypeKL ) or ( "O_TFR" == te_aba.subtypeKL ) )
      if ( empty te_parms )
        te_aba.ParameterDefinition = ( " " + te_c.Name ) + " * thismodule";
        te_aba.ParameterDeclaration = ( " " + te_c.Name ) + " *";
      else
        te_aba.ParameterDefinition = ( ( " " + te_c.Name ) + ( " * thismodule," + te_aba.ParameterDefinition ) );
        te_aba.ParameterDeclaration = ( ( " " + te_c.Name ) + ( " *," + te_aba.ParameterDeclaration ) );
      end if;
    end if;
  end if;
end if;
te_aba.GeneratedName = name;
te_aba.ReturnDataType = te_dt.ExtName;
te_aba.dimensions = 0;
// In the C model compiler, treat strings as arrays.
if ( 4 == te_dt.Core_Typ )
  // string
  select any te_string from instances of TE_STRING;
  te_aba.dimensions = te_aba.dimensions + 1;
  te_aba.array_spec = ( te_aba.array_spec + "[" ) + ( te_string.max_string_length + "]" );
end if;
// Allow arrays (including strings) to be returned as pointers.
if ( te_aba.dimensions > 0 )
  te_aba.ReturnDataType = te_aba.ReturnDataType + " *";
end if;
return te_aba;
',
	"5fb4bb14-9533-4d0c-bec8-44e5e22fbbfd",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("37b04ade-9663-43b1-9304-342c03b3e808",
	"6af5b470-b065-4c38-8cdc-fdcd552c435c",
	'te_c',
	"af13e9b7-f940-4a62-b6da-d8fb321a8a39",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("bd409221-e686-437a-bd11-b7abb4f46716",
	"6af5b470-b065-4c38-8cdc-fdcd552c435c",
	'te_parms',
	"954dc6bb-6e2a-47a5-aa3b-886723803133",
	0,
	'',
	"37b04ade-9663-43b1-9304-342c03b3e808",
	'');
INSERT INTO S_SPARM
	VALUES ("8422fe64-7d26-4938-8267-39dd8e0d46b4",
	"6af5b470-b065-4c38-8cdc-fdcd552c435c",
	'scope',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"bd409221-e686-437a-bd11-b7abb4f46716",
	'');
INSERT INTO S_SPARM
	VALUES ("2bc21db6-01a9-4002-aa53-b08a6120287d",
	"6af5b470-b065-4c38-8cdc-fdcd552c435c",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"8422fe64-7d26-4938-8267-39dd8e0d46b4",
	'');
INSERT INTO S_SPARM
	VALUES ("3d3e61be-3123-436e-a54f-698437cf140b",
	"6af5b470-b065-4c38-8cdc-fdcd552c435c",
	'subtypeKL',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"2bc21db6-01a9-4002-aa53-b08a6120287d",
	'');
INSERT INTO S_SPARM
	VALUES ("34b0c54f-aef5-4b72-a232-d231b17db559",
	"6af5b470-b065-4c38-8cdc-fdcd552c435c",
	'te_dt',
	"5b20f7fb-179b-4254-a8de-922a50a1225d",
	0,
	'',
	"3d3e61be-3123-436e-a54f-698437cf140b",
	'');
INSERT INTO PE_PE
	VALUES ("6af5b470-b065-4c38-8cdc-fdcd552c435c",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a612dd95-c45f-4da5-a22e-e7d5fd27b94f",
	"00000000-0000-0000-0000-000000000000",
	'FactoryTE_PARM',
	'',
	'//
//
//============================================================================
// New and link up extended parameter.
//============================================================================
s_dims = param.s_dims;
te_dt = param.te_dt;
prefix = param.prefix;
name = param.name;
description = param.description;
by_ref = param.by_ref;
create object instance te_parm of TE_PARM;
te_parm.Order = 0;
te_parm.ParamBuffer = "";
te_parm.OALParamBuffer = "";
te_parm.Name = T::r(s:name);
te_parm.Descrip = description;
te_parm.By_Ref = by_ref;
te_parm.GeneratedName = prefix + name;
relate te_parm to te_dt across R2049;
// Set up the array dimensions for the parameter.
te_parm.dimensions = cardinality s_dims;
array_spec = "";
select one te_dim related by te_parm->TE_DIM[R2056] where ( false );
dim_index = 0;
while ( dim_index < te_parm.dimensions )
  for each s_dim in s_dims
    if ( s_dim.dimensionCount == dim_index )
      r = ::FactoryTE_DIM( s_dim:s_dim, predecessor_te_dim:te_dim );
      te_dim = r;
      if ( dim_index == 0 )
        relate te_parm to te_dim across R2056;
      end if;
      array_spec = ( array_spec + "[" ) + ( T::s(i:te_dim.elementCount) + "]" );
    end if;
  end for;
  dim_index = dim_index + 1;
  te_parm.By_Ref = 0;
end while;
te_parm.array_spec = array_spec;
// In the C model compiler, treat strings as arrays.
if ( 4 == te_dt.Core_Typ )
  // string
  select any te_string from instances of TE_STRING;
  te_parm.dimensions = te_parm.dimensions + 1;
  te_parm.array_spec = ( te_parm.array_spec + "[" ) + ( te_string.max_string_length + "]" );
  // In C (and other languages) arrays are never values but references.
  te_parm.By_Ref = 0;
end if;
return te_parm;
',
	"c1ec5f30-73a6-4381-a1e9-87b18c00ec88",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("8b3291e4-e03a-45dc-8fdc-cb6de40fd8cc",
	"a612dd95-c45f-4da5-a22e-e7d5fd27b94f",
	's_dims',
	"3a7c5808-2c8c-4c84-865f-70beb289afcd",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("3a7c5808-2c8c-4c84-865f-70beb289afcd",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Dimensions>',
	'',
	'',
	'../Domain/Domain.xtuml');
INSERT INTO S_SPARM
	VALUES ("044e7f38-7d5d-42db-a5d5-ee4e7304d885",
	"a612dd95-c45f-4da5-a22e-e7d5fd27b94f",
	'te_dt',
	"5b20f7fb-179b-4254-a8de-922a50a1225d",
	0,
	'',
	"8b3291e4-e03a-45dc-8fdc-cb6de40fd8cc",
	'');
INSERT INTO S_SPARM
	VALUES ("bbd5ced6-140f-4cb9-a27e-8ae5f88df9c7",
	"a612dd95-c45f-4da5-a22e-e7d5fd27b94f",
	'prefix',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"044e7f38-7d5d-42db-a5d5-ee4e7304d885",
	'');
INSERT INTO S_SPARM
	VALUES ("22db69a1-6bc4-4ed2-99b2-71b1b59bba1f",
	"a612dd95-c45f-4da5-a22e-e7d5fd27b94f",
	'name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"bbd5ced6-140f-4cb9-a27e-8ae5f88df9c7",
	'');
INSERT INTO S_SPARM
	VALUES ("19aa6f6c-8c35-423b-8b34-b450442c285f",
	"a612dd95-c45f-4da5-a22e-e7d5fd27b94f",
	'description',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"22db69a1-6bc4-4ed2-99b2-71b1b59bba1f",
	'');
INSERT INTO S_SPARM
	VALUES ("c38990ca-1753-4a09-a438-4e836908cc31",
	"a612dd95-c45f-4da5-a22e-e7d5fd27b94f",
	'by_ref',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"19aa6f6c-8c35-423b-8b34-b450442c285f",
	'');
INSERT INTO PE_PE
	VALUES ("a612dd95-c45f-4da5-a22e-e7d5fd27b94f",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_DT_PROXY
	VALUES ("c1ec5f30-73a6-4381-a1e9-87b18c00ec88",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Parameter>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO S_SYNC
	VALUES ("7e7c5f22-bc13-4393-b82e-1957806b2c8a",
	"00000000-0000-0000-0000-000000000000",
	'TE_PARM_duplicate',
	'',
	'//
//============================================================================
// Duplicate (copy) an instance of TE_PARM.
//============================================================================
te_parm = param.te_parm;
create object instance duplicate_te_parm of TE_PARM;
duplicate_te_parm.Order = te_parm.Order;
duplicate_te_parm.ParamBuffer = te_parm.ParamBuffer;
duplicate_te_parm.OALParamBuffer = te_parm.OALParamBuffer;
duplicate_te_parm.Name = te_parm.Name;
duplicate_te_parm.Descrip = te_parm.Descrip;
duplicate_te_parm.By_Ref = te_parm.By_Ref;
duplicate_te_parm.GeneratedName = te_parm.GeneratedName;
select one te_dt related by te_parm->TE_DT[R2049];
relate duplicate_te_parm to te_dt across R2049;
duplicate_te_parm.dimensions = te_parm.dimensions;
select one te_dim related by te_parm->TE_DIM[R2056];
if ( not_empty te_dim )
  relate duplicate_te_parm to te_dim across R2056;
else
  end if;
duplicate_te_parm.array_spec = te_parm.array_spec;
return duplicate_te_parm;
',
	"c1ec5f30-73a6-4381-a1e9-87b18c00ec88",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("7c05ec60-b95d-4a80-8887-15be19606627",
	"7e7c5f22-bc13-4393-b82e-1957806b2c8a",
	'te_parm',
	"c1ec5f30-73a6-4381-a1e9-87b18c00ec88",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("7e7c5f22-bc13-4393-b82e-1957806b2c8a",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("ef015bda-b730-4ecb-be7b-d7049458d36c",
	"00000000-0000-0000-0000-000000000000",
	'FactoryTE_LNK',
	'',
	'//
//============================================================================
// New and return instance of TE_LNK.
//============================================================================
act_lnk = param.act_lnk;
select one o_obj related by act_lnk->O_OBJ[R678];
select one te_class related by o_obj->TE_CLASS[R2019];
if ( not_empty te_class )
  create object instance te_lnk of TE_LNK;
  relate te_lnk to act_lnk across R2042;
  te_lnk.rel_phrase = act_lnk.Rel_Phrase;
    select one r_rel related by act_lnk->R_REL[R681];
  te_lnk.rel_number = r_rel.Numb;
  relate te_lnk to te_class across R2076;
  te_lnk.OAL = ( ( "->" + te_class.Key_Lett ) + ( "[R" + T::s(i:te_lnk.rel_number) ) );
  if ( "" != te_lnk.rel_phrase )
    te_lnk.OAL = ( te_lnk.OAL + "." ) + te_lnk.rel_phrase;
  end if;
  te_lnk.OAL = te_lnk.OAL + "]";
  te_lnk.iterator = "i" + te_lnk.linkage;
  te_lnk.first = false;
  te_lnk.last = false;
  rel_phrase = T::underscore(s:te_lnk.rel_phrase);
  select any te_oir related by r_rel->R_OIR[R201]->TE_OIR[R2035] where ( ( selected.Obj_ID == o_obj.Obj_ID ) and ( selected.rel_phrase == rel_phrase ) );
  if ( empty te_oir )
    select any te_oir related by r_rel->R_OIR[R201]->TE_OIR[R2035] where ( selected.Obj_ID == o_obj.Obj_ID );
  end if;
  te_lnk.linkage = te_oir.data_member;
  te_lnk.Mult = te_oir.Mult;
  te_lnk.assoc_type = te_oir.assoc_type;
  // Deal with associative reflexives.
  if ( "assr" == te_oir.assoc_type )
    r = ::is_reflexive( r_rel:r_rel );
    reflexive = r;
    if ( reflexive )
      select one r_aone related by r_rel->R_ASSOC[R206]->R_AONE[R209];
      select one r_aoth related by r_rel->R_ASSOC[R206]->R_AOTH[R210];
      if ( te_lnk.rel_phrase == r_aone.Txt_Phrs )
        te_lnk.Mult = r_aone.Mult;
      elif ( te_lnk.rel_phrase == r_aoth.Txt_Phrs )
        te_lnk.Mult = r_aoth.Mult;
      else
        T::print(s:"ERROR:  Unrecognized reflexive association:  RT::s(i:r_rel.Numb).");
        T::exit(i:13);
      end if;
      te_lnk.linkage = ( te_oir.data_member + "_" ) + rel_phrase;
    end if;
  end if;
end if;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("d27b0170-5617-40b4-a124-ec96f681c0e7",
	"ef015bda-b730-4ecb-be7b-d7049458d36c",
	'act_lnk',
	"44344236-6d4d-42b5-b14f-246447643355",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("44344236-6d4d-42b5-b14f-246447643355",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Chain Link>',
	'',
	'',
	'../Selection/Selection.xtuml');
INSERT INTO PE_PE
	VALUES ("ef015bda-b730-4ecb-be7b-d7049458d36c",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("2cd8362d-500b-488c-a463-c1b6facf4f05",
	"00000000-0000-0000-0000-000000000000",
	'associator_TE_LNK',
	'',
	'//
//============================================================================
// Create and insert a new TE_LNK between these two (for associator).
//============================================================================
left_te_lnk = param.left_te_lnk;
right_te_lnk = param.right_te_lnk;
create object instance te_lnk of TE_LNK;
te_lnk.rel_phrase = "";
// Insert the new link in between the left and right TE_LNKs.
relate te_lnk to right_te_lnk across R2075.''succeeds'';
select one r_rel related by right_te_lnk->ACT_LNK[R2042]->R_REL[R681];
te_lnk.rel_number = right_te_lnk.rel_number;
select one te_class related by r_rel->R_ASSOC[R206]->R_ASSR[R211]->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201]->TE_CLASS[R2019];
relate te_lnk to te_class across R2076;
// Leave OAL blank, because real OAL is not showing this link.
te_lnk.OAL = "";
select any te_oir related by r_rel->R_OIR[R201]->R_RGO[R203]->R_OIR[R203]->TE_OIR[R2035];
te_lnk.linkage = te_oir.data_member;
te_lnk.Mult = te_oir.Mult;
te_lnk.assoc_type = te_oir.assoc_type;
// Reflexive associatives put the relationship phrase onto the AONE/AOTH data members.
if ( "" != right_te_lnk.rel_phrase )
  te_lnk.linkage = ( te_lnk.linkage + "_" ) + T::underscore(s:right_te_lnk.rel_phrase);
end if;
if ( not_empty left_te_lnk )
  relate left_te_lnk to te_lnk across R2075.''succeeds'';
  te_lnk.left = left_te_lnk.linkage;
  te_lnk.first = false;
else
  te_lnk.left = te_lnk.linkage;
  te_lnk.first = true;
end if;
te_lnk.last = false;
te_lnk.iterator = "i" + te_lnk.linkage;
te_lnk.Mult = right_te_lnk.Mult;
right_te_lnk.Mult = 0;
right_te_lnk.left = te_lnk.linkage;
return te_lnk;
',
	"7fafab07-49e2-4355-8187-c89c6b120460",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("46eff49d-9046-4559-9130-6ed56a420eb7",
	"2cd8362d-500b-488c-a463-c1b6facf4f05",
	'left_te_lnk',
	"7fafab07-49e2-4355-8187-c89c6b120460",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("7fafab07-49e2-4355-8187-c89c6b120460",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended Chain Link>',
	'',
	'',
	'../Translation OAL/Translation OAL.xtuml');
INSERT INTO S_SPARM
	VALUES ("c06dc954-f0c6-4336-bd24-84e19136286b",
	"2cd8362d-500b-488c-a463-c1b6facf4f05",
	'right_te_lnk',
	"7fafab07-49e2-4355-8187-c89c6b120460",
	0,
	'',
	"46eff49d-9046-4559-9130-6ed56a420eb7",
	'');
INSERT INTO PE_PE
	VALUES ("2cd8362d-500b-488c-a463-c1b6facf4f05",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("83c74139-af4d-4883-a6b9-2dc098ff075c",
	"00000000-0000-0000-0000-000000000000",
	'detect_and_insert_associator_TE_LNK',
	'',
	'//
//============================================================================
// Detect and insert an associator TE_LNK if needed and adjust the te_lnk
// attributes according to the flavor of associative traversal.
// Accept a pair of te_lnk instances or a start_o_obj and one next_te_lnk.
//============================================================================
te_lnk = param.te_lnk;
next_te_lnk = param.next_te_lnk;
act_lnk = param.act_lnk;
next_act_lnk = param.next_act_lnk;
start_o_obj = param.start_o_obj;
if ( not_empty te_lnk )
  select one start_o_obj related by act_lnk->O_OBJ[R678];
end if;
if ( "aone" == next_te_lnk.assoc_type )
  select one r_aoth related by next_act_lnk->R_REL[R681]->R_ASSOC[R206]->R_AOTH[R210];
  if ( start_o_obj.Obj_ID == r_aoth.Obj_ID )
    // aoth -> aone
    r = ::associator_TE_LNK( left_te_lnk:te_lnk, right_te_lnk:next_te_lnk );
    te_lnk = r;
  else
    select one r_assr related by next_act_lnk->R_REL[R681]->R_ASSOC[R206]->R_ASSR[R211];
    if ( start_o_obj.Obj_ID == r_assr.Obj_ID )
      // assr -> aone
      next_te_lnk.Mult = 0;
    end if;
  end if;
elif ( "aoth" == next_te_lnk.assoc_type )
  select one r_aone related by next_act_lnk->R_REL[R681]->R_ASSOC[R206]->R_AONE[R209];
  if ( start_o_obj.Obj_ID == r_aone.Obj_ID )
    // aone -> aoth
    r = ::associator_TE_LNK( left_te_lnk:te_lnk, right_te_lnk:next_te_lnk );
    te_lnk = r;
  else
    select one r_assr related by next_act_lnk->R_REL[R681]->R_ASSOC[R206]->R_ASSR[R211];
    if ( start_o_obj.Obj_ID == r_assr.Obj_ID )
      // assr -> aoth
      next_te_lnk.Mult = 0;
    end if;
  end if;
elif ( "assr" == next_te_lnk.assoc_type )
  // For an associator, the multiplicity is that of the far side.
  select one r_aone related by next_act_lnk->R_REL[R681]->R_ASSOC[R206]->R_AONE[R209];
  select one r_aoth related by next_act_lnk->R_REL[R681]->R_ASSOC[R206]->R_AOTH[R210];
  if ( r_aone.Obj_ID == r_aoth.Obj_ID )
    // reflexive associative going from aone/aoth to assr
    if ( r_aone.Txt_Phrs == next_te_lnk.rel_phrase )
      next_te_lnk.Mult = r_aone.Mult;
    elif ( r_aoth.Txt_Phrs == next_te_lnk.rel_phrase )
      next_te_lnk.Mult = r_aoth.Mult;
    else
      T::print(s:"Invalid associative reflexive traversal from T::s(i:start_o_obj.Name)/T::s(i:start_o_obj.Key_Lett) to T::s(i:next_te_lnk.te_classGeneratedName).");
      T::exit(i:100);
    end if;
  elif ( start_o_obj.Obj_ID == r_aone.Obj_ID )
    // aone -> assr
    next_te_lnk.Mult = r_aoth.Mult;
  elif ( start_o_obj.Obj_ID == r_aoth.Obj_ID )
    // aoth -> assr
    next_te_lnk.Mult = r_aone.Mult;
  else
    T::print(s:"Invalid associative reflexive traversal from T::s(i:start_o_obj.Name)/T::s(i:start_o_obj.Key_Lett) to T::s(i:next_te_lnk.te_classGeneratedName).");
    T::exit(i:100);
  end if;
end if;
return te_lnk;
',
	"7fafab07-49e2-4355-8187-c89c6b120460",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("f8dc59d7-5699-43c5-903f-6579414b8901",
	"83c74139-af4d-4883-a6b9-2dc098ff075c",
	'te_lnk',
	"7fafab07-49e2-4355-8187-c89c6b120460",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("a87d8c30-0030-400a-9016-66818ec55808",
	"83c74139-af4d-4883-a6b9-2dc098ff075c",
	'next_te_lnk',
	"7fafab07-49e2-4355-8187-c89c6b120460",
	0,
	'',
	"f8dc59d7-5699-43c5-903f-6579414b8901",
	'');
INSERT INTO S_SPARM
	VALUES ("880bebb6-cce7-4b57-b5a8-1729a8df18ba",
	"83c74139-af4d-4883-a6b9-2dc098ff075c",
	'act_lnk',
	"44344236-6d4d-42b5-b14f-246447643355",
	0,
	'',
	"a87d8c30-0030-400a-9016-66818ec55808",
	'');
INSERT INTO S_SPARM
	VALUES ("fb520cf3-6730-4735-a956-34718a9c39fe",
	"83c74139-af4d-4883-a6b9-2dc098ff075c",
	'next_act_lnk',
	"44344236-6d4d-42b5-b14f-246447643355",
	0,
	'',
	"880bebb6-cce7-4b57-b5a8-1729a8df18ba",
	'');
INSERT INTO S_SPARM
	VALUES ("2dc373e9-4dfb-4000-bf3f-b7a4d4cfa823",
	"83c74139-af4d-4883-a6b9-2dc098ff075c",
	'start_o_obj',
	"d6b21eeb-39da-43bf-b503-c7bbc9ddf242",
	0,
	'',
	"fb520cf3-6730-4735-a956-34718a9c39fe",
	'');
INSERT INTO PE_PE
	VALUES ("83c74139-af4d-4883-a6b9-2dc098ff075c",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("c6f8d6dc-d19b-48e4-a03c-0816d6189b7a",
	"00000000-0000-0000-0000-000000000000",
	'TE_C_mark_nested_system',
	'',
	'//
// Recursive call to drill down and get all of the nested components and
// component references.
te_cs = param.te_cs;
for each te_c in te_cs
  te_c.included_in_build = true;
  select many nested_te_cs related by te_c->C_C[R2054]->PE_PE[R8003]->C_C[R8001]->TE_C[R2054];
  ::TE_C_mark_nested_system( te_cs:nested_te_cs );
  select many nested_te_cs related by te_c->C_C[R2054]->PE_PE[R8003]->CL_IC[R8001]->C_C[R4201]->TE_C[R2054];
  ::TE_C_mark_nested_system( te_cs:nested_te_cs );
  // TODO - SKB: What about components that are nested under package(s) inside this component?  The above 2
  // traversals assume the nested component or component reference is right under the component we''re processing.
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("73a530ff-65f1-4f63-909a-50fc0e78fbfd",
	"c6f8d6dc-d19b-48e4-a03c-0816d6189b7a",
	'te_cs',
	"524464d1-f305-4a50-8ac5-89e6a4df72f0",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("524464d1-f305-4a50-8ac5-89e6a4df72f0",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Extended Component>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("c6f8d6dc-d19b-48e4-a03c-0816d6189b7a",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("6eee0a70-66f5-4340-b427-c20b90f18711",
	"00000000-0000-0000-0000-000000000000",
	'TE_C_getContainingComponent',
	'',
	'//
// Recursively search upwards through the package hierarchy to find the
// containing (parent/owning) component.
ep_pkg = param.ep_pkg;
select any te_c from instances of TE_C where ( false );
// Return empty te_c for a top-level package with no containing package or component.
select one s_sys related by ep_pkg->S_SYS[R1401];
if ( empty s_sys )
  select one te_c related by ep_pkg->PE_PE[R8001]->C_C[R8003]->TE_C[R2054];
  if ( empty te_c )
    select one parent_ep_pkg related by ep_pkg->PE_PE[R8001]->EP_PKG[R8000];
    if ( not_empty parent_ep_pkg )
      r = ::TE_C_getContainingComponent( ep_pkg:parent_ep_pkg );
      te_c = r;
    end if;
  end if;
end if;
return te_c;
',
	"af13e9b7-f940-4a62-b6da-d8fb321a8a39",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("39ae6319-6fab-4741-aa7f-358ee1d3dab3",
	"6eee0a70-66f5-4340-b427-c20b90f18711",
	'ep_pkg',
	"bc235622-5914-4c46-87f7-e7209f83a876",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("bc235622-5914-4c46-87f7-e7209f83a876",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Package>',
	'',
	'',
	'../Instance Reference Data Types/Instance Reference Data Types.xtuml');
INSERT INTO PE_PE
	VALUES ("6eee0a70-66f5-4340-b427-c20b90f18711",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("f5b18a44-7a2e-48f4-b98d-ec67ee174c02",
	"00000000-0000-0000-0000-000000000000",
	'EP_PKG_getContainingPackage',
	'',
	'//
// Recursively search upwards through the component hierarcy to find the
// containing (parent/owning) package.
c_c = param.c_c;
select one ep_pkg related by c_c->PE_PE[R8001]->EP_PKG[R8000];
if ( empty ep_pkg )
  select one c_c related by c_c->PE_PE[R8001]->C_C[R8003];
  r = ::EP_PKG_getContainingPackage( c_c:c_c );
  ep_pkg = r;
end if;
return ep_pkg;
',
	"bc235622-5914-4c46-87f7-e7209f83a876",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("f89ae209-89c8-4db2-b3b1-587d9b8f6a62",
	"f5b18a44-7a2e-48f4-b98d-ec67ee174c02",
	'c_c',
	"3a196930-4610-45a6-baf8-3062a2ef9851",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("3a196930-4610-45a6-baf8-3062a2ef9851",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Component>',
	'',
	'',
	'../Instance Reference Data Types/Instance Reference Data Types.xtuml');
INSERT INTO PE_PE
	VALUES ("f5b18a44-7a2e-48f4-b98d-ec67ee174c02",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b190e7ad-6fd2-463f-b4a3-53ec9793f248",
	"00000000-0000-0000-0000-000000000000",
	'TE_C_sort',
	'',
	'//
// Sort a list of TE_Cs.
te_cs = param.te_cs;
// Declare an empty instance reference.
select any head_te_c related by te_cs->TE_C[R2017.''succeeds''] where ( false );
for each te_c in te_cs
  r = ::TE_C_insert( head_te_c:head_te_c, te_c:te_c );
  head_te_c = r;
end for;
return head_te_c;
',
	"af13e9b7-f940-4a62-b6da-d8fb321a8a39",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("59f25273-980d-4aaf-803f-b11a780a92d5",
	"b190e7ad-6fd2-463f-b4a3-53ec9793f248",
	'te_cs',
	"524464d1-f305-4a50-8ac5-89e6a4df72f0",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("b190e7ad-6fd2-463f-b4a3-53ec9793f248",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("f097a50d-17cb-485f-820f-ca15425001b8",
	"00000000-0000-0000-0000-000000000000",
	'TE_C_insert',
	'',
	'head_te_c = param.head_te_c;
te_c = param.te_c;
result = te_c;
if ( empty head_te_c )
  // Just starting.  Return te_c as head.
elif ( te_c.Name <= head_te_c.Name )
  // insert before
  relate te_c to head_te_c across R2017.''succeeds'';
else
  // find bigger
  result = head_te_c;
  prev_te_c = head_te_c;
  select one cursor_te_c related by head_te_c->TE_C[R2017.''succeeds''];
  while ( not_empty cursor_te_c )
    if ( te_c.Name <= cursor_te_c.Name )
      break;
    else
      prev_te_c = cursor_te_c;
      select one cursor_te_c related by cursor_te_c->TE_C[R2017.''succeeds''];
    end if;
  end while;
  relate prev_te_c to te_c across R2017.''succeeds'';
  if ( not_empty cursor_te_c )
    relate te_c to cursor_te_c across R2017.''succeeds'';
  end if;
end if;
return result;
',
	"af13e9b7-f940-4a62-b6da-d8fb321a8a39",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("bdaea846-1378-4918-8a36-b73ec4ce264d",
	"f097a50d-17cb-485f-820f-ca15425001b8",
	'head_te_c',
	"af13e9b7-f940-4a62-b6da-d8fb321a8a39",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("663d32e4-fd19-45b2-890b-23f63a4c24c6",
	"f097a50d-17cb-485f-820f-ca15425001b8",
	'te_c',
	"af13e9b7-f940-4a62-b6da-d8fb321a8a39",
	0,
	'',
	"bdaea846-1378-4918-8a36-b73ec4ce264d",
	'');
INSERT INTO PE_PE
	VALUES ("f097a50d-17cb-485f-820f-ca15425001b8",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("997b3ee1-55be-457a-9ed5-0102753346da",
	"00000000-0000-0000-0000-000000000000",
	'class_sort',
	'',
	'//
// Sort a list of TE_CLASSes.
te_classs = param.te_classs;
// Declare an empty instance reference.
select any head_te_class related by te_classs->TE_CLASS[R2092.''succeeds''] where ( false );
for each te_class in te_classs
  end for;
for each te_class in te_classs
  r = ::class_insert( head_te_class:head_te_class, te_class:te_class );
  head_te_class = r;
end for;
return head_te_class;
',
	"f975acb7-4246-4a87-9c5a-75481f096785",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("7443814e-4fd7-4494-b9fa-0715595acc2e",
	"997b3ee1-55be-457a-9ed5-0102753346da",
	'te_classs',
	"54de650e-cdb2-4d65-ad98-5eb87386d7e7",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("54de650e-cdb2-4d65-ad98-5eb87386d7e7",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Extended Class>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("997b3ee1-55be-457a-9ed5-0102753346da",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("59a67f1c-b21f-4c07-9432-3aaad5a922c7",
	"00000000-0000-0000-0000-000000000000",
	'class_insert',
	'',
	'head_te_class = param.head_te_class;
te_class = param.te_class;
result = te_class;
if ( empty head_te_class )
  // Just starting.  Return te_class as head.
else
  lkey = T::s(i:te_class.Numb) + te_class.GeneratedName;
  rkey = T::s(i:head_te_class.Numb) + head_te_class.GeneratedName;
  if ( lkey <= rkey )
    // insert before
    relate te_class to head_te_class across R2092.''succeeds'';
  else
    // find bigger
    result = head_te_class;
    prev_te_class = head_te_class;
    select one cursor_te_class related by head_te_class->TE_CLASS[R2092.''succeeds''];
    while ( not_empty cursor_te_class )
      rkey = T::s(i:cursor_te_class.Numb) + cursor_te_class.GeneratedName;
      if ( lkey <= rkey )
        break;
      else
        prev_te_class = cursor_te_class;
        select one cursor_te_class related by cursor_te_class->TE_CLASS[R2092.''succeeds''];
      end if;
    end while;
    relate prev_te_class to te_class across R2092.''succeeds'';
    if ( not_empty cursor_te_class )
      relate te_class to cursor_te_class across R2092.''succeeds'';
    end if;
  end if;
end if;
return result;
',
	"f975acb7-4246-4a87-9c5a-75481f096785",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("7f0e52c4-82ea-479c-acb4-54020ba1816e",
	"59a67f1c-b21f-4c07-9432-3aaad5a922c7",
	'head_te_class',
	"f975acb7-4246-4a87-9c5a-75481f096785",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("c345484f-10b6-44cf-a437-01aace5c1e37",
	"59a67f1c-b21f-4c07-9432-3aaad5a922c7",
	'te_class',
	"f975acb7-4246-4a87-9c5a-75481f096785",
	0,
	'',
	"7f0e52c4-82ea-479c-acb4-54020ba1816e",
	'');
INSERT INTO PE_PE
	VALUES ("59a67f1c-b21f-4c07-9432-3aaad5a922c7",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("06485ed8-96d8-4d90-ae91-34278b5da4e6",
	"00000000-0000-0000-0000-000000000000",
	'mact_sort',
	'',
	'//
// Sort a list of TE_MACTs.
te_macts = param.te_macts;
// Declare an empty instance reference.
select any head_te_mact related by te_macts->TE_MACT[R2083.''succeeds''] where ( false );
for each te_mact in te_macts
  end for;
for each te_mact in te_macts
  r = ::mact_insert( head_te_mact:head_te_mact, te_mact:te_mact );
  head_te_mact = r;
end for;
counter = 0;
te_mact = head_te_mact;
while ( not_empty te_mact )
  te_mact.Order = counter;
  counter = counter + 1;
  select one te_mact related by te_mact->TE_MACT[R2083.''succeeds''];
end while;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("c2a74f68-c108-4b55-99d0-5312d80f9bca",
	"06485ed8-96d8-4d90-ae91-34278b5da4e6",
	'te_macts',
	"f368fddc-d16b-426c-81ab-525461c2ac04",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("f368fddc-d16b-426c-81ab-525461c2ac04",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Extended Message Action>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("06485ed8-96d8-4d90-ae91-34278b5da4e6",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("93f76872-3e14-40da-8502-2a2b72ce4796",
	"00000000-0000-0000-0000-000000000000",
	'mact_insert',
	'',
	'head_te_mact = param.head_te_mact;
te_mact = param.te_mact;
result = te_mact;
if ( empty head_te_mact )
  // Just starting.  Return te_mact as head.
else
  lkey = te_mact.Name;
  rkey = head_te_mact.Name;
  if ( lkey <= rkey )
    // insert before
    relate te_mact to head_te_mact across R2083.''succeeds'';
  else
    // find bigger
    result = head_te_mact;
    prev_te_mact = head_te_mact;
    select one cursor_te_mact related by head_te_mact->TE_MACT[R2083.''succeeds''];
    while ( not_empty cursor_te_mact )
      rkey = cursor_te_mact.Name;
      if ( lkey <= rkey )
        break;
      else
        prev_te_mact = cursor_te_mact;
        select one cursor_te_mact related by cursor_te_mact->TE_MACT[R2083.''succeeds''];
      end if;
    end while;
    relate prev_te_mact to te_mact across R2083.''succeeds'';
    if ( not_empty cursor_te_mact )
      relate te_mact to cursor_te_mact across R2083.''succeeds'';
    end if;
  end if;
end if;
return result;
',
	"7268e543-f48e-4464-ba70-227deff22727",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("75c59a22-f063-400c-85f7-1654295c087c",
	"93f76872-3e14-40da-8502-2a2b72ce4796",
	'head_te_mact',
	"7268e543-f48e-4464-ba70-227deff22727",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("aeaa6da7-f7b6-402e-97bc-acfd9720bd81",
	"93f76872-3e14-40da-8502-2a2b72ce4796",
	'te_mact',
	"7268e543-f48e-4464-ba70-227deff22727",
	0,
	'',
	"75c59a22-f063-400c-85f7-1654295c087c",
	'');
INSERT INTO PE_PE
	VALUES ("93f76872-3e14-40da-8502-2a2b72ce4796",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("e21313dd-f4f3-41db-970a-97811e638c4b",
	"00000000-0000-0000-0000-000000000000",
	'blk_indentwhitespace',
	'',
	'//
// indentation maker
//
indentation = param.indentation;
result = "";
while ( 0 < indentation )
  indentation = indentation - 1;
  result = result + "  ";
end while;
return result;
',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("96941198-31b6-46df-a625-0e532e882d6d",
	"e21313dd-f4f3-41db-970a-97811e638c4b",
	'indentation',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("e21313dd-f4f3-41db-970a-97811e638c4b",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("512bb350-7fb7-4e09-9918-76bc3400f2a0",
	"00000000-0000-0000-0000-000000000000",
	'gen_parameter_list',
	'',
	'//====================================================================
//
// $RCSfile: q.utils.arc,v $
//
// (c) Copyright 1998-2013 Mentor Graphics Corporation  All rights reserved.
//
//====================================================================
//
v_pars = param.v_pars;
prefix_param_delimiter = param.prefix_param_delimiter;
invocation_flavor = param.invocation_flavor;
//
code = "";
OAL = "";
select any te_parm from instances of TE_PARM;
if ( not_empty v_pars )
  select any te_string from instances of TE_STRING;
  item_count = 0;
  select many te_pars related by v_pars->TE_PAR[R2063];
  for each te_par in te_pars
    select one te_parm related by te_par->TE_PARM[R2091];
    te_par.Order = te_parm.Order;
    item_count = item_count + 1;
  end for;
  item_number = 0;
  param_delimiter = "";
  if ( prefix_param_delimiter )
    param_delimiter = ",";
  end if;
  while ( item_number < item_count )
    select any te_par related by v_pars->TE_PAR[R2063] where ( selected.Order == item_number );
    select one v_par related by te_par->V_PAR[R2063];
    select one v_val related by v_par->V_VAL[R800];
    select one te_val related by v_val->TE_VAL[R2040];
    OAL = ( OAL + param_delimiter ) + te_val.OAL;
    if ( "" == te_val.buffer )
      ::gen_value( v_val:v_val );
    end if;
    code = code + param_delimiter;
    //
    // Determine if the parameter is of type string.
    // If string, check to see if this parameter is actually a function.
    // If so, declare a variable in this scope to hold the return string.
    // Do so by traversing to the te_blk instance to add the declaration.
    stringbody = false;
    if ( 0 == te_par.By_Ref )
      select one te_dt related by v_val->S_DT[R820]->TE_DT[R2021];
      if ( 4 == te_dt.Core_Typ )
        // Check the four types of returnable action bodies for string.
        select one v_trv related by v_val->V_TRV[R801];
        if ( not_empty v_trv )
          stringbody = true;
        else
          select one v_msv related by v_val->V_MSV[R801];
          if ( not_empty v_msv )
            stringbody = true;
          else
            select one v_brv related by v_val->V_BRV[R801];
            if ( not_empty v_brv )
              stringbody = true;
            else
              select one v_fnv related by v_val->V_FNV[R801];
              if ( not_empty v_fnv )
                stringbody = true;
              end if;
            end if;
          end if;
        end if;
        if ( stringbody )
          te_par.buffer = "v_sretval"; // + T::s(i:info.unique_num);
          select one te_blk related by v_val->ACT_BLK[R826]->TE_BLK[R2016];
          te_blk.declaration = ( ( ( te_blk.declaration + te_dt.ExtName ) + ( " " + te_par.buffer ) ) + ( "[" + te_string.max_string_length ) ) + "];";
          code = ( ( code + te_string.strcpy ) + ( "( " + te_par.buffer ) ) + ", ";
        end if;
      end if;
      //
      //
      code = code + te_val.buffer;
      if ( stringbody )
        code = code + ")";
      end if;
    else
      code = ( ( code + "&(" ) + ( te_val.buffer + ")" ) );
    end if;
    param_delimiter = ", ";
    item_number = item_number + 1;
  end while;
end if;
te_parm.ParamBuffer = code;
te_parm.OALParamBuffer = OAL;
return te_parm;
',
	"c1ec5f30-73a6-4381-a1e9-87b18c00ec88",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("b11509ef-29c2-4ca5-bc9c-9810632ea06b",
	"512bb350-7fb7-4e09-9918-76bc3400f2a0",
	'v_pars',
	"ae5b840e-5312-4865-ae17-5c9bba997543",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("ae5b840e-5312-4865-ae17-5c9bba997543",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Actual Parameter>',
	'',
	'',
	'../Value/Value.xtuml');
INSERT INTO S_SPARM
	VALUES ("3deb5854-a449-405b-9352-1df443b92a84",
	"512bb350-7fb7-4e09-9918-76bc3400f2a0",
	'prefix_param_delimiter',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"b11509ef-29c2-4ca5-bc9c-9810632ea06b",
	'');
INSERT INTO S_SPARM
	VALUES ("22e0e1dd-a5ac-461c-b170-62d0e9693a11",
	"512bb350-7fb7-4e09-9918-76bc3400f2a0",
	'invocation_flavor',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"3deb5854-a449-405b-9352-1df443b92a84",
	'');
INSERT INTO PE_PE
	VALUES ("512bb350-7fb7-4e09-9918-76bc3400f2a0",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("07ae5e9f-6eb9-4b7f-8736-b0e2a1f26fd3",
	"00000000-0000-0000-0000-000000000000",
	'is_reflexive',
	'',
	'//
//====================================================================
//
r_rel = param.r_rel;
//
result = false;
select one r_simp related by r_rel->R_SIMP[R206];
if ( not_empty r_simp )
  select many r_parts related by r_simp->R_PART[R207];
  if ( ( cardinality r_parts ) > 1 )
    select any first_r_part related by r_simp->R_PART[R207];
    select any second_r_part related by r_simp->R_PART[R207] where ( selected.OIR_ID != first_r_part.OIR_ID );
    if ( first_r_part.Obj_ID == second_r_part.Obj_ID )
      result = true;
    end if;
  else
    select any r_part related by r_simp->R_PART[R207];
    select one r_form related by r_simp->R_FORM[R208];
    if ( not_empty r_form )
      if ( r_part.Obj_ID == r_form.Obj_ID )
        result = true;
      end if;
    end if;
  end if;
else
  select one r_assoc related by r_rel->R_ASSOC[R206];
  if ( not_empty r_assoc )
    select one r_aone related by r_assoc->R_AONE[R209];
    select one r_aoth related by r_assoc->R_AOTH[R210];
    if ( r_aone.Obj_ID == r_aoth.Obj_ID )
      result = true;
    end if;
  end if;
end if;
return result;
',
	"ba5eda7a-def5-0000-0000-000000000001",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("8a73df9c-f196-40fe-ae54-8f16408b6ef4",
	"07ae5e9f-6eb9-4b7f-8736-b0e2a1f26fd3",
	'r_rel',
	"620e9be8-e289-47ed-9279-69b359c269c5",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("620e9be8-e289-47ed-9279-69b359c269c5",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Association>',
	'',
	'',
	'../Association/Association.xtuml');
INSERT INTO PE_PE
	VALUES ("07ae5e9f-6eb9-4b7f-8736-b0e2a1f26fd3",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("ea58dd67-8339-464e-be05-43d6068ebd7e",
	"00000000-0000-0000-0000-000000000000",
	't_oal_smt_event_parameters',
	'',
	'//------------------------------------------------
// Note the use of p_ here.  It is hard-coded and depends upon
// matching the prefix used in initialization population query.
evt_msg_var = param.evt_msg_var;
parameter = param.parameter;
value = param.value;
value_type = param.value_type;
ws = param.ws;
result = "";
select any te_eq from instances of TE_EQ;
if ( "" == evt_msg_var )
  evt_msg_var = te_eq.event_message_variable;
end if;
if ( 4 == value_type )
  // string
  select any te_string from instances of TE_STRING;
  select any te_instance from instances of TE_INSTANCE;
  result = ws + te_instance.module + te_string.strcpy + "(" + evt_msg_var + "->p_" + T::underscore(s:parameter) + ", " + value +");" ;
else
  result = ws + evt_msg_var+"->p_" + parameter + " = " + value + ";";
end if;
return result;
',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("bed348f5-7f3c-4d7d-98f3-32896cb90588",
	"ea58dd67-8339-464e-be05-43d6068ebd7e",
	'evt_msg_var',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("2a4bba70-43f8-4376-b69f-a431ce86b24c",
	"ea58dd67-8339-464e-be05-43d6068ebd7e",
	'parameter',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"bed348f5-7f3c-4d7d-98f3-32896cb90588",
	'');
INSERT INTO S_SPARM
	VALUES ("da420a84-05f7-4a7c-a3a2-9d248f20614d",
	"ea58dd67-8339-464e-be05-43d6068ebd7e",
	'value',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"2a4bba70-43f8-4376-b69f-a431ce86b24c",
	'');
INSERT INTO S_SPARM
	VALUES ("3afbe081-9bf3-44b4-921b-0c3279763052",
	"ea58dd67-8339-464e-be05-43d6068ebd7e",
	'value_type',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"da420a84-05f7-4a7c-a3a2-9d248f20614d",
	'');
INSERT INTO S_SPARM
	VALUES ("3777e065-1692-4e7f-bbe0-25d384fed2e4",
	"ea58dd67-8339-464e-be05-43d6068ebd7e",
	'ws',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"3afbe081-9bf3-44b4-921b-0c3279763052",
	'');
INSERT INTO PE_PE
	VALUES ("ea58dd67-8339-464e-be05-43d6068ebd7e",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("2e8dae90-bc3e-4b10-b57d-d57540f889a0",
	"00000000-0000-0000-0000-000000000000",
	'TagDataTypePrecision',
	'',
	'//============================================================================
// $RCSfile: m.datatype.arc,v $
//
// Description:
// This archetype file contains the implementation functions for marks
// specified in the (user supplied/modified) datatype.clr file.
//
// Notice:
// (C) Copyright 1998-2013 Mentor Graphics Corporation
//     All rights reserved.
//
// This document contains confidential and proprietary information and
// property of Mentor Graphics Corp.  No part of this document may be
// reproduced without the express written permission of Mentor Graphics Corp.
//============================================================================
//
//============================================================================
component_name = param.component_name;
dt_name = param.dt_name;
tagged_name = param.tagged_name;
initial_value = param.initial_value;
component_name = T::r(s:component_name);
select any tm_precision from instances of TM_PRECISION where ( ( selected.Domain == component_name ) and ( selected.DT_name == dt_name ) );
if ( empty tm_precision )
  create object instance tm_precision of TM_PRECISION;
end if;
tm_precision.Domain = component_name;
tm_precision.DT_name = dt_name;
tm_precision.xName = tagged_name;
tm_precision.initial_value = initial_value;
T::print(s:"TagDataTypePrecision:  T::s(i:dt_name) in T::s(i:component_name) given T::s(i:tagged_name) precision with T::s(i:initial_value).");
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("9c8cd158-905e-426e-95bc-454525db8f59",
	"2e8dae90-bc3e-4b10-b57d-d57540f889a0",
	'component_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("09e545f2-9cfb-4c37-8a70-13a8aaaae433",
	"2e8dae90-bc3e-4b10-b57d-d57540f889a0",
	'dt_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"9c8cd158-905e-426e-95bc-454525db8f59",
	'');
INSERT INTO S_SPARM
	VALUES ("38ad2bda-2b0d-4277-abfe-35c5c1fa8c20",
	"2e8dae90-bc3e-4b10-b57d-d57540f889a0",
	'tagged_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"09e545f2-9cfb-4c37-8a70-13a8aaaae433",
	'');
INSERT INTO S_SPARM
	VALUES ("74e453e1-eb60-41c8-b632-b89e16946d5d",
	"2e8dae90-bc3e-4b10-b57d-d57540f889a0",
	'initial_value',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"38ad2bda-2b0d-4277-abfe-35c5c1fa8c20",
	'');
INSERT INTO PE_PE
	VALUES ("2e8dae90-bc3e-4b10-b57d-d57540f889a0",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("aec353ec-0cd2-4850-b246-a4222dac57c2",
	"00000000-0000-0000-0000-000000000000",
	'MapDataTypeAsPointer',
	'',
	'//
//============================================================================
// Map a user defined data type to a pointer.  This allows the system
// to pass arbitrarily shaped data around by simply pointing to it.
//============================================================================
component_name = param.component_name;
dt_name = param.dt_name;
pointer_type = param.pointer_type;
include_file = param.include_file;
component_name = T::r(s:component_name);
select any tm_pointer from instances of TM_POINTER where ( ( selected.Domain == component_name ) and ( selected.DT_name == dt_name ) );
if ( empty tm_pointer )
  create object instance tm_pointer of TM_POINTER;
end if;
tm_pointer.Domain = component_name;
tm_pointer.DT_name = dt_name;
tm_pointer.pointer_type = pointer_type;
tm_pointer.include_file = include_file;
T::print(s:"MapDataTypeAsPointer:  T::s(i:dt_name) in T::s(i:component_name) given T::s(i:pointer_type) mapping (T::s(i:include_file)).");
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("d8c9c8b8-c846-4386-8bf0-966c47542a10",
	"aec353ec-0cd2-4850-b246-a4222dac57c2",
	'component_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("a68b8e14-ecae-44cc-826b-4fcb37b06dde",
	"aec353ec-0cd2-4850-b246-a4222dac57c2",
	'dt_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"d8c9c8b8-c846-4386-8bf0-966c47542a10",
	'');
INSERT INTO S_SPARM
	VALUES ("45e48f82-ea07-40e6-ad6a-18ae595f18c1",
	"aec353ec-0cd2-4850-b246-a4222dac57c2",
	'pointer_type',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"a68b8e14-ecae-44cc-826b-4fcb37b06dde",
	'');
INSERT INTO S_SPARM
	VALUES ("d2ab5fce-be22-45f4-b2e9-82467f40eb05",
	"aec353ec-0cd2-4850-b246-a4222dac57c2",
	'include_file',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"45e48f82-ea07-40e6-ad6a-18ae595f18c1",
	'');
INSERT INTO PE_PE
	VALUES ("aec353ec-0cd2-4850-b246-a4222dac57c2",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("44a223c3-c30e-4973-97e1-b8633f7db5cf",
	"00000000-0000-0000-0000-000000000000",
	'TagEnumeratorDiscreteValue',
	'',
	'//
//============================================================================
// Specifying Values for Enumerators
//
// To indicate to the model compiler that a user defined enumeration
// data type enumerator (defined in the BridgePoint Subsystem Partitioning
// Model (SPM) component data editor) shall have a value other than the default,
// use the following invocation:
//
// TagEnumeratorDiscreteValue( "component", "enumeration", "enumerator", "value"
//
// Where the input parameters are:
//   component - Registered component name.  Use "*" to indicate a system wide
//     enumeration data type (to be applied to all components containing
//     the user defined enumeration data type).
//   enumeration - name of the enumeration data type as known in the
//     application analysis
//   enumerator - name of the enumerator as known in the application analysis
//   value - a string containing the value to be assigned to the enumerator
//
// Examples:
//  Domain specific:
//   .invoke TagEnumeratorDiscreteValue( "MO", "tube_wattage", "low", "4" )
//   .invoke TagEnumeratorDiscreteValue( "MO", "tube_wattage", "med", "0x20" )
//  System Wide:
//   .invoke TagEnumeratorDiscreteValue( "*", "tube_wattage", "high", "0x40" )
//
//============================================================================
component_name = param.component_name;
enumeration = param.enumeration;
enumerator = param.enumerator;
value = param.value;
component_name = T::r(s:component_name);
select any tm_enumval from instances of TM_ENUMVAL where ( ( ( selected.Domain == component_name ) and ( selected.enumeration == enumeration ) ) and ( selected.enumerator == enumerator ) );
if ( empty tm_enumval )
  create object instance tm_enumval of TM_ENUMVAL;
end if;
tm_enumval.Domain = component_name;
tm_enumval.enumeration = enumeration;
tm_enumval.enumerator = enumerator;
tm_enumval.value = value;
T::print(s:"TagEnumeratorDiscreteValue:  T::s(i:enumeration)::T::s(i:enumerator) in T::s(i:component_name) given discrete value T::s(i:value).");
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("4728f70b-ae72-417e-8b6b-35cdddb2d827",
	"44a223c3-c30e-4973-97e1-b8633f7db5cf",
	'component_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("29e68e9a-187d-4557-967c-6c2cf84f373a",
	"44a223c3-c30e-4973-97e1-b8633f7db5cf",
	'enumeration',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"4728f70b-ae72-417e-8b6b-35cdddb2d827",
	'');
INSERT INTO S_SPARM
	VALUES ("d4ccadc4-0ffc-49b2-8814-092c18923a84",
	"44a223c3-c30e-4973-97e1-b8633f7db5cf",
	'enumerator',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"29e68e9a-187d-4557-967c-6c2cf84f373a",
	'');
INSERT INTO S_SPARM
	VALUES ("24afe97e-93a9-45d3-9c1d-c3416135dd2b",
	"44a223c3-c30e-4973-97e1-b8633f7db5cf",
	'value',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"d4ccadc4-0ffc-49b2-8814-092c18923a84",
	'');
INSERT INTO PE_PE
	VALUES ("44a223c3-c30e-4973-97e1-b8633f7db5cf",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("21c7ec83-1dad-44e5-a572-cf7e12928d58",
	"00000000-0000-0000-0000-000000000000",
	'TagUninitializedEnumerationValue',
	'',
	'//
//============================================================================
// Specifying Value for the Default Un-Initialized Enumerator
//
// To indicate to the software architecture that the un-initialized enumerator
// of an enumeration (defined in the BridgePoint Subsystem Partitioning Model
// (SPM) component data editor) shall have a value other than the default,
// use the following invocation:
//
// TagUninitializedEnumerationValue( "component", "enumeration", "value" )
//
// Where the input parameters are:
//   component - Registered component name.  Use "*" to indicate a system wide
//     enumeration data type (to be applied to all components containing
//     the user defined enumeration data type).
//   enumeration - Name of the enumeration data type as known in the
//     application analysis. Use "*" to indicate ALL enumerations.
//   value - A string containing the value to be assigned to the uninitialized
//     enumerator.
//
// Examples:
//  Domain specific:
//   .invoke TagUninitializedEnumerationValue( "MO", "tube_wattage", "4" )
//  All Enumerations in Domain:
//   .invoke TagUninitializedEnumerationValue( "MO", "*", "40" )
//  System Wide:
//   .invoke TagUninitializedEnumerationValue( "*", "tube_wattage", "20" )
//  All Enumerations in All Domains:
//   .invoke TagUninitializedEnumerationValue( "*", "*", "100" )
//
//============================================================================
component_name = param.component_name;
enumeration = param.enumeration;
value = param.value;
component_name = T::r(s:component_name);
select any tm_enuminit from instances of TM_ENUMINIT where ( ( selected.Domain == component_name ) and ( selected.enumeration == enumeration ) );
if ( empty tm_enuminit )
  create object instance tm_enuminit of TM_ENUMINIT;
end if;
tm_enuminit.Domain = component_name;
tm_enuminit.enumeration = enumeration;
tm_enuminit.value = value;
T::print(s:"TagUninitializedEnumerationValue:  T::s(i:enumeration) in T::s(i:component_name) given default uninitialized value T::s(i:value).");
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("a8bcb13a-69c8-4e11-879d-e3813d828bfb",
	"21c7ec83-1dad-44e5-a572-cf7e12928d58",
	'component_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("026441fa-65c6-4061-8b69-4c41c6f97341",
	"21c7ec83-1dad-44e5-a572-cf7e12928d58",
	'enumeration',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"a8bcb13a-69c8-4e11-879d-e3813d828bfb",
	'');
INSERT INTO S_SPARM
	VALUES ("56f0d466-fa30-4444-8422-832d3b371981",
	"21c7ec83-1dad-44e5-a572-cf7e12928d58",
	'value',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"026441fa-65c6-4061-8b69-4c41c6f97341",
	'');
INSERT INTO PE_PE
	VALUES ("21c7ec83-1dad-44e5-a572-cf7e12928d58",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("3a205373-28bd-473c-83b5-7a02b413c195",
	"00000000-0000-0000-0000-000000000000",
	'AssignDirectToUDTPackage',
	'',
	'//
//
//============================================================================
// Specifying "Direct" manipulation to "SystemC UDT Pacakage"
//
// to indicate that this UDT package should be generated using its name
// instead of core type
//============================================================================
package_name = param.package_name;
T::print(s:"AssignDirectToUDTPackage is not a supported marking function.");
T::exit(i:1);
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("082785ce-0780-49f5-a212-70fb74d7900b",
	"3a205373-28bd-473c-83b5-7a02b413c195",
	'package_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("3a205373-28bd-473c-83b5-7a02b413c195",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("8bd9876a-a195-4cf1-a580-063eb4130d5d",
	"00000000-0000-0000-0000-000000000000",
	'EnableTasking',
	'',
	'//============================================================================
// $RCSfile: m.system.arc,v $
//
// Description:
// System level coloring functions are found here.
// Notice that the colors that would normally update TE_SYS are active.
//
// Notice:
// (C) Copyright 1998-2013 Mentor Graphics Corporation
//     All rights reserved.
// Enhancements provided by TOYO Corporation.
//
// This document contains confidential and proprietary information and
// property of Mentor Graphics Corp.  No part of this document may be
// reproduced without the express written permission of Mentor Graphics Corp.
//============================================================================
//
//
//============================================================================
// Enable tasking/threading.
//============================================================================
flavor = param.flavor;
serialize = param.serialize;
number_of_threads = param.number_of_threads;
//
T::print(s:"EnableTasking( T::s(i:flavor), T::s(i:serialize), T::s(i:number_of_threads) )");
select any tm_thread from instances of TM_THREAD;
if ( empty tm_thread )
  create object instance tm_thread of TM_THREAD;
  tm_thread.extra_initialization = "";
end if;
tm_thread.number_of_threads = number_of_threads;
if ( T::l(s:serialize) == "serialize" )
  tm_thread.serialize = true;
else
  tm_thread.serialize = false;
end if;
if ( ( ( ( "Nucleus" == flavor ) or ( "POSIX" == flavor ) ) or ( ( "OSX" == flavor ) or ( "Windows" == flavor ) ) ) or ( ( "AUTOSAR" == flavor ) or ( "SystemC" == flavor ) ) )
  tm_thread.flavor = flavor;
  if ( "SystemC" == flavor )
    // SystemC uses a single thread inside each component.
    // So, no need for an array of threads.
    tm_thread.number_of_threads = 1;
    tm_thread.enabled = false;
  else
    tm_thread.enabled = true;
  end if;
else
  T::print(s:"ERROR:  system.mark:EnableTasking has incorrect tasking/threading type:T::s(i:flavor).\n");
  T::exit(i:100);
end if;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("4941b618-f275-4ae7-a864-93a86919ca2d",
	"8bd9876a-a195-4cf1-a580-063eb4130d5d",
	'flavor',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("989ccb9e-7d3d-464c-b083-39f27cde4894",
	"8bd9876a-a195-4cf1-a580-063eb4130d5d",
	'serialize',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"4941b618-f275-4ae7-a864-93a86919ca2d",
	'');
INSERT INTO S_SPARM
	VALUES ("0b35233b-7d51-4440-8068-d3d93f4798e3",
	"8bd9876a-a195-4cf1-a580-063eb4130d5d",
	'number_of_threads',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"989ccb9e-7d3d-464c-b083-39f27cde4894",
	'');
INSERT INTO PE_PE
	VALUES ("8bd9876a-a195-4cf1-a580-063eb4130d5d",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("39a5cb73-8e63-4248-8589-2648c1e45d81",
	"00000000-0000-0000-0000-000000000000",
	'SetTaskPriority',
	'',
	'//
//============================================================================
// Establish task priority.
//============================================================================
task_number = param.task_number;
priority = param.priority;
T::print(s:"SetTaskPriority( T::s(i:task_number), T::s(i:priority) )");
select any tm_thread from instances of TM_THREAD;
if ( empty tm_thread )
  create object instance tm_thread of TM_THREAD;
end if;
tm_thread.extra_initialization = tm_thread.extra_initialization + "  xtUML_task_priorities[ T::s(i:task_number) ] = T::s(i:priority);\n";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("089fa280-0290-4075-b67b-4c48d8f6d9c2",
	"39a5cb73-8e63-4248-8589-2648c1e45d81",
	'task_number',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("d85ab967-3b61-4dbf-8acd-22abd8cdefb3",
	"39a5cb73-8e63-4248-8589-2648c1e45d81",
	'priority',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"089fa280-0290-4075-b67b-4c48d8f6d9c2",
	'');
INSERT INTO PE_PE
	VALUES ("39a5cb73-8e63-4248-8589-2648c1e45d81",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("2bf9e321-eb7e-4a74-b8e9-05dcaf779959",
	"00000000-0000-0000-0000-000000000000",
	'TagMaximumStringLength',
	'',
	'//
//============================================================================
max_len = param.max_len;
r = ::TM_SYSTAG_select();
tm_systag = r;
tm_systag.MaxStringLen = max_len;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("f9eb1f0f-50c2-494c-9d2d-1a1f5606a934",
	"2bf9e321-eb7e-4a74-b8e9-05dcaf779959",
	'max_len',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("2bf9e321-eb7e-4a74-b8e9-05dcaf779959",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("8843b20c-3e98-4650-982d-047448a3ff75",
	"00000000-0000-0000-0000-000000000000",
	'TagMaximumRelationshipExtentSize',
	'',
	'//
//============================================================================
user_specified_size = param.user_specified_size;
r = ::TM_SYSTAG_select();
tm_systag = r;
tm_systag.MaxRelExtent = user_specified_size;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("2e25d78a-36de-4338-88ce-ab0e1194e76e",
	"8843b20c-3e98-4650-982d-047448a3ff75",
	'user_specified_size',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("8843b20c-3e98-4650-982d-047448a3ff75",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("d51ea437-c3a7-4ba6-be33-7edd02915181",
	"00000000-0000-0000-0000-000000000000",
	'TagMaximumSelectionExtentSize',
	'',
	'//
//============================================================================
user_specified_size = param.user_specified_size;
r = ::TM_SYSTAG_select();
tm_systag = r;
tm_systag.MaxSelectExtent = user_specified_size;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("c28b762f-c96e-4d4b-a51a-ba33ae5b1cd7",
	"d51ea437-c3a7-4ba6-be33-7edd02915181",
	'user_specified_size',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("d51ea437-c3a7-4ba6-be33-7edd02915181",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("14ec098f-ab6f-4ba2-85ff-1b3af336bd48",
	"00000000-0000-0000-0000-000000000000",
	'TagMaximumSelfDirectedEvents',
	'',
	'//
//============================================================================
user_specified_size = param.user_specified_size;
r = ::TM_SYSTAG_select();
tm_systag = r;
tm_systag.MaxSelfEvents = user_specified_size;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("6fb56184-68ce-4dea-8b52-0728bf9e8d6c",
	"14ec098f-ab6f-4ba2-85ff-1b3af336bd48",
	'user_specified_size',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("14ec098f-ab6f-4ba2-85ff-1b3af336bd48",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("aa8854ff-3408-4f7c-96cb-54a667557a74",
	"00000000-0000-0000-0000-000000000000",
	'TagMaximumNonSelfDirectedEvents',
	'',
	'//
//============================================================================
user_specified_size = param.user_specified_size;
r = ::TM_SYSTAG_select();
tm_systag = r;
tm_systag.MaxNonSelfEvents = user_specified_size;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("07165f7f-6e19-496c-8fbb-91987a10adb8",
	"aa8854ff-3408-4f7c-96cb-54a667557a74",
	'user_specified_size',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("aa8854ff-3408-4f7c-96cb-54a667557a74",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("ea21f809-e61b-4a54-89e2-059160f6e9d5",
	"00000000-0000-0000-0000-000000000000",
	'TagMaximumPendingOoaTimers',
	'',
	'//
//============================================================================
user_specified_size = param.user_specified_size;
r = ::TM_SYSTAG_select();
tm_systag = r;
tm_systag.MaxTimers = user_specified_size;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("cf9798f8-ae7f-419f-a5af-28f6446195d0",
	"ea21f809-e61b-4a54-89e2-059160f6e9d5",
	'user_specified_size',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("ea21f809-e61b-4a54-89e2-059160f6e9d5",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("9fbac3fa-5fb1-4034-b3a3-03895e064315",
	"00000000-0000-0000-0000-000000000000",
	'TagMaximumInterleavedBridges',
	'',
	'//
//============================================================================
user_specified_size = param.user_specified_size;
r = ::TM_SYSTAG_select();
tm_systag = r;
tm_systag.MaxInterleavedBridges = user_specified_size;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("1074954c-95e3-4e6c-a07e-6ca6ae05a662",
	"9fbac3fa-5fb1-4034-b3a3-03895e064315",
	'user_specified_size',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("9fbac3fa-5fb1-4034-b3a3-03895e064315",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("fb7a1e37-97f9-4076-afee-cecf629a78db",
	"00000000-0000-0000-0000-000000000000",
	'TagInterleavedBridgeDataSize',
	'',
	'//
//============================================================================
user_specified_size = param.user_specified_size;
r = ::TM_SYSTAG_select();
tm_systag = r;
tm_systag.MaxInterleavedBridgeDataSize = user_specified_size;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("aa653e4f-463f-4dfe-9319-81077123d135",
	"fb7a1e37-97f9-4076-afee-cecf629a78db",
	'user_specified_size',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("fb7a1e37-97f9-4076-afee-cecf629a78db",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("1fd34275-50c7-45e7-832c-13db163b3784",
	"00000000-0000-0000-0000-000000000000",
	'TagCollectionsFlavor',
	'',
	'//
//============================================================================
// Use doubly linked lists for collections.  This speeds up deletes.
//============================================================================
collections_flavor = param.collections_flavor;
r = ::TM_SYSTAG_select();
tm_systag = r;
tm_systag.CollectionsFlavor = collections_flavor;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("8da07d76-3c63-4512-b39d-100a34c5e56b",
	"1fd34275-50c7-45e7-832c-13db163b3784",
	'collections_flavor',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("1fd34275-50c7-45e7-832c-13db163b3784",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("e1078dbf-3f8a-4615-a7a1-4109955e770b",
	"00000000-0000-0000-0000-000000000000",
	'MarkPersistenceCacheDepth',
	'',
	'//
//============================================================================
// Mark Depth of Persistence Cache Queue
//
// This color is used to specify the maximum number of instances and
// links that can be queued waiting to be flushed to non-volatile
// storage (NVS).  As instances and links become "dirty" they get
// queued to NVS.  When Persist::Commit is called this queue is flushed.
//
// MarkPersistenceCacheDepth( instance_depth, link_depth )
//
// Where the input parameter(s) are:
//   instance_depth = the integer depth of the linked list of instances
//   link_depth = the integer depth of the linked list of persistent links
//============================================================================
instance_depth = param.instance_depth;
link_depth = param.link_depth;
r = ::TM_SYSTAG_select();
tm_systag = r;
tm_systag.PersistInstanceCacheDepth = instance_depth;
tm_systag.PersistLinkCacheDepth = link_depth;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("c012eb1c-af30-46ce-8c6c-55f14802452f",
	"e1078dbf-3f8a-4615-a7a1-4109955e770b",
	'instance_depth',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("b47924d6-26dd-4545-a7c5-d10c670bebe2",
	"e1078dbf-3f8a-4615-a7a1-4109955e770b",
	'link_depth',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"c012eb1c-af30-46ce-8c6c-55f14802452f",
	'');
INSERT INTO PE_PE
	VALUES ("e1078dbf-3f8a-4615-a7a1-4109955e770b",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("9df79132-1330-43dc-80c2-7717444153a2",
	"00000000-0000-0000-0000-000000000000",
	'TagDynamicMemoryAllocationOn',
	'',
	'//
//============================================================================
units_to_allocate = param.units_to_allocate;
r = ::TM_SYSTAG_select();
tm_systag = r;
tm_systag.UnitsToDynamicallyAllocate = units_to_allocate;
if ( tm_systag.UnitsToDynamicallyAllocate < 1 )
  tm_systag.UnitsToDynamicallyAllocate = 1;
end if;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("89694476-6884-4ce6-9905-10129e9e59d4",
	"9df79132-1330-43dc-80c2-7717444153a2",
	'units_to_allocate',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("9df79132-1330-43dc-80c2-7717444153a2",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("08671037-0102-4521-acd0-f5f89f12308b",
	"00000000-0000-0000-0000-000000000000",
	'TagInstanceLoading',
	'',
	'//
//============================================================================
r = ::TM_SYSTAG_select();
tm_systag = r;
tm_systag.InstanceLoading = true;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("08671037-0102-4521-acd0-f5f89f12308b",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b8551d0d-5d43-4ffb-af64-067a5e8ba45b",
	"00000000-0000-0000-0000-000000000000",
	'VFBEnable',
	'',
	'//
//============================================================================
// Enable Virtual Function Bus (VFB) for AUTOSAR.
//============================================================================
r = ::TM_SYSTAG_select();
tm_systag = r;
tm_systag.VFB = true;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("b8551d0d-5d43-4ffb-af64-067a5e8ba45b",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("377ab304-d8fa-442f-b9c5-a706759d330d",
	"00000000-0000-0000-0000-000000000000",
	'TM_SYSTAG_select',
	'',
	'//
select any tm_systag from instances of TM_SYSTAG;
if ( empty tm_systag )
  create object instance tm_systag of TM_SYSTAG;
  tm_systag.MaxStringLen = 32;
  tm_systag.PersistInstanceCacheDepth = 128;
  tm_systag.PersistLinkCacheDepth = 128;
  tm_systag.SystemCPortsType = "sc_interface";
end if;
return tm_systag;
',
	"67a6ef0a-7a73-4370-9d87-d743c0801099",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("377ab304-d8fa-442f-b9c5-a706759d330d",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_DT_PROXY
	VALUES ("67a6ef0a-7a73-4370-9d87-d743c0801099",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<System Tags>',
	'',
	'',
	'../Translation Marking/Translation Marking.xtuml');
INSERT INTO S_SYNC
	VALUES ("c82b4a07-ec11-423b-8791-3129f3dc9a0c",
	"00000000-0000-0000-0000-000000000000",
	'MarkSystemConfigurationPackage',
	'',
	'//
//============================================================================
// Mark a package as containing the system configuration.  Code will be
// generated for components contained in this package (and referred to
// from this package).
//============================================================================
package_name = param.package_name;
select any tm_build from instances of TM_BUILD;
if ( empty tm_build )
  create object instance tm_build of TM_BUILD;
else
  T::print(s:"Warning:  Re-marking system configuration.  Last configuration marked will be built.");
end if;
tm_build.package_to_build = package_name;
tm_build.package_obj_name = package_name + "_sys";
tm_build.package_inst_name = package_name + "_top";
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("07d7436a-a8e1-4756-8089-048af9892f60",
	"c82b4a07-ec11-423b-8791-3129f3dc9a0c",
	'package_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("c82b4a07-ec11-423b-8791-3129f3dc9a0c",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("012e62f4-0faa-4dde-b1a2-1d8534916a8c",
	"00000000-0000-0000-0000-000000000000",
	'MarkSystemCPortType',
	'',
	'//
//============================================================================
// Enable Channel binding instead of Signal Binding.
//============================================================================
port_type = param.port_type;
r = ::TM_SYSTAG_select();
tm_systag = r;
if ( ( ( port_type == "TLM" ) or ( port_type == "BitLevelSignals" ) ) or ( port_type == "sc_interface" ) )
  tm_systag.SystemCPortsType = port_type;
else
  T::print(s:"Warning:  Unrecognized SystemC Port Type(T::s(i:port_type)). Please choose either TLM, BitLevelSignals or sc_interface. Default configuration will be used.");
  tm_systag.SystemCPortsType = "sc_interface";
end if;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("b3ef82fe-beef-4b02-b17c-d6706589140d",
	"012e62f4-0faa-4dde-b1a2-1d8534916a8c",
	'port_type',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("012e62f4-0faa-4dde-b1a2-1d8534916a8c",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("2136a5cf-8f54-4a07-b535-81690074c0dd",
	"00000000-0000-0000-0000-000000000000",
	'MarkAllPortsPolymorphic',
	'',
	'//
//============================================================================
// Force all ports to be polymorphic (where a component implements the same 
// interface going in the same direction more than once). 
//============================================================================
r = ::TM_SYSTAG_select();
tm_systag = r;
tm_systag.AllPortsPoly = true;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("2136a5cf-8f54-4a07-b535-81690074c0dd",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b4c6c65e-9c08-44a1-ae73-2d3c391ba876",
	"00000000-0000-0000-0000-000000000000",
	'sys_analyze',
	'',
	'//============================================================================
// File:  $RCSfile: q.domain.analyze.arc,v $
//
// Description:
// This query file provides the "first pass" of a multi-pass translation
// model compiler.  The first pass analyzes the action semantics embodied
// in the analysis domain, and applies optimization algorithms to the
// action language statements encountered.  The results of these algorithmic
// operations are then leveraged by subsequent passes of the structural
// queries and templates to realize time/space/performance trade offs in
// the generated application code.
//
// Notice:
// (C) Copyright 1998-2013 Mentor Graphics Corporation
//     All rights reserved.
//
// This document contains confidential and proprietary information and
// property of Mentor Graphics Corp.  No part of this document may be
// reproduced without the express written permission of Mentor Graphics Corp.
//============================================================================
//
//
te_sys = param.te_sys;
T::print(s:"Analyzing model and making optimizations....");
// Identify state models having at least one state, event and transition.
::SM_SM_mark_valid();
// Count up how many times each event is created/generated.
::event_smt_used();
// Find classes that are created in some way and identify invalid creates.
::class_smt_created();
// Detect invalid deletions.
::class_smt_deleted();
// Track down optimizable where clauses.
::selection_whereclause_identify_special();
// Identify the associations that need link and/or unlink methods.
::association_mark_link_unlink_needed();
// Identify associations that are navigated (in either or both directions).
::association_R_OIR_mark_navigated();
// Find which event queues are necessary.
::event_queue_analyze_needed();
::attr_analyze_accesses();
//.invoke attr_analyze_codegen( te_sys )
::TE_TXN_used();
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("4382aa0c-c573-45cb-a601-dca294dc2875",
	"b4c6c65e-9c08-44a1-ae73-2d3c391ba876",
	'te_sys',
	"195cd118-2bf6-483c-9efd-4ec7a5cd069a",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("195cd118-2bf6-483c-9efd-4ec7a5cd069a",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Extended System>',
	'',
	'',
	'../Translation Extensions/Translation Extensions.xtuml');
INSERT INTO PE_PE
	VALUES ("b4c6c65e-9c08-44a1-ae73-2d3c391ba876",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("4d902897-a76e-4015-a41f-b860882f225e",
	"00000000-0000-0000-0000-000000000000",
	'selection_whereclause_identify_special',
	'',
	'//============================================================================
// $RCSfile: q.oal.analyze.arc,v $
//
// Description:
// The query/transformations in this file analyze the action language
// of the customer model and gather statistics for use in optimized
// code generation.
//
// Notice:
// (C) Copyright 1998-2013 Mentor Graphics Corporation
//     All rights reserved.
//
// This document contains confidential and proprietary information and
// property of Mentor Graphics Corp.  No part of this document may be
// reproduced without the express written permission of Mentor Graphics Corp.
//============================================================================
//
//
//
// Identify (special) where clauses that can be optimized.
//
// Select the class from which extent we are selecting.
//  Mark its identifying attributes.
// Select the blind select statements having where clauses.
// Select the values that represent the where clauses that
// are binary expressions where the operator is == or AND.
// BUG:  R676 and R677 should be unconditional on the O_OBJ side.
// Select the V_SLRs and their attributes.
// Compare the two sets.
//
select many act_fiws from instances of ACT_FIW;
for each act_fiw in act_fiws
  select one v_bin related by act_fiw->V_VAL[R610]->V_BIN[R801] where ( ( selected.Operator == "and" ) or ( selected.Operator == "==" ) );
  if ( not_empty v_bin )
    select one o_obj related by act_fiw->O_OBJ[R676];
    // Select the TE_WHEREs, because we can check to see if we have
    // already marked a special where.
    select many te_wheres related by o_obj->O_ID[R104]->TE_WHERE[R2032] where ( not selected.WhereKey );
    if ( not_empty te_wheres )
      // Clear out the included flag on all attributes of this class.
      select many te_attrs related by o_obj->O_ATTR[R102]->TE_ATTR[R2033];
      for each te_attr in te_attrs
        te_attr.Included = false;
      end for;
      // Call a routine that will recursively drill down and mark any
      // attributes compared in the where clause.
      ::where_clause_mark_selected_attributes( v_bin:v_bin );
      select many te_attrs related by o_obj->O_ATTR[R102]->TE_ATTR[R2033] where ( selected.Included );
      if ( not_empty te_attrs )
        for each te_where in te_wheres
          select many identifying_te_attrs related by te_where->O_ID[R2032]->O_OIDA[R105]->O_ATTR[R105]->TE_ATTR[R2033];
          if ( te_attrs == identifying_te_attrs )
            T::print(s:"marking SPECIAL where on T::s(i:o_obj.Key_Lett):T::s(i:o_obj.Name)");
            te_where.WhereKey = true;
          end if;
        end for;
      end if;
    end if;
  end if;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("4d902897-a76e-4015-a41f-b860882f225e",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("491975fe-65b2-4d48-8060-7761c6a2d7d6",
	"00000000-0000-0000-0000-000000000000",
	'where_clause_mark_selected_attributes',
	'',
	'//
//
// Recursively drill down into the where clause expression marking
// selected attributes along the way.
//
v_bin = param.v_bin;
if ( v_bin.Operator == "and" )
  select one left_v_val related by v_bin->V_VAL[R802];
  select one right_v_val related by v_bin->V_VAL[R803];
  select one v_bin related by left_v_val->V_BIN[R801];
  if ( not_empty v_bin )
    ::where_clause_mark_selected_attributes( v_bin:v_bin );
  end if;
  select one v_bin related by right_v_val->V_BIN[R801];
  if ( not_empty v_bin )
    ::where_clause_mark_selected_attributes( v_bin:v_bin );
  end if;
elif ( v_bin.Operator == "==" )
  select one te_attr related by v_bin->V_VAL[R802]->V_SLR[R801]->O_ATTR[R812]->TE_ATTR[R2033];
  if ( not_empty te_attr )
    te_attr.Included = true;
  end if;
  select one te_attr related by v_bin->V_VAL[R803]->V_SLR[R801]->O_ATTR[R812]->TE_ATTR[R2033];
  if ( not_empty te_attr )
    te_attr.Included = true;
  end if;
else
  // allow return
end if;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("37265d28-eba7-4c7b-9d47-dfa7484805a2",
	"491975fe-65b2-4d48-8060-7761c6a2d7d6",
	'v_bin',
	"a6e95352-7701-470f-a154-2a42ea44c24d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("a6e95352-7701-470f-a154-2a42ea44c24d",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Binary Operation>',
	'',
	'',
	'../Value/Value.xtuml');
INSERT INTO PE_PE
	VALUES ("491975fe-65b2-4d48-8060-7761c6a2d7d6",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("11fcfad2-7021-413f-90f2-430fa514ccfd",
	"00000000-0000-0000-0000-000000000000",
	'SM_SM_mark_valid',
	'',
	'//
//
// Find valid state machines and mark them thusly.
// Such state machines have at least one each of state, event and transition.
//
// Select only the state machines that have been configured for generation.
select many te_sms from instances of TE_SM;
for each te_sm in te_sms
  select one sm_sm related by te_sm->SM_SM[R2043];
  select any sm_state related by sm_sm->SM_STATE[R501];
  if ( not_empty sm_state )
    select any sm_txn related by sm_sm->SM_TXN[R505];
    if ( not_empty sm_txn )
      select any sm_evt related by sm_sm->SM_EVT[R502];
      if ( not_empty sm_evt )
        te_sm.complete = true;
      end if;
    end if;
  end if;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("11fcfad2-7021-413f-90f2-430fa514ccfd",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("d6b624dd-e201-4fb2-a75c-a74fa62b89e0",
	"00000000-0000-0000-0000-000000000000",
	'TE_TXN_used',
	'',
	'//
//
// Update the size of SEM cells when transition actions are present.
//
select any te_sm from instances of TE_SM where ( selected.txn_action_count > 0 );
if ( not_empty te_sm )
  select any te_typemap from instances of TE_TYPEMAP;
  te_typemap.SEM_cell_type = "u2_t";
end if;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("d6b624dd-e201-4fb2-a75c-a74fa62b89e0",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("bc579c03-8122-4dfb-b092-f1aff8d1c064",
	"00000000-0000-0000-0000-000000000000",
	'event_smt_used',
	'',
	'//
//
// Find and mark/count events that are used in action language.
// Even though we store the information in a count, this query
// only counts each event once.
//
select many e_gsmes from instances of E_GSME;
select many te_evts related by e_gsmes->SM_EVT[R707]->TE_EVT[R2036];
for each te_evt in te_evts
  te_evt.UsedCount = te_evt.UsedCount + 1;
  te_evt.Used = true;
end for;
select many e_csmes from instances of E_CSME;
select many te_evts related by e_csmes->SM_EVT[R706]->TE_EVT[R2036];
for each te_evt in te_evts
  te_evt.UsedCount = te_evt.UsedCount + 1;
  te_evt.Used = true;
end for;
// Mark all of the signals (inter-component class-based events) as used.
select many sm_sgevts from instances of SM_SGEVT;
select many te_evts related by sm_sgevts->SM_SEVT[R526]->SM_EVT[R525]->TE_EVT[R2036];
for each te_evt in te_evts
  te_evt.UsedCount = te_evt.UsedCount + 1;
  te_evt.Used = true;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("bc579c03-8122-4dfb-b092-f1aff8d1c064",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("f7646998-b293-478f-b45b-1c0d05d59a1d",
	"00000000-0000-0000-0000-000000000000",
	'class_smt_created',
	'',
	'//
//
// Mark classes that are created synchronously (nonself) or
// asynchronously (self).
//
select many act_crs from instances of ACT_CR;
select many te_classs related by act_crs->O_OBJ[R671]->TE_CLASS[R2019];
::class_smt_crdel_check( te_classs:te_classs );
for each te_class in te_classs
  te_class.NonSelfCreated = true;
end for;
select many act_cnvs from instances of ACT_CNV;
select many te_classs related by act_cnvs->O_OBJ[R672]->TE_CLASS[R2019];
::class_smt_crdel_check( te_classs:te_classs );
for each te_class in te_classs
  te_class.NonSelfCreated = true;
end for;
// Now find any creator events to classes.
select many e_gecs from instances of E_GEC;
select many te_classs related by e_gecs->E_GSME[R705]->SM_EVT[R707]->SM_SM[R502]->SM_ISM[R517]->O_OBJ[R518]->TE_CLASS[R2019];
::class_smt_crdel_check( te_classs:te_classs );
for each te_class in te_classs
  te_class.SelfCreated = true;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("f7646998-b293-478f-b45b-1c0d05d59a1d",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("70b9f269-6ef8-424d-9e94-2e64d1ad474c",
	"00000000-0000-0000-0000-000000000000",
	'class_smt_deleted',
	'',
	'//
//
// Check for classes that are deleted synchronously and should not be.
//
select many act_dels from instances of ACT_DEL;
select many te_classs related by act_dels->V_VAR[R634]->V_INT[R814]->O_OBJ[R818]->TE_CLASS[R2019];
::class_smt_crdel_check( te_classs:te_classs );
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("70b9f269-6ef8-424d-9e94-2e64d1ad474c",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("d5e7fa07-91c4-48e6-8884-a8cfa3b80345",
	"00000000-0000-0000-0000-000000000000",
	'class_smt_crdel_check',
	'',
	'//
te_classs = param.te_classs;
for each te_class in te_classs
  if ( te_class.IsReadOnly )
    select one o_obj related by te_class->O_OBJ[R2019];
    T::print(s:"ERROR:  Attempt to create/delete read-only object T::s(i:o_obj.Name) (T::s(i:o_obj.Key_Lett))");
  end if;
  if ( te_class.IsFixedPopulation )
    select one o_obj related by te_class->O_OBJ[R2019];
    T::print(s:"ERROR:  Attempt to create/delete object T::s(i:o_obj.Name) (T::s(i:o_obj.Key_Lett)) within static instance population.");
  end if;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("cfdd1983-5818-40f7-9029-8a7c6f341c39",
	"d5e7fa07-91c4-48e6-8884-a8cfa3b80345",
	'te_classs',
	"54de650e-cdb2-4d65-ad98-5eb87386d7e7",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("d5e7fa07-91c4-48e6-8884-a8cfa3b80345",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b5713c04-f462-4000-be19-df1e57503777",
	"00000000-0000-0000-0000-000000000000",
	'event_queue_analyze_needed',
	'',
	'//
// Count up all the places that events are either generated directly (E_GEN)
// or where they are created for deferred generation (E_CEI).
// Also count up the self versus nonself events.
//
self_queue_needed = false;
nonself_queue_needed = false;
select many e_gens from instances of E_GEN;
select any v_var related by e_gens->V_VAR[R712] where ( selected.Name == "self" );
if ( not_empty v_var )
  self_queue_needed = true;
end if;
select any v_var related by e_gens->V_VAR[R712] where ( selected.Name != "self" );
if ( not_empty v_var )
  nonself_queue_needed = true;
end if;
if ( not ( self_queue_needed and nonself_queue_needed ) )
  select many e_ceis from instances of E_CEI;
  select any v_var related by e_ceis->V_VAR[R711] where ( selected.Name == "self" );
  if ( not_empty v_var )
    self_queue_needed = true;
  end if;
  select any v_var related by e_ceis->V_VAR[R711] where ( selected.Name != "self" );
  if ( not_empty v_var )
    nonself_queue_needed = true;
  end if;
end if;
if ( self_queue_needed )
  T::print(s:"Self event queue needed.");
end if;
if ( nonself_queue_needed )
  T::print(s:"Instance event queue needed.");
end if;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("b5713c04-f462-4000-be19-df1e57503777",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("c1989074-4b55-4f5b-8d1f-7b55fe25224d",
	"00000000-0000-0000-0000-000000000000",
	'attr_analyze_accesses',
	'',
	'//
//
// Analyze and mark the attributes of the customer model to flag which
// attributes are read and/or written.  We will use this information
// later to optimize out member data access code that is not needed.
// Also, mark attributes participating as identifiers as used.
// Mark written, read and Used attributes to TE_ATTR.
//
attributes_read_count = 0;
attributes_written_count = 0;
//
// Select all the attribute values references.
// Cycle through them marking their associated attributes as being read.
// Then, see if they are written by determining whether they participate
// as an lval in an assignment.
// Note, there can be several V_AVLs for each O_ATTR.
//
select many te_attrs from instances of TE_ATTR;
for each te_attr in te_attrs
  select many v_avls related by te_attr->O_ATTR[R2033]->V_AVL[R806];
  if ( not_empty v_avls )
    if ( not te_attr.read )
      attributes_read_count = attributes_read_count + 1;
    end if;
    te_attr.read = true;
    te_attr.Used = true;
  end if;
  // attributes written
  select any act_ai related by v_avls->V_VAL[R801]->ACT_AI[R689];
  if ( not_empty act_ai )
    if ( not te_attr.written )
      attributes_written_count = attributes_written_count + 1;
      select one te_class related by te_attr->TE_CLASS[R2061];
      if ( te_class.IsReadOnly )
        T::print(s:"ERROR:  Attempt to write to read-only object T::s(i:te_class.Name) (T::s(i:te_class.Key_Lett)).");
      end if;
    end if;
    te_attr.written = true;
  end if;
end for;
// Identifying attributes are copied across in RELATE statements
// even if they are never read or written.
select many o_oidas from instances of O_OIDA;
select many te_attrs related by o_oidas->O_ATTR[R105]->TE_ATTR[R2033];
for each te_attr in te_attrs
  te_attr.Used = true;
end for;
msg = T::s(i:attributes_read_count) + " attributes read";
T::print(s:msg);
msg = T::s(i:attributes_written_count) + " attributes written";
T::print(s:msg);
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("c1989074-4b55-4f5b-8d1f-7b55fe25224d",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("375b0b4e-9b4d-4630-8e59-3ec7d8451ebc",
	"00000000-0000-0000-0000-000000000000",
	'attr_analyze_codegen',
	'',
	'//
//
// Mark attributes that are not used, needed and should be optimized out.
//
te_sys = param.te_sys;
optimized_out_count = 0;
select many te_cs from instances of TE_C where ( not selected.OptDisabled );
select many te_attrs related by te_cs->TE_CLASS[R2064]->TE_ATTR[R2061];
for each te_attr in te_attrs
  select one o_attr related by te_attr->O_ATTR[R2033];
  // Do not translate current_state attributes.
  select one s_cdt related by o_attr->S_DT[R114]->S_CDT[R17] where ( selected.Core_Typ == 6 );
  if ( not_empty s_cdt )
    te_attr.translate = false;
    optimized_out_count = optimized_out_count + 1;
  end if;
  if ( not te_attr.Used )
    // not accessed?
    te_attr.translate = false;
    optimized_out_count = optimized_out_count + 1;
  else
    // referential attribute?
    select one o_rattr related by o_attr->O_RATTR[R106];
    if ( not_empty o_rattr )
      // Is referential not also an identifying attribute?
      select any o_oida related by o_attr->O_OIDA[R105] where ( selected.Attr_ID == o_rattr.Attr_ID );
      if ( ( empty o_oida ) and ( not te_attr.Used ) )
        if ( not te_sys.InstanceLoading )
          te_attr.translate = false;
          optimized_out_count = optimized_out_count + 1;
        end if;
      end if;
    end if;
  end if;
end for;
msg = T::s(i:optimized_out_count) + " attributes optimized out";
T::print(s:msg);
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("0555a460-abeb-44f2-a965-029622e121f0",
	"375b0b4e-9b4d-4630-8e59-3ec7d8451ebc",
	'te_sys',
	"195cd118-2bf6-483c-9efd-4ec7a5cd069a",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("375b0b4e-9b4d-4630-8e59-3ec7d8451ebc",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("881ec01d-87e6-49c4-bfbb-d5eee6a99c0f",
	"00000000-0000-0000-0000-000000000000",
	'association_R_OIR_mark_navigated',
	'',
	'//
//
// Here we mark which classes are navigated across associations in each
// direction, from the formalizer or from the participant.  The results
// are stored in instances linked to instances of R_OIR (TE_OIR).
//
select many act_lnks from instances of ACT_LNK;
for each act_lnk in act_lnks
  select any r_oir related by act_lnk->R_REL[R681]->R_OIR[R201] where ( selected.Obj_ID == act_lnk.Obj_ID );
  select one te_oir related by r_oir->TE_OIR[R2035];
  if ( not_empty te_oir )
    te_oir.NavigatedTo = true;
  end if;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("881ec01d-87e6-49c4-bfbb-d5eee6a99c0f",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b41310ca-f06c-4f71-b3d9-753109107647",
	"00000000-0000-0000-0000-000000000000",
	'association_mark_link_unlink_needed',
	'',
	'//
//
// Select all of the association instances and mark the ones that
// actually get linked with the relate/unrelate OAL statements.
//
// Mark all navigation (across a particular association).
// Mark all assocations that get navigated.
//
select many te_rels from instances of TE_REL;
select many r_rels related by te_rels->R_REL[R2034];
for each r_rel in r_rels
  link_needed = false;
  unlink_needed = false;
  navigated = false;
  // Check if navigated.
  select any act_lnk related by r_rel->ACT_LNK[R681];
  if ( not_empty act_lnk )
    navigated = true;
  end if;
  // Check if related.
  select any act_rel related by r_rel->ACT_REL[R653];
  if ( not_empty act_rel )
    link_needed = true;
  else
    select any act_ru related by r_rel->ACT_RU[R654];
    if ( not_empty act_ru )
      link_needed = true;
    end if;
  end if;
  // Check if unrelated.
  select any act_unr related by r_rel->ACT_UNR[R655];
  if ( not_empty act_unr )
    unlink_needed = true;
  else
    select any act_uru related by r_rel->ACT_URU[R656];
    if ( not_empty act_uru )
      unlink_needed = true;
    end if;
  end if;
  // Apply results to TE_REL.
  if ( ( link_needed or unlink_needed ) or navigated )
    select one te_rel related by r_rel->TE_REL[R2034];
    if ( navigated )
      te_rel.Navigated = true;
    end if;
    if ( link_needed )
      te_rel.LinkNeeded = true;
    end if;
    if ( unlink_needed )
      te_rel.UnlinkNeeded = true;
    end if;
  end if;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("b41310ca-f06c-4f71-b3d9-753109107647",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("640a6ae3-0148-4ce1-a8d0-316901df3055",
	"00000000-0000-0000-0000-000000000000",
	'containoid_select_many_count',
	'',
	'//============================================================================
// $RCSfile: q.oal.utils.arc,v $
//
// Description:
// Utility functions specifically for OAL analysis.
//
// Notice:
// (C) Copyright 1998-2013 Mentor Graphics Corporation
//     All rights reserved.
//
// This document contains confidential and proprietary information and
// property of Mentor Graphics Corp.  No part of this document may be
// reproduced without the express written permission of Mentor Graphics Corp.
//============================================================================
//
//
//
// Find the maximum number of "select many" statements expressed in
// one action body.  We will use this number to estimate the container
// pool.
// CDS - This gets called for each component but uses all actions in 
// the system.  And it gets called too many times.
//
result = 0;
select many act_acts from instances of ACT_ACT;
for each act_act in act_acts
  select many act_smts related by act_act->ACT_BLK[R601]->ACT_SMT[R602];
  select many act_sels related by act_smts->ACT_SEL[R603] where ( ( selected.cardinality == "many" ) and ( selected.is_implicit ) );
  select many act_fios related by act_smts->ACT_FIO[R603] where ( ( selected.cardinality == "many" ) and ( selected.is_implicit ) );
  select many act_fiws related by act_smts->ACT_FIW[R603] where ( ( selected.cardinality == "many" ) and ( selected.is_implicit ) );
  count = cardinality act_sels;
  c1 = cardinality act_fios;
  count = count + c1;
  c1 = cardinality act_fiws;
  count = count + c1;
  if ( count > result )
    result = count;
  end if;
end for;
return result;
',
	"ba5eda7a-def5-0000-0000-000000000002",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("640a6ae3-0148-4ce1-a8d0-316901df3055",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("8c3ea287-5fad-4fc7-8fc7-346eb8de14ee",
	"00000000-0000-0000-0000-000000000000",
	'timer_analyze_starts',
	'',
	'//
//
// Count up the number of places where a timer is started (or started
// in recurring mode).
//
result = 0;
select many s_ees from instances of S_EE where ( selected.Key_Lett == "TIM" );
for each s_ee in s_ees
  select any s_brg related by s_ee->S_BRG[R19] where ( selected.Name == "timer_start" );
  if ( not_empty s_brg )
    select many timer_invocations related by s_brg->V_BRV[R828];
    c = cardinality timer_invocations;
    result = result + c;
  end if;
  select any s_brg related by s_ee->S_BRG[R19] where ( selected.Name == "timer_start_recurring" );
  if ( not_empty s_brg )
    select many timer_invocations related by s_brg->V_BRV[R828];
    c = cardinality timer_invocations;
    result = result + c;
  end if;
end for;
return result;
',
	"ba5eda7a-def5-0000-0000-000000000002",
	1,
	'');
INSERT INTO PE_PE
	VALUES ("8c3ea287-5fad-4fc7-8fc7-346eb8de14ee",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("4c55eb32-5e05-4b89-9770-d0a865eec3d4",
	"00000000-0000-0000-0000-000000000000",
	'CreateSpecialWhereClauseInstances',
	'',
	'//
//============================================================================
// Class: 2000.  Special Where Clause
// CREATE TABLE TE_SWC (
// 	Obj_Kl		STRING,
// 	Where_Spec	STRING,
// 	Key	        STRING,
// 	Ret_Val	        BOOLEAN,
//	Built_In	BOOLEAN,
//	Oid_ID	        INTEGER );
//
// Notes:
// (1) The selected attributes of the where clause _Key_ are specified in the
//     same order as they appear on the OIM. This convention allows other
//     archetypes a _rule_ for dealing with the positional parameter
//     information provided during fragment parsing of a special where clause.
//============================================================================
te_sys = param.te_sys;
//
// Special Where Clause patterns that may be optimized by the model compiler.
//
unique_num = 0;
select many te_classes from instances of TE_CLASS where ( not selected.ExcludeFromGen );
for each te_class in te_classes
  select many o_ids related by te_class->O_OBJ[R2019]->O_ID[R104];
  for each o_id in o_ids
    select one te_where related by o_id->TE_WHERE[R2032];
    // Get all special wheres when loading instances even if they are
    // not seen in the OAL.  We need them for batch_relate.
    if ( te_sys.InstanceLoading )
      select any r_rto related by o_id->R_RTO[R109];
      if ( not_empty r_rto )
        te_where.WhereKey = true;
      end if;
    end if;
    if ( te_where.WhereKey )
      key_number = o_id.Oid_ID + 1;
      where_spec = "";
      unique_num = unique_num + 1;
      where_key = ( ( te_class.Key_Lett + T::s(i:key_number) ) + ( "_mcw" + T::s(i:unique_num) ) );
      //
      select many te_attrs related by te_class->TE_ATTR[R2061];
      for each te_attr in te_attrs
        te_attr.Included = false;
      end for;
      //
      select many te_attrs related by o_id->O_OIDA[R105]->O_ATTR[R105]->TE_ATTR[R2033];
      num_ident_attr = cardinality te_attrs;
      for each te_attr in te_attrs
        te_attr.Included = true;
      end for;
      //
      // *** Provide a key without parenthesis.
      // Be sure we have the first attribute in the class.
      select any first_te_attr related by te_class->TE_ATTR[R2061];
      while ( not_empty first_te_attr )
        select one prev_te_attr related by first_te_attr->TE_ATTR[R2087.''precedes''];
        if ( empty prev_te_attr )
          break;
        end if;
        first_te_attr = prev_te_attr;
      end while;
      te_attr = first_te_attr;
      oida_count = 0;
      while ( not_empty te_attr )
        select one o_attr related by te_attr->O_ATTR[R2033];
        if ( te_attr.Included )
          oida_count = oida_count + 1;
          where_spec = where_spec + "selected.T::s(i:o_attr.Name) == ?";
          if ( oida_count < num_ident_attr )
            where_spec = where_spec + " AND ";
          end if;
        end if;
        //
        select one te_attr related by te_attr->TE_ATTR[R2087.''succeeds''];
      end while;
      //
      // Object ${te_class.Name} (${te_class.Key_Lett}) Identifier *${key_number}
      create object instance te_swc of TE_SWC;
      relate te_swc to te_class across R2001;
      te_swc.Obj_Kl = te_class.Key_Lett;
      te_swc.Where_Spec = where_spec;
      te_swc.Key = where_key;
      te_swc.Ret_Val = false;
      te_swc.Built_In = true;
      te_swc.Oid_ID = o_id.Oid_ID;
      //
      // *** Provide a key parenthesized at the outer construct.
      where_spec = "(";
      unique_num = unique_num + 1;
      where_key = ( ( te_class.Key_Lett + T::s(i:key_number) ) + ( "_mcw" + T::s(i:unique_num) ) );
      te_attr = first_te_attr;
      oida_count = 0;
      while ( not_empty te_attr )
        select one o_attr related by te_attr->O_ATTR[R2033];
        if ( te_attr.Included )
          oida_count = oida_count + 1;
          where_spec = where_spec + "selected.T::s(i:o_attr.Name) == ?";
          if ( oida_count < num_ident_attr )
            where_spec = where_spec + " AND ";
          else
            where_spec = where_spec + ")";
          end if;
        end if;
        //
        select one te_attr related by te_attr->TE_ATTR[R2087.''succeeds''];
      end while;
      //
      // Object ${te_class.Name} (${te_class.Key_Lett}) Identifier *${key_number}
      create object instance te_swc of TE_SWC;
      relate te_swc to te_class across R2001;
      te_swc.Obj_Kl = te_class.Key_Lett;
      te_swc.Where_Spec = where_spec;
      te_swc.Key = where_key;
      te_swc.Ret_Val = false;
      te_swc.Built_In = true;
      te_swc.Oid_ID = o_id.Oid_ID;
      //
      if ( num_ident_attr > 1 )
        // *** Provide a key parenthesized at outer and inner constructs.
        where_spec = "(";
        unique_num = unique_num + 1;
        where_key = ( ( te_class.Key_Lett + T::s(i:key_number) ) + ( "_mcw" + T::s(i:unique_num) ) );
        te_attr = first_te_attr;
        oida_count = 0;
        while ( not_empty te_attr )
          select one o_attr related by te_attr->O_ATTR[R2033];
          if ( te_attr.Included )
            oida_count = oida_count + 1;
            where_spec = where_spec + "(selected.T::s(i:o_attr.Name) == ?)";
            if ( oida_count < num_ident_attr )
              where_spec = where_spec + " AND ";
            else
              where_spec = where_spec + ")";
            end if;
          end if;
          //
          select one te_attr related by te_attr->TE_ATTR[R2087.''succeeds''];
        end while;
        //
        // Object ${te_class.Name} (${te_class.Key_Lett}) Identifier *${key_number}
        create object instance te_swc of TE_SWC;
        relate te_swc to te_class across R2001;
        te_swc.Obj_Kl = te_class.Key_Lett;
        te_swc.Where_Spec = where_spec;
        te_swc.Key = where_key;
        te_swc.Ret_Val = false;
        te_swc.Built_In = true;
        te_swc.Oid_ID = o_id.Oid_ID;
        // *** Provide a key parenthesized at just inner constructs.
        where_spec = "";
        unique_num = unique_num + 1;
        where_key = ( ( te_class.Key_Lett + T::s(i:key_number) ) + ( "_mcw" + T::s(i:unique_num) ) );
        te_attr = first_te_attr;
        oida_count = 0;
        while ( not_empty te_attr )
          select one o_attr related by te_attr->O_ATTR[R2033];
          if ( te_attr.Included )
            oida_count = oida_count + 1;
            where_spec = where_spec + "(selected.T::s(i:o_attr.Name) == ?)";
            if ( oida_count < num_ident_attr )
              where_spec = where_spec + " AND ";
            end if;
          end if;
          //
          select one te_attr related by te_attr->TE_ATTR[R2087.''succeeds''];
        end while;
        //
        // Object ${te_class.Name} (${te_class.Key_Lett}) Identifier *${key_number}
        create object instance te_swc of TE_SWC;
        relate te_swc to te_class across R2001;
        te_swc.Obj_Kl = te_class.Key_Lett;
        te_swc.Where_Spec = where_spec;
        te_swc.Key = where_key;
        te_swc.Ret_Val = false;
        te_swc.Built_In = true;
        te_swc.Oid_ID = o_id.Oid_ID;
        //
      end if;
    end if;
  end for;
end for;
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("953821c2-e703-4f18-8aab-ed9c0e6d2c2e",
	"4c55eb32-5e05-4b89-9770-d0a865eec3d4",
	'te_sys',
	"195cd118-2bf6-483c-9efd-4ec7a5cd069a",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("4c55eb32-5e05-4b89-9770-d0a865eec3d4",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("f01989f6-4de0-488f-ae84-204e2d3a54e8",
	"00000000-0000-0000-0000-000000000000",
	'te_c_CollectLimits',
	'',
	'//============================================================================
// $RCSfile: q.domain.limits.arc,v $
//
// Description:
// These queries collect static analysis information and propagate it
// forward to the system build step by outputting a set of INSERT
// statements that will populate the system build gen database.
//
// Notice:
// (C) Copyright 1998-2013 Mentor Graphics Corporation
//     All rights reserved.
//
// This document contains confidential and proprietary information and
// property of Mentor Graphics Corp.  No part of this document may be
// reproduced without the express written permission of Mentor Graphics Corp.
//============================================================================
//
//
//============================================================================
// Store statistics into TE_C.
//============================================================================
te_c = param.te_c;
//
select any te_file from instances of TE_FILE;
//
// Analyze maximums for extents.
// The extents should be analyzed only *after* extent size coloring!
select many te_classs related by te_c->TE_CLASS[R2064] where ( not selected.ExcludeFromGen );
object_class_extents = 0;
relationship_extents = 0;
largest_object_extent = 0;
//
for each te_class in te_classs
  select one o_obj related by te_class->O_OBJ[R2019];
  object_class_extents = object_class_extents + te_class.MaxExtentSize;
  if ( te_class.MaxExtentSize > largest_object_extent )
    largest_object_extent = te_class.MaxExtentSize;
  end if;
  // Calculate maximum extents required for objects on "MANY" side of a relationship.
  select many r_rgos related by o_obj->R_OIR[R201]->R_RGO[R203] where ( selected.Obj_ID == o_obj.Obj_ID );
  for each r_rgo in r_rgos
    select one form related by r_rgo->R_FORM[R205];
    if ( not_empty form )
      if ( form.Mult == 1 )
        relationship_extents = relationship_extents + te_class.MaxExtentSize;
      end if;
    end if;
    select one assr related by r_rgo->R_ASSR[R205];
    if ( not_empty assr )
      if ( assr.Mult == 1 )
        relationship_extents = relationship_extents + te_class.MaxExtentSize;
      end if;
    end if;
  end for;
  select many r_rtos related by o_obj->R_OIR[R201]->R_RTO[R203] where ( selected.Obj_ID == o_obj.Obj_ID );
  for each r_rto in r_rtos
    select one aone related by r_rto->R_AONE[R204];
    if ( not_empty aone )
      if ( aone.Mult == 1 )
        relationship_extents = relationship_extents + te_class.MaxExtentSize;
      end if;
    end if;
    select one aoth related by r_rto->R_AOTH[R204];
    if ( not_empty aoth )
      if ( aoth.Mult == 1 )
        relationship_extents = relationship_extents + te_class.MaxExtentSize;
      end if;
    end if;
  end for;
end for;
//
// analyze timers events selects
r = ::timer_analyze_starts();
total_timer_starts = r;
//
// Count up the event specification statements which is the supertype
// of generated and deferred events.  This will give us a starting point
// on allocating event queue resources.
// CDS - We are (re)counting the events for each component, but this code is not component-specific.
// CDS - The event counts should be "harvested" while processing the action language.
max_events = 0;
max_self_events = 0;
max_nonself_events = 0;
select many act_acts from instances of ACT_ACT;
for each act_act in act_acts
  select many event_specification_statements related by act_act->ACT_BLK[R601]->ACT_SMT[R602]->E_ESS[R603];
  all_events_count = cardinality event_specification_statements;
  select many act_sgns related by act_act->ACT_BLK[R601]->ACT_SMT[R602]->ACT_SGN[R603];
  all_events_count = all_events_count + ( cardinality act_sgns );
  if ( all_events_count > max_events )
    max_events = all_events_count;
  end if;
  // Count up the self events in this body.
  count = 0;
  for each e_ess in event_specification_statements
    select one v_var related by e_ess->E_GES[R701]->E_GSME[R703]->E_GEN[R705]->V_VAR[R712] where ( T::l(s:selected.Name) == "self" );
    if ( not_empty v_var )
      count = count + 1;
    else
      select any v_var related by event_specification_statements->E_CES[R701]->E_CSME[R702]->E_CEI[R704]->V_VAR[R711] where ( T::l(s:selected.Name) == "self" );
      if ( not_empty v_var )
        count = count + 1;
      end if;
    end if;
  end for;
  if ( count > max_self_events )
    max_self_events = count;
  end if;
  count = all_events_count - count;
  if ( count > max_nonself_events )
    max_nonself_events = count;
  end if;
  select one te_aba related by act_act->ACT_FNB[R698]->S_SYNC[R695]->TE_SYNC[R2023]->TE_ABA[R2010];
  if ( not_empty te_aba )
    te_aba.NonSelfEventCount = count;
  end if;
end for;
//
r = ::containoid_select_many_count();
max_select_many = r;
//
// functions
select many te_syncs related by te_c->TE_SYNC[R2084] where ( ( selected.IsSafeForInterrupts ) and ( selected.XlateSemantics ) );
total_interleaved_bridges = cardinality te_syncs;
//
// Count up the priority events.
select many te_evts from instances of TE_EVT where ( selected.Priority != 0 );
total_priority_events = cardinality te_evts;
//
// Count up the classes using preexisting instances defined in data (PEIs).
select many te_classs related by te_c->TE_CLASS[R2064] where ( ( not selected.ExcludeFromGen ) and ( selected.PEIsDefinedInData ) );
pei_class_count = cardinality te_classs;
//
// Count up the persistent classes.
select many te_classs related by te_c->TE_CLASS[R2064] where ( ( not selected.ExcludeFromGen ) and ( selected.Persistent ) );
persist_class_count = cardinality te_classs;
//
te_c.MaxObjExtent = object_class_extents;
te_c.MaxRelExtent = relationship_extents;
te_c.MaxSelectExtent = max_select_many * largest_object_extent;
te_c.MaxSelfEvents = max_self_events;
te_c.MaxNonSelfEvents = max_nonself_events;
te_c.MaxPriorityEvents = total_priority_events;
te_c.MaxTimers = total_timer_starts;
te_c.InterleavedBridges = total_interleaved_bridges;
te_c.PEIClassCount = pei_class_count;
te_c.PersistentClassCount = persist_class_count;
//
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("67282ef9-4e19-42b0-9055-da0d7f5f2401",
	"f01989f6-4de0-488f-ae84-204e2d3a54e8",
	'te_c',
	"af13e9b7-f940-4a62-b6da-d8fb321a8a39",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("f01989f6-4de0-488f-ae84-204e2d3a54e8",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("90b80234-c3ef-45e6-ab22-dcf83bdec09b",
	"00000000-0000-0000-0000-000000000000",
	'AutoInitializeUniqueIDs',
	'',
	'//============================================================================
// $RCSfile: frag_util.arc,v $
//
// Description:
// This archetype file provides general purpose functions used during 
// action language translation. They are not specific to any particular
// fragment generator entry points.
//
// Notice:
// (C) Copyright 1998-2013 Mentor Graphics Corporation
//     All rights reserved.
//
// This document contains confidential and proprietary information and
// property of Mentor Graphics Corp.  No part of this document may be
// reproduced without the express written permission of Mentor Graphics Corp.
//============================================================================
//
//============================================================================
// Initialize the attributes of type unique_id that are identifiers
// and therefore need to be automatically set up at create time.
//============================================================================
te_class = param.te_class;
instance = param.instance;
//
select any te_file from instances of TE_FILE;
select any te_instance from instances of TE_INSTANCE;
select any te_string from instances of TE_STRING;
select any te_sys from instances of TE_SYS;
// Be sure we have the first attribute in the class.
select any first_te_attr related by te_class->TE_ATTR[R2061];
while ( not_empty first_te_attr )
  select one prev_te_attr related by first_te_attr->TE_ATTR[R2087.''precedes''];
  if ( empty prev_te_attr )
    break;
  end if;
  first_te_attr = prev_te_attr;
end while;
te_attr = first_te_attr;
while ( not_empty te_attr )
  select one o_attr related by te_attr->O_ATTR[R2033];
  if ( te_attr.translate )
    r = ::GetAttributeCodeGenType( o_attr:o_attr );
    te_dt = r;
    not_empty_o_oida = false;
    if ( not_empty te_dt )
      if ( 5 == te_dt.Core_Typ )
        select any o_oida related by o_attr->O_OIDA[R105];
        if ( not_empty o_oida )
          not_empty_o_oida = true;
        end if;
      end if;
      T::include(file:"t.class.attribute.init.c");
    end if;
  end if;
  //
  // Advance to the next object attribute, if any.
  select one te_attr related by te_attr->TE_ATTR[R2087.''succeeds''];
end while;
return T::body();
',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("d736cbdc-02d6-48e4-b090-6f988ef6429b",
	"90b80234-c3ef-45e6-ab22-dcf83bdec09b",
	'te_class',
	"f975acb7-4246-4a87-9c5a-75481f096785",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("f7b61832-3e4f-444d-9d61-f7ca6f536f04",
	"90b80234-c3ef-45e6-ab22-dcf83bdec09b",
	'instance',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"d736cbdc-02d6-48e4-b090-6f988ef6429b",
	'');
INSERT INTO PE_PE
	VALUES ("90b80234-c3ef-45e6-ab22-dcf83bdec09b",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("6d504832-7f3b-40f9-b738-617ebbd9ee75",
	"00000000-0000-0000-0000-000000000000",
	'ExpandNonOptimizedSpecialWhereComparison',
	'',
	'//
//============================================================================
o_obj = param.o_obj;
special = param.special;
selected_var_name = param.selected_var_name;
//
if ( special )
  select any te_instance from instances of TE_INSTANCE;
  select any te_string from instances of TE_STRING;
  compare_stmt = "";
  cmp_element = "";
  select many te_attrs related by o_obj->O_ATTR[R102]->TE_ATTR[R2033] where ( selected.Included );
  for each te_attr in te_attrs
    if ( "" == te_attr.GeneratedType )
      cmp_element = "!T::s(i:te_instance.module)T::s(i:te_string.strcmp)(T::s(i:selected_var_name)->T::s(i:te_attr.GeneratedName), T::s(i:te_attr.ParamBuffer))";
    else
      //cmp_element = T::s(i:selected_var_name)->T::s(i:te_attr.GeneratedName) == T::s(i:te_attr.ParamBuffer);
    end if;
    compare_stmt = compare_stmt + cmp_element;
    //if ( not_last te_attrs )
      //compare_stmt = compare_stmt + " && ";
    //end if;
  end for;
T::b(s:compare_stmt);
end if;
return T::body();
',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("d4c38451-58df-43b2-9661-d71bffcfef00",
	"6d504832-7f3b-40f9-b738-617ebbd9ee75",
	'o_obj',
	"d6b21eeb-39da-43bf-b503-c7bbc9ddf242",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("302d882c-8b0e-4e5f-aa80-597507e0dbf1",
	"6d504832-7f3b-40f9-b738-617ebbd9ee75",
	'special',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"d4c38451-58df-43b2-9661-d71bffcfef00",
	'');
INSERT INTO S_SPARM
	VALUES ("58da156b-a19c-48a1-9263-ea825c707781",
	"6d504832-7f3b-40f9-b738-617ebbd9ee75",
	'selected_var_name',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"302d882c-8b0e-4e5f-aa80-597507e0dbf1",
	'');
INSERT INTO PE_PE
	VALUES ("6d504832-7f3b-40f9-b738-617ebbd9ee75",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("9b592989-83df-4759-a35f-d4ad0ec76796",
	"00000000-0000-0000-0000-000000000000",
	'CreateSpecialWhereComparisonArguments',
	'',
	'//
//==========================================================================
te_class = param.te_class;
o_id = param.o_id;
//
select many o_attrs related by o_id->O_OIDA[R105]->O_ATTR[R105];
num_ident_attr = cardinality o_attrs;
//
param_list = "";
oida_count = 0;
//
// Be sure we have the first attribute in the class.
select any first_te_attr related by te_class->TE_ATTR[R2061];
while ( not_empty first_te_attr )
  select one prev_te_attr related by first_te_attr->TE_ATTR[R2087.''precedes''];
  if ( empty prev_te_attr )
    break;
  end if;
  first_te_attr = prev_te_attr;
end while;
te_attr = first_te_attr;
while ( not_empty te_attr )
  if ( te_attr.Included )
    oida_count = oida_count + 1;
    param_list = param_list + te_attr.ParamBuffer;
    if ( oida_count < num_ident_attr )
      param_list = param_list + ", ";
    end if;
  end if;
  select one te_attr related by te_attr->TE_ATTR[R2087.''succeeds''];
end while;
//
return param_list;
',
	"ba5eda7a-def5-0000-0000-000000000004",
	1,
	'');
INSERT INTO S_SPARM
	VALUES ("9bb4abe2-3517-405b-b19d-bdf1b5f2f016",
	"9b592989-83df-4759-a35f-d4ad0ec76796",
	'te_class',
	"f975acb7-4246-4a87-9c5a-75481f096785",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("d7562a34-65c1-456c-81ad-193ad348c139",
	"9b592989-83df-4759-a35f-d4ad0ec76796",
	'o_id',
	"65d0a895-bf6c-48fa-ba74-80985a75698b",
	0,
	'',
	"9bb4abe2-3517-405b-b19d-bdf1b5f2f016",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("65d0a895-bf6c-48fa-ba74-80985a75698b",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Class Identifier>',
	'',
	'',
	'../Subsystem/Subsystem.xtuml');
INSERT INTO PE_PE
	VALUES ("9b592989-83df-4759-a35f-d4ad0ec76796",
	1,
	"e0e8a924-f549-4e50-9ee0-af61843ab967",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO PE_PE
	VALUES ("e0e8a924-f549-4e50-9ee0-af61843ab967",
	2,
	"efb614c1-5af5-40ee-92c8-706430a99db3",
	"00000000-0000-0000-0000-000000000000",
	7);
INSERT INTO EP_PKG_PROXY
	VALUES ("efb614c1-5af5-40ee-92c8-706430a99db3",
	"00000000-0000-0000-0000-000000000000",
	"d9bc5487-4193-4817-be1c-6c3f3339aebf",
	'ooaofooa',
	'========================================================================

File:          $RCSfile: ooaofooa.xtuml,v $
Version:   $Revision: 1.127 $
Modified:  $Date: 2006/09/26 15:10:20 $

(c) Copyright 2004-2012 by Mentor Graphics Corp. All rights reserved.

========================================================================
This document contains information proprietary and confidential to
Mentor Graphics Corp. and is not for external distribution.
========================================================================

This is the application domain for the Tiger project.

The processing in this model describes the activities
for model capture.



',
	0,
	'../ooaofooa.xtuml');
INSERT INTO S_SYS_PROXY
	VALUES ("d9bc5487-4193-4817-be1c-6c3f3339aebf",
	'com.mentor.nucleus.bp.core',
	1,
	'../../../../com.mentor.nucleus.bp.core.xtuml');

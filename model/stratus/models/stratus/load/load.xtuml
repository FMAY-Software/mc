-- BP 7.1.6 content: Package syschar: 3 persistence-version: 7.1.6

INSERT INTO EP_PKG
	VALUES ("fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"e1ca632b-b51d-48ee-b1a8-9539fcd49828",
	"e1ca632b-b51d-48ee-b1a8-9539fcd49828",
	'load',
	'',
	0);
INSERT INTO GD_MD
	VALUES ("2578af0a-0d3b-4429-9e9f-7058b1ef9bfd",
	112,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	108,
	0,
	0,
	1,
	1,
	1,
	12,
	1,
	0,
	0,
	200,
	150,
	0,
	'',
	'stratus::load');
INSERT INTO GD_GE
	VALUES ("434c8733-cf38-4a4d-b980-5478813c08be",
	"2578af0a-0d3b-4429-9e9f-7058b1ef9bfd",
	"d253fd26-846d-41fa-866d-36f9d01a0fa1",
	108,
	0,
	'stratus::load::selectors');
INSERT INTO GD_SHP
	VALUES ("434c8733-cf38-4a4d-b980-5478813c08be");
INSERT INTO GD_NCS
	VALUES ("434c8733-cf38-4a4d-b980-5478813c08be");
INSERT INTO DIM_ND
	VALUES (200.000000,
	150.000000,
	"434c8733-cf38-4a4d-b980-5478813c08be");
INSERT INTO DIM_GE
	VALUES (0.000000,
	0.000000,
	"434c8733-cf38-4a4d-b980-5478813c08be",
	"00000000-0000-0000-0000-000000000000");
INSERT INTO DIM_ELE
	VALUES ("434c8733-cf38-4a4d-b980-5478813c08be",
	0,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO GD_GE
	VALUES ("c50d9819-4067-4b80-be80-aaee7ac7b9ea",
	"2578af0a-0d3b-4429-9e9f-7058b1ef9bfd",
	"cf20d32f-ee33-4e4b-856b-a86d23675ef0",
	108,
	0,
	'stratus::load::marking');
INSERT INTO GD_SHP
	VALUES ("c50d9819-4067-4b80-be80-aaee7ac7b9ea");
INSERT INTO GD_NCS
	VALUES ("c50d9819-4067-4b80-be80-aaee7ac7b9ea");
INSERT INTO DIM_ND
	VALUES (200.000000,
	150.000000,
	"c50d9819-4067-4b80-be80-aaee7ac7b9ea");
INSERT INTO DIM_GE
	VALUES (220.000000,
	0.000000,
	"c50d9819-4067-4b80-be80-aaee7ac7b9ea",
	"00000000-0000-0000-0000-000000000000");
INSERT INTO DIM_ELE
	VALUES ("c50d9819-4067-4b80-be80-aaee7ac7b9ea",
	0,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO DIM_DIA
	VALUES ("2578af0a-0d3b-4429-9e9f-7058b1ef9bfd",
	'',
	1.000000,
	0.000000,
	0.000000,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO S_SYNC
	VALUES ("2fa13145-0c97-4f52-b60b-01b9250b2b55",
	"00000000-0000-0000-0000-000000000000",
	'BuiltinType_populate',
	'',
	'create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "instance";
create object instance any_instance_type of AnyInstanceType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to any_instance_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "boolean";
create object instance boolean_type of BooleanType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to boolean_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "character";
create object instance character_type of CharacterType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to character_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "device";
create object instance device_type of DeviceType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to device_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "duration";
create object instance duration_type of DurationType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to duration_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "event";
create object instance event_type of EventType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to event_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "string";
create object instance string_type of StringType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to string_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "timer";
create object instance timer_type of TimerType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to timer_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "timestamp";
create object instance timestamp_type of TimestampType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to timestamp_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "wcharacter";
create object instance wcharacter_type of WCharacterType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to wcharacter_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "wstring";
create object instance wstring_type of WStringType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to wstring_type across R6206;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "real";
create object instance numeric_type of NumericType;
numeric_type.bits = 64;
numeric_type.signed = true;
// create and link to min and max expressions
create object instance expression of MaslExpression;
create object instance literal_expression of LiteralExpression;
create object instance numeric_literal of NumericLiteral;
create object instance integer_literal of IntegerLiteral;
integer_literal.value = 2147483647; // 2 ^ 63 - 1 TODO
relate expression to literal_expression across R5517;
relate literal_expression to numeric_literal across R5700;
relate numeric_literal to integer_literal across R5703;
relate expression to numeric_type across R6222;
create object instance expression of MaslExpression;
create object instance literal_expression of LiteralExpression;
create object instance numeric_literal of NumericLiteral;
create object instance integer_literal of IntegerLiteral;
integer_literal.value = -2147483647; // 2 ^ 63 - 1 TODO
relate expression to literal_expression across R5517;
relate literal_expression to numeric_literal across R5700;
relate numeric_literal to integer_literal across R5703;
relate expression to numeric_type across R6223;
create object instance real_type of RealType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to numeric_type across R6206;
relate numeric_type to real_type across R6221;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "long_integer";
create object instance numeric_type of NumericType;
numeric_type.bits = 64;
numeric_type.signed = true;
// create and link to min and max expressions
create object instance expression of MaslExpression;
create object instance literal_expression of LiteralExpression;
create object instance numeric_literal of NumericLiteral;
create object instance integer_literal of IntegerLiteral;
integer_literal.value = 2147483647; // 2 ^ 63 - 1 TODO
relate expression to literal_expression across R5517;
relate literal_expression to numeric_literal across R5700;
relate numeric_literal to integer_literal across R5703;
relate expression to numeric_type across R6222;
create object instance expression of MaslExpression;
create object instance literal_expression of LiteralExpression;
create object instance numeric_literal of NumericLiteral;
create object instance integer_literal of IntegerLiteral;
integer_literal.value = -2147483647; // 2 ^ 63 - 1 TODO
relate expression to literal_expression across R5517;
relate literal_expression to numeric_literal across R5700;
relate numeric_literal to integer_literal across R5703;
relate expression to numeric_type across R6223;
create object instance integer_type of IntegerType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to numeric_type across R6206;
relate numeric_type to integer_type across R6221;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "byte";
create object instance numeric_type of NumericType;
numeric_type.bits = 8;
numeric_type.signed = false;
// create and link to min and max expressions
create object instance expression of MaslExpression;
create object instance literal_expression of LiteralExpression;
create object instance numeric_literal of NumericLiteral;
create object instance integer_literal of IntegerLiteral;
integer_literal.value = 255; // 2 ^ 8 - 1 TODO
relate expression to literal_expression across R5517;
relate literal_expression to numeric_literal across R5700;
relate numeric_literal to integer_literal across R5703;
relate expression to numeric_type across R6222;
create object instance expression of MaslExpression;
create object instance literal_expression of LiteralExpression;
create object instance numeric_literal of NumericLiteral;
create object instance integer_literal of IntegerLiteral;
integer_literal.value = 0;
relate expression to literal_expression across R5517;
relate literal_expression to numeric_literal across R5700;
relate numeric_literal to integer_literal across R5703;
relate expression to numeric_type across R6223;
create object instance byte_type of ByteType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to numeric_type across R6206;
relate numeric_type to byte_type across R6221;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
create object instance builtin_type of BuiltinType;
builtin_type.name = "integer";
create object instance numeric_type of NumericType;
numeric_type.bits = 32;
numeric_type.signed = false;
// create and link to min and max expressions
create object instance expression of MaslExpression;
create object instance literal_expression of LiteralExpression;
create object instance numeric_literal of NumericLiteral;
create object instance integer_literal of IntegerLiteral;
integer_literal.value = 2147483647; // 2 ^ 31 - 1 TODO
relate expression to literal_expression across R5517;
relate literal_expression to numeric_literal across R5700;
relate numeric_literal to integer_literal across R5703;
relate expression to numeric_type across R6222;
create object instance expression of MaslExpression;
create object instance literal_expression of LiteralExpression;
create object instance numeric_literal of NumericLiteral;
create object instance integer_literal of IntegerLiteral;
integer_literal.value = -2147483647; // - 2 ^ 31 - 1 TODO
relate expression to literal_expression across R5517;
relate literal_expression to numeric_literal across R5700;
relate numeric_literal to integer_literal across R5703;
relate expression to numeric_type across R6223;
create object instance small_type of SmallIntegerType;
relate type_definition to basic_type across R6236;
relate basic_type to builtin_type across R6205;
relate builtin_type to numeric_type across R6206;
relate numeric_type to small_type across R6221;

/* Comment out the logging if not desired.
 */
select many builtin_types from instances of BuiltinType where ( SORT::ascending( attr:"name" ) );
message = "builtin types:  ";
for each builtin_type in builtin_types
  message = message + builtin_type.name + " ";
end for;
LOG::LogInfo( message:message );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO PE_PE
	VALUES ("2fa13145-0c97-4f52-b60b-01b9250b2b55",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("8c5ed96e-e998-4395-bbf8-623ddde3eee9",
	"00000000-0000-0000-0000-000000000000",
	'create_DotExpression',
	'',
	'lhs = param.lhs;
create object instance expression of MaslExpression;

select one lhs_basic_type related by lhs->BasicType[R5570];
if (empty lhs_basic_type)
  LOG::LogFailure(message:"create_DotExpression:  lhs has no type - " + param.name);
end if;

// TODO - provide subtyping maybe from DotExpression <- SelectedAttributeExpression, SelectedComponentExpression, TypeNameExpression, ObjectNameExpresion

// Look for attribute access.
select one instance_type related by lhs_basic_type->InstanceType[R6205];
if (not_empty instance_type)
  select any attribute_declaration related by instance_type->ObjectDeclaration[R6220]->AttributeDeclaration[R5802] where (selected.name == param.name);
  if (not_empty attribute_declaration)
    // create selected attribute expression
    create object instance selected_attribute_expression of SelectedAttributeExpression;
    relate lhs to selected_attribute_expression across R5569;
    relate selected_attribute_expression to expression across R5517;
    relate selected_attribute_expression to attribute_declaration across R5541;
    select one basic_type related by attribute_declaration->BasicType[R5803];
    relate basic_type to expression across R5570;
    LOG::LogInfo(message:"create_DotExpression:  attribute:  " + param.name);
    return expression;
  end if;
  // Look for instance operation access.
  select any service related by instance_type->ObjectDeclaration[R6220]->ObjectService[R5808]->Service[R5203] where (selected.name == param.name);
  if (not_empty service)
    create object instance call_expr of CallExpression;
    relate call_expr to expression across R5517;
		create object instance service_invocation of ServiceInvocation;
		relate service_invocation to call_expr across R5500;
		create object instance instance_service_invocation of InstanceServiceInvocation;
		relate instance_service_invocation to service_invocation across R5610;
		relate lhs to instance_service_invocation across R5615;
		select one object_service related by service->ObjectService[R5203];
		relate object_service to instance_service_invocation across R5614;
		select one basic_type related by service->BasicType[R5205];
		if (not_empty basic_type)
      relate basic_type to expression across R5570;
    end if;
    LOG::LogInfo(message:"create_DotExpression:  object service invocation:  " + param.name);
    return expression;
  end if;
end if;

// Look for structure element.
/* TODO
select one structure_type related by lhs_basic_type->MaslUserDefinedType[R6205]->TypeDeclaration[R6241]->TypeDefinition[R6234]->FullTypeDefinition[R6236]->StructureType[R6219];
if (not_empty structure_type)
  select one structure_element related by structure_type->StructureElement[R6244];
  while (not_empty structure_element)
    if (param.name == structure_element.name)
      // create selected component expression
      create object instance selected_component_expression of SelectedComponentExpression;
      relate selected_component_expression to structure_element across R5543;
      relate selected_component_expression to dot_expression across R5571;
      select one basic_type related by structure_element->BasicType[R6230];
      LOG::LogInfo(message:"create_DotExpression:  structure element:  " + param.name);
      return basic_type;
    end if;
    select one structure_element related by structure_element->StructureElement[R6243.''precedes''];
  end while;
end if;
*/

LOG::LogFailure(message:"create_DotExpression: failed to resolve dot expression: " + param.name);
return expression;',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("8497859e-df75-4e8f-8b56-feeeb63e620c",
	"8c5ed96e-e998-4395-bbf8-623ddde3eee9",
	'name',
	"18a1a0a5-c53e-4a43-a5bc-f75ee1a2abe2",
	0,
	'',
	"45edb3d8-f5bc-43e5-ba45-c0fc8b5f3cdb",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("18a1a0a5-c53e-4a43-a5bc-f75ee1a2abe2",
	"00000000-0000-0000-0000-000000000000",
	'Name',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/Shared/Shared.xtuml');
INSERT INTO S_SPARM
	VALUES ("45edb3d8-f5bc-43e5-ba45-c0fc8b5f3cdb",
	"8c5ed96e-e998-4395-bbf8-623ddde3eee9",
	'lhs',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Expression>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/expression/expression.xtuml');
INSERT INTO PE_PE
	VALUES ("8c5ed96e-e998-4395-bbf8-623ddde3eee9",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("090d9c1b-7f20-4e26-9d28-1d080b6dd7cf",
	"00000000-0000-0000-0000-000000000000",
	'create_RelationshipSpecification',
	'',
	'relationship_declaration = param.relationship_declaration;
from_object_declaration = param.from_object_declaration;
to_object_declaration = param.to_object_declaration;

spec = "" + from_object_declaration.name + "->" + relationship_declaration.name;
if (param.object_or_role != "")
  spec = spec + "." + param.object_or_role;
end if;
if (not_empty to_object_declaration)
  spec = spec + "." + to_object_declaration.name;
end if;
LOG::LogInfo(message:"creating relationship spec: " + spec);

// Create the relationship specification
create object instance relationship_specification of RelationshipSpecification;
relate relationship_specification to relationship_declaration across R6015;
relate relationship_specification to from_object_declaration across R6014;


// Resolve when all information is provided.
if (not_empty to_object_declaration and param.object_or_role != "")
  
  // Fill out "to" object and role phrase
  relate relationship_specification to to_object_declaration across R6011;
  relationship_specification.role = param.object_or_role;

  // Find applicable half-relationship for binary and associative relationships.
  // Binary
	select one half_rel_1 related by relationship_declaration->NormalRelationshipDeclaration[R6010]->HalfRelationship[R6007];
	select one to_object_1 related by half_rel_1->ObjectDeclaration[R6004];
	if (not_empty to_object_1 and to_object_1.name == to_object_declaration.name and half_rel_1.role == param.object_or_role)
		LOG::LogInfo(message: "normal ltr from " + from_object_declaration.name + "->" + to_object_declaration.name);
		relate relationship_specification to half_rel_1 across R6013;
		relationship_specification.multiplicity = half_rel_1.multiplicity;
		relationship_specification.conditional = half_rel_1.isconditional;
		return relationship_specification;
	end if;
	select one half_rel_2 related by relationship_declaration->NormalRelationshipDeclaration[R6010]->HalfRelationship[R6008];
	select one to_object_2 related by half_rel_2->ObjectDeclaration[R6004];
	if (not_empty to_object_2 and to_object_2.name == to_object_declaration.name and half_rel_2.role == param.object_or_role)
		LOG::LogInfo(message: "normal rtl from " + from_object_declaration.name + "->" + to_object_declaration.name);
		relate relationship_specification to half_rel_2 across R6013;
		relationship_specification.multiplicity = half_rel_2.multiplicity;
		relationship_specification.conditional = half_rel_2.isconditional;
		return relationship_specification;
	end if;
	
	// Assoc
	select one half_rel_1 related by relationship_declaration->AssociativeRelationshipDeclaration[R6010]->HalfRelationship[R6000];
	select one from_object_1 related by half_rel_1->ObjectDeclaration[R6006];
	if (not_empty from_object_1 and from_object_1.name == from_object_declaration.name and half_rel_1.role == param.object_or_role)
		LOG::LogInfo(message: "assoc ltr from " + from_object_declaration.name + "->" + to_object_declaration.name);
		relate relationship_specification to half_rel_1 across R6013;
		relationship_specification.multiplicity = half_rel_1.multiplicity;
		relationship_specification.conditional = half_rel_1.isconditional;
		return relationship_specification;
	end if;
	select one half_rel_2 related by relationship_declaration->AssociativeRelationshipDeclaration[R6010]->HalfRelationship[R6002];
	select one from_object_2 related by half_rel_2->ObjectDeclaration[R6006];
	if (not_empty from_object_2 and from_object_2.name == from_object_declaration.name and half_rel_2.role == param.object_or_role)
		LOG::LogInfo(message: "assoc rtl from " + from_object_declaration.name + "->" + to_object_declaration.name);
		relate relationship_specification to half_rel_2 across R6013;
		relationship_specification.multiplicity = half_rel_2.multiplicity;
		relationship_specification.conditional = half_rel_2.isconditional;
		return relationship_specification;
	end if;
	select one link_obj related by relationship_declaration->AssociativeRelationshipDeclaration[R6010]
	  ->ObjectDeclaration[R6001] where selected.name == from_object_declaration.name;
	if (not_empty link_obj)  // from the associator to the one or other
		select one half_rel_1 related by relationship_declaration->AssociativeRelationshipDeclaration[R6010]->HalfRelationship[R6000];
		select one to_object_1 related by half_rel_1->ObjectDeclaration[R6004];
		if (not_empty to_object_1 and to_object_1.name == to_object_declaration.name and half_rel_1.role == param.object_or_role)
			LOG::LogInfo(message: "assoc ltr from " + to_object_declaration.name + "->" + to_object_declaration.name);
			relate relationship_specification to half_rel_1 across R6013;
			relationship_specification.multiplicity = half_rel_1.multiplicity;
			relationship_specification.conditional = half_rel_1.isconditional;
			return relationship_specification;
		end if;
		select one half_rel_2 related by relationship_declaration->AssociativeRelationshipDeclaration[R6010]->HalfRelationship[R6002];
		select one to_object_2 related by half_rel_2->ObjectDeclaration[R6004];
		if (not_empty to_object_2 and to_object_2.name == to_object_declaration.name and half_rel_2.role == param.object_or_role)
			LOG::LogInfo(message: "assoc rtl from " + to_object_declaration.name + "->" + to_object_declaration.name);
			relate relationship_specification to half_rel_2 across R6013;
			relationship_specification.multiplicity = half_rel_2.multiplicity;
			relationship_specification.conditional = half_rel_2.isconditional;
			return relationship_specification;
		end if;
	end if;
	
	// sub-super
  select one subsup related by relationship_declaration->SubtypeRelationshipDeclaration[R6010];
  if (not_empty subsup)
		relationship_specification.multiplicity = MaslMultiplicity::one;
		relationship_specification.conditional = false;
		return relationship_specification;
  end if;

// Resolve when the relationship name and either the object name or role phrase
// is provided but not both.
elif ((empty to_object_declaration and param.object_or_role != "") or
      (not_empty to_object_declaration and param.object_or_role == ""))
  if (empty to_object_declaration)
		select any to_object_declaration related by relationship_declaration->Domain[R6003]
			->ObjectDeclaration[R5805] where "" + selected.name == param.object_or_role;
  end if;

	// Resolve when only the relationship name and to object name are provided.
	// All non-reflexive binary and associative relationships and sub-super
	// relationships can be resolved with this information.
  if (not_empty to_object_declaration)
    if (to_object_declaration.name != from_object_declaration.name)

			// Fill out "to" object
			relate relationship_specification to to_object_declaration across R6011;

			// Find applicable half-relationship for binary and associative relationships.
			// Binary
			select one half_rel_1 related by relationship_declaration->NormalRelationshipDeclaration[R6010]->HalfRelationship[R6007];
			select one to_object_1 related by half_rel_1->ObjectDeclaration[R6004];
			if (not_empty to_object_1 and to_object_1.name == to_object_declaration.name)
				LOG::LogInfo(message: "normal ltr from " + from_object_declaration.name + "->" + to_object_declaration.name);
				relate relationship_specification to half_rel_1 across R6013;
				relationship_specification.multiplicity = half_rel_1.multiplicity;
				relationship_specification.conditional = half_rel_1.isconditional;
				relationship_specification.role = half_rel_1.role;
				return relationship_specification;
			end if;
			select one half_rel_2 related by relationship_declaration->NormalRelationshipDeclaration[R6010]->HalfRelationship[R6008];
			select one to_object_2 related by half_rel_2->ObjectDeclaration[R6004];
			if (not_empty to_object_2 and to_object_2.name == to_object_declaration.name)
				LOG::LogInfo(message: "normal rtl from " + from_object_declaration.name + "->" + to_object_declaration.name);
				relate relationship_specification to half_rel_2 across R6013;
				relationship_specification.multiplicity = half_rel_2.multiplicity;
				relationship_specification.conditional = half_rel_2.isconditional;
				relationship_specification.role = half_rel_2.role;
				return relationship_specification;
			end if;
			
			// Assoc
			select one half_rel_1 related by relationship_declaration->AssociativeRelationshipDeclaration[R6010]->HalfRelationship[R6000];
			select one from_object_1 related by half_rel_1->ObjectDeclaration[R6006];
			if (not_empty from_object_1 and from_object_1.name == from_object_declaration.name)
				LOG::LogInfo(message: "assoc ltr from " + from_object_declaration.name + "->" + to_object_declaration.name);
				relate relationship_specification to half_rel_1 across R6013;
				relationship_specification.multiplicity = half_rel_1.multiplicity;
				relationship_specification.conditional = half_rel_1.isconditional;
				relationship_specification.role = half_rel_1.role;
				return relationship_specification;
			end if;
			select one half_rel_2 related by relationship_declaration->AssociativeRelationshipDeclaration[R6010]->HalfRelationship[R6002];
			select one from_object_2 related by half_rel_2->ObjectDeclaration[R6006];
			if (not_empty from_object_2 and from_object_2.name == from_object_declaration.name)
				LOG::LogInfo(message: "assoc rtl from " + from_object_declaration.name + "->" + to_object_declaration.name);
				relate relationship_specification to half_rel_2 across R6013;
				relationship_specification.multiplicity = half_rel_2.multiplicity;
				relationship_specification.conditional = half_rel_2.isconditional;
				relationship_specification.role = half_rel_2.role;
				return relationship_specification;
			end if;
			select one link_obj related by relationship_declaration->AssociativeRelationshipDeclaration[R6010]
				->ObjectDeclaration[R6001] where selected.name == from_object_declaration.name;
			if (not_empty link_obj)  // from the associator to the one or other
				select one half_rel_1 related by relationship_declaration->AssociativeRelationshipDeclaration[R6010]->HalfRelationship[R6000];
				select one to_object_1 related by half_rel_1->ObjectDeclaration[R6004];
				if (not_empty to_object_1 and to_object_1.name == to_object_declaration.name)
					LOG::LogInfo(message: "assoc ltr from " + to_object_declaration.name + "->" + to_object_declaration.name);
					relate relationship_specification to half_rel_1 across R6013;
					relationship_specification.multiplicity = half_rel_1.multiplicity;
					relationship_specification.conditional = half_rel_1.isconditional;
					relationship_specification.role = half_rel_1.role;
					return relationship_specification;
				end if;
				select one half_rel_2 related by relationship_declaration->AssociativeRelationshipDeclaration[R6010]->HalfRelationship[R6002];
				select one to_object_2 related by half_rel_2->ObjectDeclaration[R6004];
				if (not_empty to_object_2 and to_object_2.name == to_object_declaration.name)
					LOG::LogInfo(message: "assoc rtl from " + to_object_declaration.name + "->" + to_object_declaration.name);
					relate relationship_specification to half_rel_2 across R6013;
					relationship_specification.multiplicity = half_rel_2.multiplicity;
					relationship_specification.conditional = half_rel_2.isconditional;
					relationship_specification.role = half_rel_2.role;
					return relationship_specification;
				end if;
			end if;
		end if;
			
			// sub-super
			select one subsup related by relationship_declaration->SubtypeRelationshipDeclaration[R6010];
			if (not_empty subsup)
				relationship_specification.multiplicity = MaslMultiplicity::one;
				relationship_specification.conditional = false;
				relationship_specification.role = "is_a";
				return relationship_specification;
			end if;
    
	// Resolve when only the relationship name and role phrase are provided.
	// Only binary relationships can be resolved with this information.
  else
    // TODO
    LOG::LogFailure(message:"TODO rel spec with only rel num and phrase not supported");

  end if;
  
// Resolve when only relationship name provided.
// Only non-reflexive binary associations and sub->supertype associations can be
// resolved with this little information.
elif (empty to_object_declaration and param.object_or_role == "")

	// normal binary non-reflexive
	select one half_rel_1 related by relationship_declaration->NormalRelationshipDeclaration[R6010]->HalfRelationship[R6007];
	select one object_declaration related by half_rel_1->ObjectDeclaration[R6004];
	if (not_empty object_declaration and from_object_declaration.name != object_declaration.name)
		LOG::LogInfo(message: "normal ltr from " + from_object_declaration.name + "->" + object_declaration.name);
		relate relationship_specification to half_rel_1 across R6013;
		relate relationship_specification to object_declaration across R6011;
		relationship_specification.multiplicity = half_rel_1.multiplicity;
		relationship_specification.conditional = half_rel_1.isconditional;
		return relationship_specification;
	end if;
	select one half_rel_2 related by relationship_declaration->NormalRelationshipDeclaration[R6010]->HalfRelationship[R6008];
	select one object_declaration related by half_rel_2->ObjectDeclaration[R6004];
	if (not_empty object_declaration and from_object_declaration.name != object_declaration.name)
		LOG::LogInfo(message: "normal rtl to " + from_object_declaration.name + "->" + object_declaration.name);
		relate relationship_specification to half_rel_2 across R6013;
		relate relationship_specification to object_declaration across R6011;
		relationship_specification.multiplicity = half_rel_2.multiplicity;
		relationship_specification.conditional = half_rel_2.isconditional;
		return relationship_specification;
	end if;

	// supertype
	select one object_declaration related by relationship_declaration->SubtypeRelationshipDeclaration[R6010]->ObjectDeclaration[R6017];
	if (not_empty object_declaration and from_object_declaration.name != object_declaration.name)
		LOG::LogInfo(message: "sub-super supertype " + from_object_declaration.name + "->" + object_declaration.name);
		relate relationship_specification to object_declaration across R6011;
		relationship_specification.multiplicity = MaslMultiplicity::one;
		relationship_specification.conditional = false;
	  relationship_specification.role = "is_a";
		return relationship_specification;
	end if;

end if;

LOG::LogFailure(message:"Failed to resolve relationship specification");
return relationship_specification;',
	"47e32455-be33-4b7c-9e44-d3b8f4f9ad39",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("01c2ac2c-dccd-4eed-99b4-a6caef76d43c",
	"090d9c1b-7f20-4e26-9d28-1d080b6dd7cf",
	'from_object_declaration',
	"ccbbc697-c60c-4034-8e31-7a46032151eb",
	0,
	'',
	"08bc443f-7e24-4cb7-8e8d-0e99e8bb8fc9",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("ccbbc697-c60c-4034-8e31-7a46032151eb",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<ObjectDeclaration>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/object/object.xtuml');
INSERT INTO S_SPARM
	VALUES ("08bc443f-7e24-4cb7-8e8d-0e99e8bb8fc9",
	"090d9c1b-7f20-4e26-9d28-1d080b6dd7cf",
	'relationship_declaration',
	"fc9b3839-3ca6-48c8-b09a-c036f8335a12",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("fc9b3839-3ca6-48c8-b09a-c036f8335a12",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<RelationshipDeclaration>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/relationship/relationship.xtuml');
INSERT INTO S_SPARM
	VALUES ("d7a813ed-b8ed-4aa3-afc3-5e9ddec62d42",
	"090d9c1b-7f20-4e26-9d28-1d080b6dd7cf",
	'object_or_role',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"01c2ac2c-dccd-4eed-99b4-a6caef76d43c",
	'');
INSERT INTO S_SPARM
	VALUES ("21e7b6d3-c7be-4951-9e8b-1a7ad83d3d2a",
	"090d9c1b-7f20-4e26-9d28-1d080b6dd7cf",
	'to_object_declaration',
	"ccbbc697-c60c-4034-8e31-7a46032151eb",
	0,
	'',
	"d7a813ed-b8ed-4aa3-afc3-5e9ddec62d42",
	'');
INSERT INTO PE_PE
	VALUES ("090d9c1b-7f20-4e26-9d28-1d080b6dd7cf",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_DT_PROXY
	VALUES ("47e32455-be33-4b7c-9e44-d3b8f4f9ad39",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<RelationshipSpecification>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/relationship/relationship.xtuml');
INSERT INTO S_SYNC
	VALUES ("646d0520-59e0-4335-b11f-e59c46fc675c",
	"00000000-0000-0000-0000-000000000000",
	'InternalType_populate',
	'',
	'create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
basic_type.isanonymous = true;
create object instance internal_type of InternalType;
internal_type.name = "characteristic";
relate type_definition to basic_type across R6236;
relate basic_type to internal_type across R6205;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
basic_type.isanonymous = true;
create object instance internal_type of InternalType;
internal_type.name = "enum";
relate type_definition to basic_type across R6236;
relate basic_type to internal_type across R6205;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
basic_type.isanonymous = true;
create object instance internal_type of InternalType;
internal_type.name = "object";
relate type_definition to basic_type across R6236;
relate basic_type to internal_type across R6205;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
basic_type.isanonymous = true;
create object instance internal_type of InternalType;
internal_type.name = "service";
relate type_definition to basic_type across R6236;
relate basic_type to internal_type across R6205;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
basic_type.isanonymous = true;
create object instance internal_type of InternalType;
internal_type.name = "split";
relate type_definition to basic_type across R6236;
relate basic_type to internal_type across R6205;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
basic_type.isanonymous = true;
create object instance internal_type of InternalType;
internal_type.name = "stream_modifier";
relate type_definition to basic_type across R6236;
relate basic_type to internal_type across R6205;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
basic_type.isanonymous = true;
create object instance internal_type of InternalType;
internal_type.name = "terminator";
relate type_definition to basic_type across R6236;
relate basic_type to internal_type across R6205;

create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
basic_type.isanonymous = true;
create object instance internal_type of InternalType;
internal_type.name = "type";
relate type_definition to basic_type across R6236;
relate basic_type to internal_type across R6205;

/* Comment out the logging if not desired.
 */
select many internal_types from instances of InternalType where ( SORT::ascending( attr:"name" ) );
message = "internal types:  ";
for each internal_type in internal_types
  message = message + internal_type.name + " ";
end for;
LOG::LogInfo( message:message );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO PE_PE
	VALUES ("646d0520-59e0-4335-b11f-e59c46fc675c",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("ece8c43b-0559-4bc6-91f2-4805bacb8b63",
	"00000000-0000-0000-0000-000000000000",
	'OrderingExpression_initialize',
	'',
	'ordering_expression = param.ordering_expression;
child_expression = param.child_expression;

ordering_expression.isreverse = param.isreverse;
relate ordering_expression to child_expression across R5535;

// Determine whether we have structures or instances.
select one child_basic_type related by child_expression->BasicType[R5570]->CollectionType[R6205]->BasicType[R6208];
select one instance_type related by child_basic_type->InstanceType[R6205];
if ( not_empty instance_type )
  // We have a collection of instances.
  create object instance instance_ordering_expression of InstanceOrderingExpression;
  relate instance_ordering_expression to ordering_expression across R5534;
else
  // We have a collection of structures
  create object instance structure_ordering_expression of StructureOrderingExpression;
  relate structure_ordering_expression to ordering_expression across R5534;
end if;

// Create an anonymous sequence of the same element as the child expression.
create object instance type_definition of TypeDefinition;
create object instance basic_type of BasicType;
basic_type.isanonymous = true;
create object instance collection_type of CollectionType;
create object instance sequence_type of SequenceType;
relate basic_type to type_definition across R6236;
relate collection_type to basic_type across R6205;
relate sequence_type to collection_type across R6207;
relate collection_type to child_basic_type across R6208;

return basic_type;',
	"f2470f88-fc4a-406d-ba1c-54179e448ed4",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("88d37daf-bb85-43d0-8d37-5a7979ca6cc0",
	"ece8c43b-0559-4bc6-91f2-4805bacb8b63",
	'child_expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"8d4c77d4-fe17-4711-a5fb-652acb129024",
	'');
INSERT INTO S_SPARM
	VALUES ("98ec35b4-1347-4a64-a5a6-e3bc8505da11",
	"ece8c43b-0559-4bc6-91f2-4805bacb8b63",
	'isreverse',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"88d37daf-bb85-43d0-8d37-5a7979ca6cc0",
	'');
INSERT INTO S_SPARM
	VALUES ("8d4c77d4-fe17-4711-a5fb-652acb129024",
	"ece8c43b-0559-4bc6-91f2-4805bacb8b63",
	'ordering_expression',
	"c91ad4ef-f132-440a-8a85-a39814523746",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("c91ad4ef-f132-440a-8a85-a39814523746",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<OrderingExpression>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/expression/expression.xtuml');
INSERT INTO PE_PE
	VALUES ("ece8c43b-0559-4bc6-91f2-4805bacb8b63",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_DT_PROXY
	VALUES ("f2470f88-fc4a-406d-ba1c-54179e448ed4",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<BasicType>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/type/type.xtuml');
INSERT INTO S_SYNC
	VALUES ("20183b0e-40fc-465f-94b7-5494d92bc624",
	"00000000-0000-0000-0000-000000000000",
	'OrderingExpression_sort',
	'',
	'ordering_expression = param.ordering_expression;

select one child_basic_type related by ordering_expression->MaslExpression[R5535]->BasicType[R5570]->CollectionType[R6205]->BasicType[R6208];
select one instance_ordering_expression related by ordering_expression->InstanceOrderingExpression[R5534];
if ( not_empty instance_ordering_expression )
  select one instance_type related by child_basic_type->InstanceType[R6205];
  select one object_declaration related by instance_type->ObjectDeclaration[R6220];
  select any attribute_declaration related by object_declaration->AttributeDeclaration[R5802] where ( selected.name == param.name );
  if ( not_empty attribute_declaration )
    relate attribute_declaration to instance_ordering_expression across R5563;
  end if;
else
  select one structure_ordering_expression related by ordering_expression->StructureOrderingExpression[R5534];
  select one structure_type related by child_basic_type->MaslUserDefinedType[R6205]->TypeDeclaration[R6241]->TypeDefinition[R6234]->FullTypeDefinition[R6236]->StructureType[R6219];
  select one structure_element related by structure_type->StructureElement[R6244];
  while ( not_empty structure_element )
    if ( structure_element.name == param.name )
      relate structure_element to structure_ordering_expression across R5564;
      break;
    end if;
    select one structure_element related by structure_element->StructureElement[R6243.''precedes''];
  end while;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("120e9147-178e-45ac-8fb9-475ad8821729",
	"20183b0e-40fc-465f-94b7-5494d92bc624",
	'ordering_expression',
	"c91ad4ef-f132-440a-8a85-a39814523746",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("df97b1a7-79bb-468e-9dc2-dade0205c464",
	"20183b0e-40fc-465f-94b7-5494d92bc624",
	'name',
	"18a1a0a5-c53e-4a43-a5bc-f75ee1a2abe2",
	0,
	'',
	"120e9147-178e-45ac-8fb9-475ad8821729",
	'');
INSERT INTO S_SPARM
	VALUES ("090f6775-958f-4976-b78a-4b38c717dd32",
	"20183b0e-40fc-465f-94b7-5494d92bc624",
	'isreverse',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"df97b1a7-79bb-468e-9dc2-dade0205c464",
	'');
INSERT INTO PE_PE
	VALUES ("20183b0e-40fc-465f-94b7-5494d92bc624",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("90e0a8bb-2227-4ea2-a3cd-74317453fb69",
	"00000000-0000-0000-0000-000000000000",
	'ReferentialAttribute_resolve',
	'',
	'// Link up the referential attributes here after all objects and attributes
// are fully defined.  During the first pass, the referentials were linked
// to themselves.

LOG::LogInfo( message:"RerentialAttribute_resolve starting..." );

o_referring = ""; o_referenced = ""; // string UDTs
select many referential_attribute_definitions from instances of ReferentialAttributeDefinition;
for each referential_attribute_definition in referential_attribute_definitions
  select one referring_attribute_declaration related by referential_attribute_definition->AttributeDeclaration[R5800.''is_referenced_by''];
  select one referring_object_declaration related by referring_attribute_declaration->ObjectDeclaration[R5802];
  o_referring = referring_object_declaration.name;
  o_referring = o_referring + "." + referential_attribute_definition.name;
  unrelate referring_attribute_declaration from referring_attribute_declaration across R5800.''refers_to'' using referential_attribute_definition;
  select any referenced_attribute_declaration related by
    referential_attribute_definition->RelationshipSpecification[R5811]->ObjectDeclaration[R6011]->AttributeDeclaration[R5802]
    where ( selected.name == referential_attribute_definition.name );
  if ( empty referenced_attribute_declaration )
    LOG::LogFailure( message:"RerentialAttribute_resolve failed to find referenced attribute:  " + referential_attribute_definition.name );
  else
    select one referenced_object_declaration related by referenced_attribute_declaration->ObjectDeclaration[R5802];
    o_referenced = referenced_object_declaration.name;
    o_referenced = o_referenced + "." + referenced_attribute_declaration.name;
    relate referring_attribute_declaration to referenced_attribute_declaration across R5800.''refers_to'' using referential_attribute_definition;
    LOG::LogInfo( message:"RerentialAttribute_resolve " + o_referring + " to " + o_referenced );
  end if;
end for;

LOG::LogInfo( message:"RerentialAttribute_resolve ...done" );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO PE_PE
	VALUES ("90e0a8bb-2227-4ea2-a3cd-74317453fb69",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("833efa7d-504f-41aa-86e3-501de92ef97c",
	"00000000-0000-0000-0000-000000000000",
	'relate_ObjectDeclaration_to_Domain',
	'',
	'// relate the two, but not if already related
object_declaration = param.object_declaration;
if not_empty object_declaration
  select one domain related by object_declaration->Domain[R5805];
  if empty domain
    domain = param.domain;
    relate object_declaration to domain across R5805;
  end if;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	1);
INSERT INTO S_SPARM
	VALUES ("a99c4e53-1924-4627-afe7-b9f6789f1cf7",
	"833efa7d-504f-41aa-86e3-501de92ef97c",
	'object_declaration',
	"ccbbc697-c60c-4034-8e31-7a46032151eb",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("154560e5-f3ab-469e-bc56-a2022769b696",
	"833efa7d-504f-41aa-86e3-501de92ef97c",
	'domain',
	"d467079c-c61e-4b05-8498-3fe2f24782a6",
	0,
	'',
	"a99c4e53-1924-4627-afe7-b9f6789f1cf7",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("d467079c-c61e-4b05-8498-3fe2f24782a6",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Domain>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/domain/domain.xtuml');
INSERT INTO PE_PE
	VALUES ("833efa7d-504f-41aa-86e3-501de92ef97c",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("2a726c91-8ada-4a55-a49a-4b424f6dbcb2",
	"00000000-0000-0000-0000-000000000000",
	'resolve_name',
	'',
	'/*
AttributeDeclaration
EventDeclaration
EnumeratorItem
*/ 
expression = param.expression;
code_block = param.code_block;
message = ""; d = ""; n = ""; s = ""; // string UDTs
d = param.domainname; n = param.name;
message = "resolve_name( " + param.trace + ", " + d + "::" + n + ", ";
if ( not_empty code_block )
  select one service related by code_block->Service[R5403];
  if ( empty service )
    select one state related by code_block->MaslState[R6115];
    if ( empty state )
      LOG::LogFailure( message:"empty service and state" );
    else
      s = state.name;
    end if;
  else
    s = service.name;
  end if;
  message = message + "true(" + s + ")";
else
  message = message + "false";
end if;
message = message + " ) - ";
LOG::LogInfo( message: message + "starting..." );
// TODO not sure I need this
select any basic_type from instances of BasicType where ( false );

// charactistics
if ( "elements" == n ) // UDT strings
  select one basic_type related by expression->BasicType[R5570];
  select one instance_type related by basic_type->InstanceType[R6205];
  if ( not_empty instance_type )
    LOG::LogInfo( message: message + "elements instance type" );
    return basic_type;
  end if;
  select one collection_type related by basic_type->CollectionType[R6205];
  if ( not_empty collection_type )
    LOG::LogInfo( message: message + "elements collection type" );
    return basic_type;
  else
    LOG::LogFailure( message: message + "was not a collection type" );
  end if;
elif ( "first" == n ) // UDT strings
elif ( "last" == n ) // UDT strings
else
end if;

// variable
if ( not_empty code_block )
  select any variable_definition related by code_block->VariableDefinition[R5151] where ( selected.name == param.name );
  if ( not_empty variable_definition )
    create object instance variable_name_expression of VariableNameExpression;
    relate expression to variable_name_expression across R5517;
    select one basic_type related by variable_definition->BasicType[R5137];
    relate variable_name_expression to variable_definition across R5562;
    LOG::LogInfo( message: message + "variable." );
    return basic_type;
  end if;
end if;

// parameter
if ( not_empty code_block )
  select one parameter_definition related by code_block->Service[R5403]->ParameterDefinition[R5204];
  while ( not_empty parameter_definition )
    if ( parameter_definition.name == param.name )
      create object instance parameter_name_expression of ParameterNameExpression;
      relate expression to parameter_name_expression across R5517;
      relate parameter_name_expression to parameter_definition across R5536;
      select one basic_type related by parameter_definition->BasicType[R5200];
      LOG::LogInfo( message: message + "parameter." );
      return basic_type;
    end if;
    select one parameter_definition related by parameter_definition->ParameterDefinition[R5208.''precedes''];
  end while;
end if;

// type
select any builtin_type from instances of BuiltinType where ( selected.name == param.name );
if ( not_empty builtin_type )
  select one basic_type related by builtin_type->BasicType[R6205];
  LOG::LogInfo( message: message + "builtin type." );
  return basic_type;
else
  select any domain from instances of Domain where ( selected.name == param.domainname );
  select any user_defined_type from instances of MaslUserDefinedType where ( selected.name == param.name );
  if ( not_empty domain )
    select any user_defined_type related by domain->MaslUserDefinedType[R6235] where ( selected.name == param.name );
  end if;
  if ( not_empty user_defined_type )
    select one basic_type related by user_defined_type->BasicType[R6205];
    LOG::LogInfo( message: message + "user type." );
    return basic_type;
  end if;
end if;

// service
// TODO full signature
select any service from instances of Service where ( selected.name == param.name );
if ( not_empty service )
  select any service_overload related by service->ServiceOverload[R5207];
  create object instance service_expression of ServiceExpression;
  relate expression to service_expression across R5517;
  //relate service_expression to service_overload across R5545;
  select one basic_type related by service->BasicType[R5205];
  LOG::LogInfo( message: message + "service." );
  return basic_type;
end if;

// object
select any object_declaration from instances of ObjectDeclaration where ( selected.name == param.name );
if ( not_empty object_declaration )
  create object instance object_name_expression of ObjectNameExpression;
  relate expression to object_name_expression across R5517;
  relate object_name_expression to object_declaration across R5533;
  // TODO - may need to know that we need a set
  basic_type = ::select_create_InstanceType( object_declaration: object_declaration, isset: false );
  if ( empty basic_type )
    LOG::LogFailure( message: message + "before object... basic_type is empty" );
  end if;
  LOG::LogInfo( message: message + "object." );
  return basic_type;
end if;

// terminator
select any domain_terminator from instances of DomainTerminator where ( selected.name == param.name );
if ( not_empty domain_terminator )
  create object instance terminator_name_expression of TerminatorNameExpression;
  relate expression to terminator_name_expression across R5517;
  relate terminator_name_expression to domain_terminator across R5555;
  t = param.name; // string UDTs
  t = "terminator";
  select any internal_type from instances of InternalType where ( selected.name == t );
  select one basic_type related by internal_type->BasicType[R6205];
  LOG::LogInfo( message: message + "terminator." );
  return basic_type;
end if;

// attribute
// TODO I think this will be moved/duplicated in a routine used to resolve DotExpression.
select any attribute_declaration from instances of AttributeDeclaration where ( selected.name == param.name );
if ( not_empty attribute_declaration )
  create object instance selected_attribute_expression of SelectedAttributeExpression;
  relate selected_attribute_expression to attribute_declaration across R5541;
  select one basic_type related by attribute_declaration->BasicType[R5803];
  LOG::LogInfo( message: message + "attribute." );
  return basic_type;
end if;

// enumerator
select any enumerate_item from instances of EnumerateItem where ( selected.name == param.name );
if ( not_empty enumerate_item )
  create object instance literal_expression of LiteralExpression;
  create object instance enumerate_literal of EnumerateLiteral;
  relate enumerate_literal to literal_expression across R5700;
  relate enumerate_literal to enumerate_item across R5701;
  relate expression to literal_expression across R5517;
  select any basic_type related by enumerate_item->EnumerateType[R6218]->FullTypeDefinition[R6219]->TypeDefinition[R6236]->TypeDeclaration[R6234]->MaslUserDefinedType[R6241]->BasicType[R6205];
  LOG::LogInfo( message: message + "enumerator." );
  return basic_type;
end if;

return basic_type;',
	"f2470f88-fc4a-406d-ba1c-54179e448ed4",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("d12ba210-f6c0-44f9-b7b5-025dbb423d12",
	"2a726c91-8ada-4a55-a49a-4b424f6dbcb2",
	'name',
	"18a1a0a5-c53e-4a43-a5bc-f75ee1a2abe2",
	0,
	'',
	"1aad90a0-c186-4cb7-8b6f-c68499439519",
	'');
INSERT INTO S_SPARM
	VALUES ("5e9ba6eb-30d8-4682-955f-fca77cb8391b",
	"2a726c91-8ada-4a55-a49a-4b424f6dbcb2",
	'expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"5e844c88-314b-44fe-82d6-9d9f1fa58688",
	'');
INSERT INTO S_SPARM
	VALUES ("1aad90a0-c186-4cb7-8b6f-c68499439519",
	"2a726c91-8ada-4a55-a49a-4b424f6dbcb2",
	'domainname',
	"18a1a0a5-c53e-4a43-a5bc-f75ee1a2abe2",
	0,
	'',
	"5e9ba6eb-30d8-4682-955f-fca77cb8391b",
	'');
INSERT INTO S_SPARM
	VALUES ("5e844c88-314b-44fe-82d6-9d9f1fa58688",
	"2a726c91-8ada-4a55-a49a-4b424f6dbcb2",
	'code_block',
	"a76746ea-c05f-42fd-bfbf-00a70b069bb6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("a76746ea-c05f-42fd-bfbf-00a70b069bb6",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<CodeBlock>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/statement/statement.xtuml');
INSERT INTO S_SPARM
	VALUES ("3aa7cff8-ae53-4666-b575-887685c25d55",
	"2a726c91-8ada-4a55-a49a-4b424f6dbcb2",
	'trace',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"d12ba210-f6c0-44f9-b7b5-025dbb423d12",
	'');
INSERT INTO PE_PE
	VALUES ("2a726c91-8ada-4a55-a49a-4b424f6dbcb2",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("183c6254-c6e2-4d4e-a5f3-5011775222ab",
	"00000000-0000-0000-0000-000000000000",
	'resolve_NameExpression',
	'',
	'select any domain from instances of Domain where selected.name == param.domain_name;
current_block = param.current_block;

// search for local variable reference
select any var related by current_block->VariableDefinition[R5151] where (selected.name == param.name);
while (not_empty current_block and empty var)
  select one current_block related by current_block->MaslCodeBlock[R5160.''nested_within''];
  select any var related by current_block->VariableDefinition[R5151] where (selected.name == param.name);
end while;
if (not_empty var)
  // create a new variable reference
  create object instance expr of MaslExpression;
  select one type related by var->BasicType[R5137];
  relate type to expr across R5570;
  create object instance var_ref of VariableNameExpression;
  relate var_ref to expr across R5517;
  relate var_ref to var across R5562;
  LOG::LogInfo(message:"resolved name [variable]: ''" + param.name + "''");
  return expr;
end if;

// search for parameter reference
current_block = param.current_block;
select one current_service related by current_block->Service[R5403];
select one current_state related by current_block->MaslState[R6115];
while ((empty current_service and empty current_state) and not_empty current_block)
  select one current_block related by current_block->MaslCodeBlock[R5160.''nested_within''];
  select one current_service related by current_block->Service[R5403];
  select one current_state related by current_block->MaslState[R6115];
end while;
select any ref_param from instances of ParameterDefinition where false;
select one service_param related by current_service->ParameterDefinition[R5204];
while (not_empty service_param and empty ref_param)
  if (service_param.name == param.name)
    ref_param = service_param;
  end if;
  select one service_param related by service_param->ParameterDefinition[R5208.''precedes''];
end while;
select one state_param related by current_state->ParameterDefinition[R6104];
while (not_empty state_param and empty ref_param)
  if (state_param.name == param.name)
    ref_param = state_param;
  end if;
  select one state_param related by state_param->ParameterDefinition[R5208.''precedes''];
end while;
if (not_empty ref_param)
  create object instance expr of MaslExpression;
  create object instance param_ref of ParameterNameExpression;
  relate param_ref to expr across R5517;
  relate ref_param to param_ref across R5536;
  select one type related by ref_param->BasicType[R5200];
  relate type to expr across R5570;
  LOG::LogInfo(message:"resolved name [parameter]: ''" + param.name + "''");
  return expr;
end if;

// search for domain service reference
select any service related by domain->DomainService[R5303]->Service[R5203] where selected.name == param.name;
if (not_empty service)
  create object instance expr of MaslExpression;
  select one type related by service->BasicType[R5205];
  if (not_empty type)
    relate type to expr across R5570;
  end if;
  create object instance call_expr of CallExpression;
  relate call_expr to expr across R5517;
  create object instance service_invocation of ServiceInvocation;
  relate service_invocation to call_expr across R5500;
  create object instance domain_service_invocation of DomainServiceInvocation;
  relate domain_service_invocation to service_invocation across R5610;
  select one domain_service related by service->DomainService[R5203];
  relate domain_service to domain_service_invocation across R5611;
  LOG::LogInfo(message:"resolved name [domain service]: ''" + param.name + "''");
  return expr;
end if;

// search for objects
select any object_declaration related by domain->ObjectDeclaration[R5805] where selected.name == param.name;
if (not_empty object_declaration)
  create object instance expr of MaslExpression;
  create object instance obj_name_expr of ObjectNameExpression;
  relate obj_name_expr to expr across R5517;
  relate object_declaration to obj_name_expr across R5533;
  type = ::select_create_InstanceType(object_declaration:object_declaration, isset:true);
  relate type to expr across R5570;
  LOG::LogInfo(message:"resolved name [object]: ''" + param.name + "''");
  return expr;
end if;

// search for terminators
// we don''t have the service name yet, so we have to return a placeholder
// service expression link any terminator service just to have a connection to
// the terminator -- it will get relinked later.
select any terminator related by domain->DomainTerminator[R5304] where selected.name == param.name;
if (not_empty terminator)
  create object instance expr of MaslExpression;
  create object instance call_expr of CallExpression;
  relate call_expr to expr across R5517;
  create object instance service_invocation of ServiceInvocation;
  relate service_invocation to call_expr across R5500;
  create object instance terminator_service_invocation of TerminatorServiceInvocation;
  relate terminator_service_invocation to service_invocation across R5610;
  select any terminator_service related by terminator->DomainTerminatorService[R5306];
  relate terminator_service to terminator_service_invocation across R5612;
  LOG::LogInfo(message:"resolved name [terminator]: ''" + param.name + "''");
  return expr;
end if;

// search for types
// TODO need to understand cast rules more
select any builtin from instances of BuiltinType where selected.name == param.name;
if (not_empty builtin)
  // create a new type cast expression
  create object instance expr of MaslExpression;
  select one type related by builtin->BasicType[R6205];
  relate type to expr across R5570;
  create object instance call_expr of CallExpression;
  relate call_expr to expr across R5517;
  create object instance cast of CastExpression;
  relate cast to call_expr across R5500;
  relate type to cast across R5501;
  LOG::LogInfo(message:"resolved name [type cast]: ''" + param.name + "''");
  return expr;
end if;

LOG::LogFailure(message:"Could not resolve name expression: " + param.domain_name + ", " + param.name);
select any expr from instances of MaslExpression where false;
return expr;',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	1,
	'',
	0,
	2);
INSERT INTO S_SPARM
	VALUES ("fedc6e46-b6f0-48ac-9833-caf14c14d63e",
	"183c6254-c6e2-4d4e-a5f3-5011775222ab",
	'domain_name',
	"18a1a0a5-c53e-4a43-a5bc-f75ee1a2abe2",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("36951a0f-4c2a-4b7c-b397-52e2fb563a44",
	"183c6254-c6e2-4d4e-a5f3-5011775222ab",
	'name',
	"18a1a0a5-c53e-4a43-a5bc-f75ee1a2abe2",
	0,
	'',
	"fedc6e46-b6f0-48ac-9833-caf14c14d63e",
	'');
INSERT INTO S_SPARM
	VALUES ("e71e8b02-8ca0-473b-b978-25e75c6c8e28",
	"183c6254-c6e2-4d4e-a5f3-5011775222ab",
	'current_block',
	"a76746ea-c05f-42fd-bfbf-00a70b069bb6",
	0,
	'',
	"36951a0f-4c2a-4b7c-b397-52e2fb563a44",
	'');
INSERT INTO PE_PE
	VALUES ("183c6254-c6e2-4d4e-a5f3-5011775222ab",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a638a541-62b0-4d67-9e02-a9cae42a5b4d",
	"00000000-0000-0000-0000-000000000000",
	'resolve_BinaryExpression_type',
	'',
	'expression = param.expression;
lhs = param.lhs;
rhs = param.rhs;

select one l_type related by lhs->BasicType[R5570];
select one r_type related by rhs->BasicType[R5570];

// default to using the type of the left-hand-side
binary_type = l_type;

// handle numeric types
select one l_numeric related by l_type->BuiltinType[R6205]->NumericType[R6206];
select one r_numeric related by r_type->BuiltinType[R6205]->NumericType[R6206];
if (not_empty l_numeric and not_empty r_numeric)
  // if either of the types is real, promot to real otherwise take the left type
  // only need to check the right-hand-side since LHS is the default
  select one r_builtin related by r_numeric->BuiltinType[R6206];
  if ("" + r_builtin.name == "real")
    binary_type = r_type;
  end if;
end if;

// comparison and logical binary expressions are always boolean
select one comp_binary related by expression->BinaryExpression[R5517]->BinaryComparisonExpression[R5000];
select one logical_binary related by expression->BinaryExpression[R5517]->BinaryLogicalExpression[R5000];
if (not_empty comp_binary or not_empty logical_binary)
  select any bool_type from instances of BuiltinType where "" + selected.name == "boolean";
  select one binary_type related by bool_type->BasicType[R6205];
end if;

// type the expression
relate binary_type to expression across R5570;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	3);
INSERT INTO S_SPARM
	VALUES ("7afdb7d5-027f-4100-8b8a-950b3e27acc9",
	"a638a541-62b0-4d67-9e02-a9cae42a5b4d",
	'expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("c56f0b39-1c44-413d-85b5-dbd10fc56088",
	"a638a541-62b0-4d67-9e02-a9cae42a5b4d",
	'lhs',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"7afdb7d5-027f-4100-8b8a-950b3e27acc9",
	'');
INSERT INTO S_SPARM
	VALUES ("3dd22e06-404d-462b-9415-49dab59f2fb9",
	"a638a541-62b0-4d67-9e02-a9cae42a5b4d",
	'rhs',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"c56f0b39-1c44-413d-85b5-dbd10fc56088",
	'');
INSERT INTO PE_PE
	VALUES ("a638a541-62b0-4d67-9e02-a9cae42a5b4d",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("9950c3b6-9aff-4add-b253-0ee4d87f10e5",
	"00000000-0000-0000-0000-000000000000",
	'resolve_Expression_ArgumentList',
	'',
	'expression = param.expression;
first_argument = param.first_argument;

select one call_expr related by expression->CallExpression[R5517];
if (not_empty call_expr and not_empty first_argument)
  relate first_argument to call_expr across R5575;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	4);
INSERT INTO S_SPARM
	VALUES ("c02182a4-29f3-4906-bd55-fa851fcdcf28",
	"9950c3b6-9aff-4add-b253-0ee4d87f10e5",
	'expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("372c7571-e9e3-4168-8e25-633579955a66",
	"9950c3b6-9aff-4add-b253-0ee4d87f10e5",
	'first_argument',
	"55087eb6-f47a-4ad0-9d03-015c8f3c3663",
	0,
	'',
	"c02182a4-29f3-4906-bd55-fa851fcdcf28",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("55087eb6-f47a-4ad0-9d03-015c8f3c3663",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Argument>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/expression/expression.xtuml');
INSERT INTO PE_PE
	VALUES ("9950c3b6-9aff-4add-b253-0ee4d87f10e5",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("93010171-646f-4498-b423-fab780cdb6fe",
	"00000000-0000-0000-0000-000000000000",
	'resolve_ServiceCall',
	'',
	'service_call = param.service_call;
expression = param.expression;
select one service_invocation related by expression->CallExpression[R5517]->ServiceInvocation[R5500];
if (not_empty service_call and not_empty service_invocation)
  relate service_call to service_invocation across R5161;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	5);
INSERT INTO S_SPARM
	VALUES ("4ef35007-2a43-4084-94b6-4480118d5d51",
	"93010171-646f-4498-b423-fab780cdb6fe",
	'service_call',
	"9e1e8ee5-e6f9-48b8-a8f3-324c684cde30",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("9e1e8ee5-e6f9-48b8-a8f3-324c684cde30",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<ServiceCall>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/statement/statement.xtuml');
INSERT INTO S_SPARM
	VALUES ("bbbf6b59-e897-4a66-858b-0fb595d578e8",
	"93010171-646f-4498-b423-fab780cdb6fe",
	'expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"4ef35007-2a43-4084-94b6-4480118d5d51",
	'');
INSERT INTO PE_PE
	VALUES ("93010171-646f-4498-b423-fab780cdb6fe",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("dafc5a91-48fd-4fcd-961a-350711f96eaf",
	"00000000-0000-0000-0000-000000000000",
	'resolve_TerminatorServiceInvocation',
	'',
	'expression = param.terminator_service_expression;
service_name = param.service_name;

// gather info
select one terminator_service_invocation related by expression->CallExpression[R5517]->ServiceInvocation[R5500]->TerminatorServiceInvocation[R5610];
select one existing_terminator_service related by terminator_service_invocation->DomainTerminatorService[R5612];
select any service related by existing_terminator_service->DomainTerminator[R5306]->DomainTerminatorService[R5306]->Service[R5203] where selected.name == service_name;
if (not_empty service)
	select one new_terminator_service related by service->DomainTerminatorService[R5203];

	// unlink and link the terminator service
	if existing_terminator_service != new_terminator_service
		unrelate existing_terminator_service from terminator_service_invocation across R5612;
		relate new_terminator_service to terminator_service_invocation across R5612;
	end if;

	// link the type to the expression
	select one type related by service->BasicType[R5205];
	if (not_empty type)
		relate type to expression across R5570;
	end if;

else
  LOG::LogFailure(message:"Failed to resolve terminator service");
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	6);
INSERT INTO S_SPARM
	VALUES ("5553823a-ad3a-4fec-bdc0-9f7b728f8903",
	"dafc5a91-48fd-4fcd-961a-350711f96eaf",
	'terminator_service_expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("0cfc70d6-e1ce-4570-b7ed-fadc2bbe88bf",
	"dafc5a91-48fd-4fcd-961a-350711f96eaf",
	'service_name',
	"18a1a0a5-c53e-4a43-a5bc-f75ee1a2abe2",
	0,
	'',
	"5553823a-ad3a-4fec-bdc0-9f7b728f8903",
	'');
INSERT INTO PE_PE
	VALUES ("dafc5a91-48fd-4fcd-961a-350711f96eaf",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("52644604-406b-4908-8eec-87492d918120",
	"00000000-0000-0000-0000-000000000000",
	'resolve_FindExpression_type',
	'',
	'expression = param.expression;
select one find_expression related by expression->FindExpression[R5517];
if (not_empty find_expression)
  // for now, assume the root expression is a set
  select one root_type related by find_expression->MaslExpression[R5519]->BasicType[R5570];
  if find_expression.flavor == FindType::find
    relate root_type to expression across R5570;
  elif find_expression.flavor == FindType::find_one
    select one root_single_type related by root_type->CollectionType[R6205]->BasicType[R6208];
    relate root_single_type to expression across R5570;
  elif find_expression.flavor == FindType::find_only
    // TODO
  end if;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	3);
INSERT INTO S_SPARM
	VALUES ("571e0577-84d0-458a-a437-c456b85fe7f1",
	"52644604-406b-4908-8eec-87492d918120",
	'expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("52644604-406b-4908-8eec-87492d918120",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("01643d70-2092-460d-856a-f4ddca302cc7",
	"00000000-0000-0000-0000-000000000000",
	'resolve_NavigationExpression',
	'',
	'expression = param.expression;
select one rel_spec related by expression->NavigationExpression[R5517]->RelationshipSpecification[R5531];
select one lhs_collection related by expression->NavigationExpression[R5517]->MaslExpression[R5532]->BasicType[R5570]->CollectionType[R6205];
select one to_obj_decl related by rel_spec->ObjectDeclaration[R6011];

select any nav_type from instances of BasicType where false;

// if the rel spec is a "many" association or the lhs is a collection type,
// assure that the type of the expression is an instance set
if (rel_spec.multiplicity == MaslMultiplicity::many or not_empty lhs_collection)
  nav_type = ::select_create_InstanceType(object_declaration:to_obj_decl, isset:true);
else
  nav_type = ::select_create_InstanceType(object_declaration:to_obj_decl, isset:false);
end if;
relate nav_type to expression across R5570;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	7);
INSERT INTO S_SPARM
	VALUES ("da8d8905-9e8b-4627-9a36-e95419bc25d6",
	"01643d70-2092-460d-856a-f4ddca302cc7",
	'expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("01643d70-2092-460d-856a-f4ddca302cc7",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("fde2dcaf-3b9c-4652-818e-0b354fdc66fc",
	"00000000-0000-0000-0000-000000000000",
	'resolve_NumericUnaryLiteral',
	'',
	'expression = param.expression;
op = param.op;

select one numeric_literal related by expression->LiteralExpression[R5517]->NumericLiteral[R5700];
if (not_empty numeric_literal and op == "Operator::minus")
  numeric_literal.text = "-" + numeric_literal.text;
  LOG::LogInfo(message:"Numeric negation applied to literal");
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	8);
INSERT INTO S_SPARM
	VALUES ("39393a9d-52b6-4c26-9721-018e5ecc16ed",
	"fde2dcaf-3b9c-4652-818e-0b354fdc66fc",
	'expression',
	"0f86953a-c0a1-4f83-b7e4-af32c53c2d6d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("5ee4b190-786c-4c3f-9e64-3803b49aa2af",
	"fde2dcaf-3b9c-4652-818e-0b354fdc66fc",
	'op',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"39393a9d-52b6-4c26-9721-018e5ecc16ed",
	'');
INSERT INTO PE_PE
	VALUES ("fde2dcaf-3b9c-4652-818e-0b354fdc66fc",
	1,
	"fa715298-1ee7-4f4d-9dc6-ff741962c501",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO PE_PE
	VALUES ("fa715298-1ee7-4f4d-9dc6-ff741962c501",
	1,
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	7);
INSERT INTO S_SYS_PROXY
	VALUES ("e1ca632b-b51d-48ee-b1a8-9539fcd49828",
	'stratus',
	1,
	'../stratus.xtuml');
